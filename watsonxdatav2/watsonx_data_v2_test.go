/**
 * (C) Copyright IBM Corp. 2024.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package watsonxdatav2_test

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/http/httptest"
	"os"
	"time"

	"github.com/IBM/go-sdk-core/v5/core"
	"github.com/IBM/watsonxdata-go-sdk/watsonxdatav2"
	"github.com/go-openapi/strfmt"
	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
)

var _ = Describe(`WatsonxDataV2`, func() {
	var testServer *httptest.Server
	Describe(`Service constructor tests`, func() {
		It(`Instantiate service client`, func() {
			watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
				Authenticator: &core.NoAuthAuthenticator{},
			})
			Expect(watsonxDataService).ToNot(BeNil())
			Expect(serviceErr).To(BeNil())
		})
		It(`Instantiate service client with error: Invalid URL`, func() {
			watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
				URL: "{BAD_URL_STRING",
			})
			Expect(watsonxDataService).To(BeNil())
			Expect(serviceErr).ToNot(BeNil())
		})
		It(`Instantiate service client with error: Invalid Auth`, func() {
			watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
				URL: "https://watsonxdatav2/api",
				Authenticator: &core.BasicAuthenticator{
					Username: "",
					Password: "",
				},
			})
			Expect(watsonxDataService).To(BeNil())
			Expect(serviceErr).ToNot(BeNil())
		})
	})
	Describe(`Service constructor tests using external config`, func() {
		Context(`Using external config, construct service client instances`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"WATSONX_DATA_URL": "https://watsonxdatav2/api",
				"WATSONX_DATA_AUTH_TYPE": "noauth",
			}

			It(`Create service client using external config successfully`, func() {
				SetTestEnvironment(testEnvironment)
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2UsingExternalConfig(&watsonxdatav2.WatsonxDataV2Options{
				})
				Expect(watsonxDataService).ToNot(BeNil())
				Expect(serviceErr).To(BeNil())
				ClearTestEnvironment(testEnvironment)

				clone := watsonxDataService.Clone()
				Expect(clone).ToNot(BeNil())
				Expect(clone.Service != watsonxDataService.Service).To(BeTrue())
				Expect(clone.GetServiceURL()).To(Equal(watsonxDataService.GetServiceURL()))
				Expect(clone.Service.Options.Authenticator).To(Equal(watsonxDataService.Service.Options.Authenticator))
			})
			It(`Create service client using external config and set url from constructor successfully`, func() {
				SetTestEnvironment(testEnvironment)
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2UsingExternalConfig(&watsonxdatav2.WatsonxDataV2Options{
					URL: "https://testService/api",
				})
				Expect(watsonxDataService).ToNot(BeNil())
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService.Service.GetServiceURL()).To(Equal("https://testService/api"))
				ClearTestEnvironment(testEnvironment)

				clone := watsonxDataService.Clone()
				Expect(clone).ToNot(BeNil())
				Expect(clone.Service != watsonxDataService.Service).To(BeTrue())
				Expect(clone.GetServiceURL()).To(Equal(watsonxDataService.GetServiceURL()))
				Expect(clone.Service.Options.Authenticator).To(Equal(watsonxDataService.Service.Options.Authenticator))
			})
			It(`Create service client using external config and set url programatically successfully`, func() {
				SetTestEnvironment(testEnvironment)
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2UsingExternalConfig(&watsonxdatav2.WatsonxDataV2Options{
				})
				err := watsonxDataService.SetServiceURL("https://testService/api")
				Expect(err).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService.Service.GetServiceURL()).To(Equal("https://testService/api"))
				ClearTestEnvironment(testEnvironment)

				clone := watsonxDataService.Clone()
				Expect(clone).ToNot(BeNil())
				Expect(clone.Service != watsonxDataService.Service).To(BeTrue())
				Expect(clone.GetServiceURL()).To(Equal(watsonxDataService.GetServiceURL()))
				Expect(clone.Service.Options.Authenticator).To(Equal(watsonxDataService.Service.Options.Authenticator))
			})
		})
		Context(`Using external config, construct service client instances with error: Invalid Auth`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"WATSONX_DATA_URL": "https://watsonxdatav2/api",
				"WATSONX_DATA_AUTH_TYPE": "someOtherAuth",
			}

			SetTestEnvironment(testEnvironment)
			watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2UsingExternalConfig(&watsonxdatav2.WatsonxDataV2Options{
			})

			It(`Instantiate service client with error`, func() {
				Expect(watsonxDataService).To(BeNil())
				Expect(serviceErr).ToNot(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
		})
		Context(`Using external config, construct service client instances with error: Invalid URL`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"WATSONX_DATA_AUTH_TYPE":   "NOAuth",
			}

			SetTestEnvironment(testEnvironment)
			watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2UsingExternalConfig(&watsonxdatav2.WatsonxDataV2Options{
				URL: "{BAD_URL_STRING",
			})

			It(`Instantiate service client with error`, func() {
				Expect(watsonxDataService).To(BeNil())
				Expect(serviceErr).ToNot(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
		})
	})
	Describe(`Regional endpoint tests`, func() {
		It(`GetServiceURLForRegion(region string)`, func() {
			var url string
			var err error
			url, err = watsonxdatav2.GetServiceURLForRegion("INVALID_REGION")
			Expect(url).To(BeEmpty())
			Expect(err).ToNot(BeNil())
			fmt.Fprintf(GinkgoWriter, "Expected error: %s\n", err.Error())
		})
	})
	Describe(`ListBucketRegistrations(listBucketRegistrationsOptions *ListBucketRegistrationsOptions) - Operation response error`, func() {
		listBucketRegistrationsPath := "/bucket_registrations"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listBucketRegistrationsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListBucketRegistrations with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListBucketRegistrationsOptions model
				listBucketRegistrationsOptionsModel := new(watsonxdatav2.ListBucketRegistrationsOptions)
				listBucketRegistrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listBucketRegistrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListBucketRegistrations(listBucketRegistrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListBucketRegistrations(listBucketRegistrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListBucketRegistrations(listBucketRegistrationsOptions *ListBucketRegistrationsOptions)`, func() {
		listBucketRegistrationsPath := "/bucket_registrations"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listBucketRegistrationsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"bucket_registrations": [{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "bucket_details": {"access_key": "b9cbf248ea5c4c96947e64407108559j", "bucket_name": "sample-bucket", "endpoint": "https://s3.<region>.cloud-object-storage.appdomain.cloud/", "key_file": "key_file", "provider": "ibm_cos", "region": "us-south", "secret_key": "13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87"}, "bucket_display_name": "sample-bucket-displayname", "bucket_id": "samplebucket123", "bucket_type": "ibm_cos", "created_by": "<username>@<domain>.com", "created_on": "1686120645", "description": "COS bucket for customer data", "managed_by": "ibm", "region": "us-south", "state": "active", "storage_details": {"access_key": "<access_key>", "application_id": "<application_id>", "auth_mode": "<account_key/sas/service_principle>", "container_name": "sample-container", "directory_id": "<directory_id>", "endpoint": "abfss://<container_name>@<storage_account_name>.dfs.core.windows.net/", "sas_token": "<sas_token>", "secret_key": "secret_key", "storage_account_name": "sample-storage"}, "tags": ["Tags"]}]}`)
				}))
			})
			It(`Invoke ListBucketRegistrations successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListBucketRegistrationsOptions model
				listBucketRegistrationsOptionsModel := new(watsonxdatav2.ListBucketRegistrationsOptions)
				listBucketRegistrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listBucketRegistrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListBucketRegistrationsWithContext(ctx, listBucketRegistrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListBucketRegistrations(listBucketRegistrationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListBucketRegistrationsWithContext(ctx, listBucketRegistrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listBucketRegistrationsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"bucket_registrations": [{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "bucket_details": {"access_key": "b9cbf248ea5c4c96947e64407108559j", "bucket_name": "sample-bucket", "endpoint": "https://s3.<region>.cloud-object-storage.appdomain.cloud/", "key_file": "key_file", "provider": "ibm_cos", "region": "us-south", "secret_key": "13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87"}, "bucket_display_name": "sample-bucket-displayname", "bucket_id": "samplebucket123", "bucket_type": "ibm_cos", "created_by": "<username>@<domain>.com", "created_on": "1686120645", "description": "COS bucket for customer data", "managed_by": "ibm", "region": "us-south", "state": "active", "storage_details": {"access_key": "<access_key>", "application_id": "<application_id>", "auth_mode": "<account_key/sas/service_principle>", "container_name": "sample-container", "directory_id": "<directory_id>", "endpoint": "abfss://<container_name>@<storage_account_name>.dfs.core.windows.net/", "sas_token": "<sas_token>", "secret_key": "secret_key", "storage_account_name": "sample-storage"}, "tags": ["Tags"]}]}`)
				}))
			})
			It(`Invoke ListBucketRegistrations successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListBucketRegistrations(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListBucketRegistrationsOptions model
				listBucketRegistrationsOptionsModel := new(watsonxdatav2.ListBucketRegistrationsOptions)
				listBucketRegistrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listBucketRegistrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListBucketRegistrations(listBucketRegistrationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListBucketRegistrations with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListBucketRegistrationsOptions model
				listBucketRegistrationsOptionsModel := new(watsonxdatav2.ListBucketRegistrationsOptions)
				listBucketRegistrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listBucketRegistrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListBucketRegistrations(listBucketRegistrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListBucketRegistrations successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListBucketRegistrationsOptions model
				listBucketRegistrationsOptionsModel := new(watsonxdatav2.ListBucketRegistrationsOptions)
				listBucketRegistrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listBucketRegistrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListBucketRegistrations(listBucketRegistrationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateBucketRegistration(createBucketRegistrationOptions *CreateBucketRegistrationOptions) - Operation response error`, func() {
		createBucketRegistrationPath := "/bucket_registrations"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createBucketRegistrationPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateBucketRegistration with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the BucketCatalog model
				bucketCatalogModel := new(watsonxdatav2.BucketCatalog)
				bucketCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				bucketCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				bucketCatalogModel.CatalogType = core.StringPtr("iceberg")

				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.KeyFile = core.StringPtr("key_file")
				bucketDetailsModel.Provider = core.StringPtr("ibm_cos")
				bucketDetailsModel.Region = core.StringPtr("us-south")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

				// Construct an instance of the StorageDetails model
				storageDetailsModel := new(watsonxdatav2.StorageDetails)
				storageDetailsModel.AccessKey = core.StringPtr("<access_key>")
				storageDetailsModel.ApplicationID = core.StringPtr("<application_id>")
				storageDetailsModel.AuthMode = core.StringPtr("<account_key/sas/service_principle>")
				storageDetailsModel.ContainerName = core.StringPtr("sample-container")
				storageDetailsModel.DirectoryID = core.StringPtr("<directory_id>")
				storageDetailsModel.Endpoint = core.StringPtr("abfss://<container_name>@<storage_account_name>.dfs.core.windows.net/")
				storageDetailsModel.SasToken = core.StringPtr("<sas_token>")
				storageDetailsModel.SecretKey = core.StringPtr("secret_key")
				storageDetailsModel.StorageAccountName = core.StringPtr("sample-storage")

				// Construct an instance of the CreateBucketRegistrationOptions model
				createBucketRegistrationOptionsModel := new(watsonxdatav2.CreateBucketRegistrationOptions)
				createBucketRegistrationOptionsModel.BucketType = core.StringPtr("ibm_cos")
				createBucketRegistrationOptionsModel.Description = core.StringPtr("COS bucket for customer data")
				createBucketRegistrationOptionsModel.ManagedBy = core.StringPtr("ibm")
				createBucketRegistrationOptionsModel.AssociatedCatalog = bucketCatalogModel
				createBucketRegistrationOptionsModel.BucketDetails = bucketDetailsModel
				createBucketRegistrationOptionsModel.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
				createBucketRegistrationOptionsModel.Region = core.StringPtr("us-south")
				createBucketRegistrationOptionsModel.StorageDetails = storageDetailsModel
				createBucketRegistrationOptionsModel.Tags = []string{"bucket-tag1", "bucket-tag2"}
				createBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateBucketRegistration(createBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateBucketRegistration(createBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateBucketRegistration(createBucketRegistrationOptions *CreateBucketRegistrationOptions)`, func() {
		createBucketRegistrationPath := "/bucket_registrations"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createBucketRegistrationPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "bucket_details": {"access_key": "b9cbf248ea5c4c96947e64407108559j", "bucket_name": "sample-bucket", "endpoint": "https://s3.<region>.cloud-object-storage.appdomain.cloud/", "key_file": "key_file", "provider": "ibm_cos", "region": "us-south", "secret_key": "13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87"}, "bucket_display_name": "sample-bucket-displayname", "bucket_id": "samplebucket123", "bucket_type": "ibm_cos", "created_by": "<username>@<domain>.com", "created_on": "1686120645", "description": "COS bucket for customer data", "managed_by": "ibm", "region": "us-south", "state": "active", "storage_details": {"access_key": "<access_key>", "application_id": "<application_id>", "auth_mode": "<account_key/sas/service_principle>", "container_name": "sample-container", "directory_id": "<directory_id>", "endpoint": "abfss://<container_name>@<storage_account_name>.dfs.core.windows.net/", "sas_token": "<sas_token>", "secret_key": "secret_key", "storage_account_name": "sample-storage"}, "tags": ["Tags"]}`)
				}))
			})
			It(`Invoke CreateBucketRegistration successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the BucketCatalog model
				bucketCatalogModel := new(watsonxdatav2.BucketCatalog)
				bucketCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				bucketCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				bucketCatalogModel.CatalogType = core.StringPtr("iceberg")

				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.KeyFile = core.StringPtr("key_file")
				bucketDetailsModel.Provider = core.StringPtr("ibm_cos")
				bucketDetailsModel.Region = core.StringPtr("us-south")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

				// Construct an instance of the StorageDetails model
				storageDetailsModel := new(watsonxdatav2.StorageDetails)
				storageDetailsModel.AccessKey = core.StringPtr("<access_key>")
				storageDetailsModel.ApplicationID = core.StringPtr("<application_id>")
				storageDetailsModel.AuthMode = core.StringPtr("<account_key/sas/service_principle>")
				storageDetailsModel.ContainerName = core.StringPtr("sample-container")
				storageDetailsModel.DirectoryID = core.StringPtr("<directory_id>")
				storageDetailsModel.Endpoint = core.StringPtr("abfss://<container_name>@<storage_account_name>.dfs.core.windows.net/")
				storageDetailsModel.SasToken = core.StringPtr("<sas_token>")
				storageDetailsModel.SecretKey = core.StringPtr("secret_key")
				storageDetailsModel.StorageAccountName = core.StringPtr("sample-storage")

				// Construct an instance of the CreateBucketRegistrationOptions model
				createBucketRegistrationOptionsModel := new(watsonxdatav2.CreateBucketRegistrationOptions)
				createBucketRegistrationOptionsModel.BucketType = core.StringPtr("ibm_cos")
				createBucketRegistrationOptionsModel.Description = core.StringPtr("COS bucket for customer data")
				createBucketRegistrationOptionsModel.ManagedBy = core.StringPtr("ibm")
				createBucketRegistrationOptionsModel.AssociatedCatalog = bucketCatalogModel
				createBucketRegistrationOptionsModel.BucketDetails = bucketDetailsModel
				createBucketRegistrationOptionsModel.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
				createBucketRegistrationOptionsModel.Region = core.StringPtr("us-south")
				createBucketRegistrationOptionsModel.StorageDetails = storageDetailsModel
				createBucketRegistrationOptionsModel.Tags = []string{"bucket-tag1", "bucket-tag2"}
				createBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateBucketRegistrationWithContext(ctx, createBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateBucketRegistration(createBucketRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateBucketRegistrationWithContext(ctx, createBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createBucketRegistrationPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "bucket_details": {"access_key": "b9cbf248ea5c4c96947e64407108559j", "bucket_name": "sample-bucket", "endpoint": "https://s3.<region>.cloud-object-storage.appdomain.cloud/", "key_file": "key_file", "provider": "ibm_cos", "region": "us-south", "secret_key": "13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87"}, "bucket_display_name": "sample-bucket-displayname", "bucket_id": "samplebucket123", "bucket_type": "ibm_cos", "created_by": "<username>@<domain>.com", "created_on": "1686120645", "description": "COS bucket for customer data", "managed_by": "ibm", "region": "us-south", "state": "active", "storage_details": {"access_key": "<access_key>", "application_id": "<application_id>", "auth_mode": "<account_key/sas/service_principle>", "container_name": "sample-container", "directory_id": "<directory_id>", "endpoint": "abfss://<container_name>@<storage_account_name>.dfs.core.windows.net/", "sas_token": "<sas_token>", "secret_key": "secret_key", "storage_account_name": "sample-storage"}, "tags": ["Tags"]}`)
				}))
			})
			It(`Invoke CreateBucketRegistration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateBucketRegistration(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the BucketCatalog model
				bucketCatalogModel := new(watsonxdatav2.BucketCatalog)
				bucketCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				bucketCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				bucketCatalogModel.CatalogType = core.StringPtr("iceberg")

				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.KeyFile = core.StringPtr("key_file")
				bucketDetailsModel.Provider = core.StringPtr("ibm_cos")
				bucketDetailsModel.Region = core.StringPtr("us-south")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

				// Construct an instance of the StorageDetails model
				storageDetailsModel := new(watsonxdatav2.StorageDetails)
				storageDetailsModel.AccessKey = core.StringPtr("<access_key>")
				storageDetailsModel.ApplicationID = core.StringPtr("<application_id>")
				storageDetailsModel.AuthMode = core.StringPtr("<account_key/sas/service_principle>")
				storageDetailsModel.ContainerName = core.StringPtr("sample-container")
				storageDetailsModel.DirectoryID = core.StringPtr("<directory_id>")
				storageDetailsModel.Endpoint = core.StringPtr("abfss://<container_name>@<storage_account_name>.dfs.core.windows.net/")
				storageDetailsModel.SasToken = core.StringPtr("<sas_token>")
				storageDetailsModel.SecretKey = core.StringPtr("secret_key")
				storageDetailsModel.StorageAccountName = core.StringPtr("sample-storage")

				// Construct an instance of the CreateBucketRegistrationOptions model
				createBucketRegistrationOptionsModel := new(watsonxdatav2.CreateBucketRegistrationOptions)
				createBucketRegistrationOptionsModel.BucketType = core.StringPtr("ibm_cos")
				createBucketRegistrationOptionsModel.Description = core.StringPtr("COS bucket for customer data")
				createBucketRegistrationOptionsModel.ManagedBy = core.StringPtr("ibm")
				createBucketRegistrationOptionsModel.AssociatedCatalog = bucketCatalogModel
				createBucketRegistrationOptionsModel.BucketDetails = bucketDetailsModel
				createBucketRegistrationOptionsModel.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
				createBucketRegistrationOptionsModel.Region = core.StringPtr("us-south")
				createBucketRegistrationOptionsModel.StorageDetails = storageDetailsModel
				createBucketRegistrationOptionsModel.Tags = []string{"bucket-tag1", "bucket-tag2"}
				createBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateBucketRegistration(createBucketRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateBucketRegistration with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the BucketCatalog model
				bucketCatalogModel := new(watsonxdatav2.BucketCatalog)
				bucketCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				bucketCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				bucketCatalogModel.CatalogType = core.StringPtr("iceberg")

				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.KeyFile = core.StringPtr("key_file")
				bucketDetailsModel.Provider = core.StringPtr("ibm_cos")
				bucketDetailsModel.Region = core.StringPtr("us-south")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

				// Construct an instance of the StorageDetails model
				storageDetailsModel := new(watsonxdatav2.StorageDetails)
				storageDetailsModel.AccessKey = core.StringPtr("<access_key>")
				storageDetailsModel.ApplicationID = core.StringPtr("<application_id>")
				storageDetailsModel.AuthMode = core.StringPtr("<account_key/sas/service_principle>")
				storageDetailsModel.ContainerName = core.StringPtr("sample-container")
				storageDetailsModel.DirectoryID = core.StringPtr("<directory_id>")
				storageDetailsModel.Endpoint = core.StringPtr("abfss://<container_name>@<storage_account_name>.dfs.core.windows.net/")
				storageDetailsModel.SasToken = core.StringPtr("<sas_token>")
				storageDetailsModel.SecretKey = core.StringPtr("secret_key")
				storageDetailsModel.StorageAccountName = core.StringPtr("sample-storage")

				// Construct an instance of the CreateBucketRegistrationOptions model
				createBucketRegistrationOptionsModel := new(watsonxdatav2.CreateBucketRegistrationOptions)
				createBucketRegistrationOptionsModel.BucketType = core.StringPtr("ibm_cos")
				createBucketRegistrationOptionsModel.Description = core.StringPtr("COS bucket for customer data")
				createBucketRegistrationOptionsModel.ManagedBy = core.StringPtr("ibm")
				createBucketRegistrationOptionsModel.AssociatedCatalog = bucketCatalogModel
				createBucketRegistrationOptionsModel.BucketDetails = bucketDetailsModel
				createBucketRegistrationOptionsModel.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
				createBucketRegistrationOptionsModel.Region = core.StringPtr("us-south")
				createBucketRegistrationOptionsModel.StorageDetails = storageDetailsModel
				createBucketRegistrationOptionsModel.Tags = []string{"bucket-tag1", "bucket-tag2"}
				createBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateBucketRegistration(createBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateBucketRegistrationOptions model with no property values
				createBucketRegistrationOptionsModelNew := new(watsonxdatav2.CreateBucketRegistrationOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateBucketRegistration(createBucketRegistrationOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateBucketRegistration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the BucketCatalog model
				bucketCatalogModel := new(watsonxdatav2.BucketCatalog)
				bucketCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				bucketCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				bucketCatalogModel.CatalogType = core.StringPtr("iceberg")

				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.KeyFile = core.StringPtr("key_file")
				bucketDetailsModel.Provider = core.StringPtr("ibm_cos")
				bucketDetailsModel.Region = core.StringPtr("us-south")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

				// Construct an instance of the StorageDetails model
				storageDetailsModel := new(watsonxdatav2.StorageDetails)
				storageDetailsModel.AccessKey = core.StringPtr("<access_key>")
				storageDetailsModel.ApplicationID = core.StringPtr("<application_id>")
				storageDetailsModel.AuthMode = core.StringPtr("<account_key/sas/service_principle>")
				storageDetailsModel.ContainerName = core.StringPtr("sample-container")
				storageDetailsModel.DirectoryID = core.StringPtr("<directory_id>")
				storageDetailsModel.Endpoint = core.StringPtr("abfss://<container_name>@<storage_account_name>.dfs.core.windows.net/")
				storageDetailsModel.SasToken = core.StringPtr("<sas_token>")
				storageDetailsModel.SecretKey = core.StringPtr("secret_key")
				storageDetailsModel.StorageAccountName = core.StringPtr("sample-storage")

				// Construct an instance of the CreateBucketRegistrationOptions model
				createBucketRegistrationOptionsModel := new(watsonxdatav2.CreateBucketRegistrationOptions)
				createBucketRegistrationOptionsModel.BucketType = core.StringPtr("ibm_cos")
				createBucketRegistrationOptionsModel.Description = core.StringPtr("COS bucket for customer data")
				createBucketRegistrationOptionsModel.ManagedBy = core.StringPtr("ibm")
				createBucketRegistrationOptionsModel.AssociatedCatalog = bucketCatalogModel
				createBucketRegistrationOptionsModel.BucketDetails = bucketDetailsModel
				createBucketRegistrationOptionsModel.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
				createBucketRegistrationOptionsModel.Region = core.StringPtr("us-south")
				createBucketRegistrationOptionsModel.StorageDetails = storageDetailsModel
				createBucketRegistrationOptionsModel.Tags = []string{"bucket-tag1", "bucket-tag2"}
				createBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateBucketRegistration(createBucketRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetBucketRegistration(getBucketRegistrationOptions *GetBucketRegistrationOptions) - Operation response error`, func() {
		getBucketRegistrationPath := "/bucket_registrations/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getBucketRegistrationPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetBucketRegistration with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetBucketRegistrationOptions model
				getBucketRegistrationOptionsModel := new(watsonxdatav2.GetBucketRegistrationOptions)
				getBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				getBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetBucketRegistration(getBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetBucketRegistration(getBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetBucketRegistration(getBucketRegistrationOptions *GetBucketRegistrationOptions)`, func() {
		getBucketRegistrationPath := "/bucket_registrations/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getBucketRegistrationPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "bucket_details": {"access_key": "b9cbf248ea5c4c96947e64407108559j", "bucket_name": "sample-bucket", "endpoint": "https://s3.<region>.cloud-object-storage.appdomain.cloud/", "key_file": "key_file", "provider": "ibm_cos", "region": "us-south", "secret_key": "13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87"}, "bucket_display_name": "sample-bucket-displayname", "bucket_id": "samplebucket123", "bucket_type": "ibm_cos", "created_by": "<username>@<domain>.com", "created_on": "1686120645", "description": "COS bucket for customer data", "managed_by": "ibm", "region": "us-south", "state": "active", "storage_details": {"access_key": "<access_key>", "application_id": "<application_id>", "auth_mode": "<account_key/sas/service_principle>", "container_name": "sample-container", "directory_id": "<directory_id>", "endpoint": "abfss://<container_name>@<storage_account_name>.dfs.core.windows.net/", "sas_token": "<sas_token>", "secret_key": "secret_key", "storage_account_name": "sample-storage"}, "tags": ["Tags"]}`)
				}))
			})
			It(`Invoke GetBucketRegistration successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetBucketRegistrationOptions model
				getBucketRegistrationOptionsModel := new(watsonxdatav2.GetBucketRegistrationOptions)
				getBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				getBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetBucketRegistrationWithContext(ctx, getBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetBucketRegistration(getBucketRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetBucketRegistrationWithContext(ctx, getBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getBucketRegistrationPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "bucket_details": {"access_key": "b9cbf248ea5c4c96947e64407108559j", "bucket_name": "sample-bucket", "endpoint": "https://s3.<region>.cloud-object-storage.appdomain.cloud/", "key_file": "key_file", "provider": "ibm_cos", "region": "us-south", "secret_key": "13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87"}, "bucket_display_name": "sample-bucket-displayname", "bucket_id": "samplebucket123", "bucket_type": "ibm_cos", "created_by": "<username>@<domain>.com", "created_on": "1686120645", "description": "COS bucket for customer data", "managed_by": "ibm", "region": "us-south", "state": "active", "storage_details": {"access_key": "<access_key>", "application_id": "<application_id>", "auth_mode": "<account_key/sas/service_principle>", "container_name": "sample-container", "directory_id": "<directory_id>", "endpoint": "abfss://<container_name>@<storage_account_name>.dfs.core.windows.net/", "sas_token": "<sas_token>", "secret_key": "secret_key", "storage_account_name": "sample-storage"}, "tags": ["Tags"]}`)
				}))
			})
			It(`Invoke GetBucketRegistration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetBucketRegistration(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetBucketRegistrationOptions model
				getBucketRegistrationOptionsModel := new(watsonxdatav2.GetBucketRegistrationOptions)
				getBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				getBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetBucketRegistration(getBucketRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetBucketRegistration with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetBucketRegistrationOptions model
				getBucketRegistrationOptionsModel := new(watsonxdatav2.GetBucketRegistrationOptions)
				getBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				getBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetBucketRegistration(getBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetBucketRegistrationOptions model with no property values
				getBucketRegistrationOptionsModelNew := new(watsonxdatav2.GetBucketRegistrationOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetBucketRegistration(getBucketRegistrationOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetBucketRegistration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetBucketRegistrationOptions model
				getBucketRegistrationOptionsModel := new(watsonxdatav2.GetBucketRegistrationOptions)
				getBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				getBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetBucketRegistration(getBucketRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteBucketRegistration(deleteBucketRegistrationOptions *DeleteBucketRegistrationOptions)`, func() {
		deleteBucketRegistrationPath := "/bucket_registrations/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteBucketRegistrationPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteBucketRegistration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteBucketRegistration(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteBucketRegistrationOptions model
				deleteBucketRegistrationOptionsModel := new(watsonxdatav2.DeleteBucketRegistrationOptions)
				deleteBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				deleteBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteBucketRegistration(deleteBucketRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteBucketRegistration with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteBucketRegistrationOptions model
				deleteBucketRegistrationOptionsModel := new(watsonxdatav2.DeleteBucketRegistrationOptions)
				deleteBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				deleteBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteBucketRegistration(deleteBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteBucketRegistrationOptions model with no property values
				deleteBucketRegistrationOptionsModelNew := new(watsonxdatav2.DeleteBucketRegistrationOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteBucketRegistration(deleteBucketRegistrationOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateBucketRegistration(updateBucketRegistrationOptions *UpdateBucketRegistrationOptions) - Operation response error`, func() {
		updateBucketRegistrationPath := "/bucket_registrations/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateBucketRegistrationPath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateBucketRegistration with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.KeyFile = core.StringPtr("key_file")
				bucketDetailsModel.Provider = core.StringPtr("ibm_cos")
				bucketDetailsModel.Region = core.StringPtr("us-south")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

				// Construct an instance of the BucketRegistrationPatch model
				bucketRegistrationPatchModel := new(watsonxdatav2.BucketRegistrationPatch)
				bucketRegistrationPatchModel.BucketDetails = bucketDetailsModel
				bucketRegistrationPatchModel.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
				bucketRegistrationPatchModel.Description = core.StringPtr("COS bucket for customer data")
				bucketRegistrationPatchModel.Tags = []string{"testbucket", "userbucket"}
				bucketRegistrationPatchModelAsPatch, asPatchErr := bucketRegistrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateBucketRegistrationOptions model
				updateBucketRegistrationOptionsModel := new(watsonxdatav2.UpdateBucketRegistrationOptions)
				updateBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				updateBucketRegistrationOptionsModel.Body = bucketRegistrationPatchModelAsPatch
				updateBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdateBucketRegistration(updateBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdateBucketRegistration(updateBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateBucketRegistration(updateBucketRegistrationOptions *UpdateBucketRegistrationOptions)`, func() {
		updateBucketRegistrationPath := "/bucket_registrations/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateBucketRegistrationPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "bucket_details": {"access_key": "b9cbf248ea5c4c96947e64407108559j", "bucket_name": "sample-bucket", "endpoint": "https://s3.<region>.cloud-object-storage.appdomain.cloud/", "key_file": "key_file", "provider": "ibm_cos", "region": "us-south", "secret_key": "13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87"}, "bucket_display_name": "sample-bucket-displayname", "bucket_id": "samplebucket123", "bucket_type": "ibm_cos", "created_by": "<username>@<domain>.com", "created_on": "1686120645", "description": "COS bucket for customer data", "managed_by": "ibm", "region": "us-south", "state": "active", "storage_details": {"access_key": "<access_key>", "application_id": "<application_id>", "auth_mode": "<account_key/sas/service_principle>", "container_name": "sample-container", "directory_id": "<directory_id>", "endpoint": "abfss://<container_name>@<storage_account_name>.dfs.core.windows.net/", "sas_token": "<sas_token>", "secret_key": "secret_key", "storage_account_name": "sample-storage"}, "tags": ["Tags"]}`)
				}))
			})
			It(`Invoke UpdateBucketRegistration successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.KeyFile = core.StringPtr("key_file")
				bucketDetailsModel.Provider = core.StringPtr("ibm_cos")
				bucketDetailsModel.Region = core.StringPtr("us-south")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

				// Construct an instance of the BucketRegistrationPatch model
				bucketRegistrationPatchModel := new(watsonxdatav2.BucketRegistrationPatch)
				bucketRegistrationPatchModel.BucketDetails = bucketDetailsModel
				bucketRegistrationPatchModel.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
				bucketRegistrationPatchModel.Description = core.StringPtr("COS bucket for customer data")
				bucketRegistrationPatchModel.Tags = []string{"testbucket", "userbucket"}
				bucketRegistrationPatchModelAsPatch, asPatchErr := bucketRegistrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateBucketRegistrationOptions model
				updateBucketRegistrationOptionsModel := new(watsonxdatav2.UpdateBucketRegistrationOptions)
				updateBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				updateBucketRegistrationOptionsModel.Body = bucketRegistrationPatchModelAsPatch
				updateBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdateBucketRegistrationWithContext(ctx, updateBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdateBucketRegistration(updateBucketRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdateBucketRegistrationWithContext(ctx, updateBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateBucketRegistrationPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "bucket_details": {"access_key": "b9cbf248ea5c4c96947e64407108559j", "bucket_name": "sample-bucket", "endpoint": "https://s3.<region>.cloud-object-storage.appdomain.cloud/", "key_file": "key_file", "provider": "ibm_cos", "region": "us-south", "secret_key": "13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87"}, "bucket_display_name": "sample-bucket-displayname", "bucket_id": "samplebucket123", "bucket_type": "ibm_cos", "created_by": "<username>@<domain>.com", "created_on": "1686120645", "description": "COS bucket for customer data", "managed_by": "ibm", "region": "us-south", "state": "active", "storage_details": {"access_key": "<access_key>", "application_id": "<application_id>", "auth_mode": "<account_key/sas/service_principle>", "container_name": "sample-container", "directory_id": "<directory_id>", "endpoint": "abfss://<container_name>@<storage_account_name>.dfs.core.windows.net/", "sas_token": "<sas_token>", "secret_key": "secret_key", "storage_account_name": "sample-storage"}, "tags": ["Tags"]}`)
				}))
			})
			It(`Invoke UpdateBucketRegistration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdateBucketRegistration(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.KeyFile = core.StringPtr("key_file")
				bucketDetailsModel.Provider = core.StringPtr("ibm_cos")
				bucketDetailsModel.Region = core.StringPtr("us-south")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

				// Construct an instance of the BucketRegistrationPatch model
				bucketRegistrationPatchModel := new(watsonxdatav2.BucketRegistrationPatch)
				bucketRegistrationPatchModel.BucketDetails = bucketDetailsModel
				bucketRegistrationPatchModel.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
				bucketRegistrationPatchModel.Description = core.StringPtr("COS bucket for customer data")
				bucketRegistrationPatchModel.Tags = []string{"testbucket", "userbucket"}
				bucketRegistrationPatchModelAsPatch, asPatchErr := bucketRegistrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateBucketRegistrationOptions model
				updateBucketRegistrationOptionsModel := new(watsonxdatav2.UpdateBucketRegistrationOptions)
				updateBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				updateBucketRegistrationOptionsModel.Body = bucketRegistrationPatchModelAsPatch
				updateBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdateBucketRegistration(updateBucketRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateBucketRegistration with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.KeyFile = core.StringPtr("key_file")
				bucketDetailsModel.Provider = core.StringPtr("ibm_cos")
				bucketDetailsModel.Region = core.StringPtr("us-south")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

				// Construct an instance of the BucketRegistrationPatch model
				bucketRegistrationPatchModel := new(watsonxdatav2.BucketRegistrationPatch)
				bucketRegistrationPatchModel.BucketDetails = bucketDetailsModel
				bucketRegistrationPatchModel.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
				bucketRegistrationPatchModel.Description = core.StringPtr("COS bucket for customer data")
				bucketRegistrationPatchModel.Tags = []string{"testbucket", "userbucket"}
				bucketRegistrationPatchModelAsPatch, asPatchErr := bucketRegistrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateBucketRegistrationOptions model
				updateBucketRegistrationOptionsModel := new(watsonxdatav2.UpdateBucketRegistrationOptions)
				updateBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				updateBucketRegistrationOptionsModel.Body = bucketRegistrationPatchModelAsPatch
				updateBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdateBucketRegistration(updateBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateBucketRegistrationOptions model with no property values
				updateBucketRegistrationOptionsModelNew := new(watsonxdatav2.UpdateBucketRegistrationOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdateBucketRegistration(updateBucketRegistrationOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateBucketRegistration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.KeyFile = core.StringPtr("key_file")
				bucketDetailsModel.Provider = core.StringPtr("ibm_cos")
				bucketDetailsModel.Region = core.StringPtr("us-south")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

				// Construct an instance of the BucketRegistrationPatch model
				bucketRegistrationPatchModel := new(watsonxdatav2.BucketRegistrationPatch)
				bucketRegistrationPatchModel.BucketDetails = bucketDetailsModel
				bucketRegistrationPatchModel.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
				bucketRegistrationPatchModel.Description = core.StringPtr("COS bucket for customer data")
				bucketRegistrationPatchModel.Tags = []string{"testbucket", "userbucket"}
				bucketRegistrationPatchModelAsPatch, asPatchErr := bucketRegistrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateBucketRegistrationOptions model
				updateBucketRegistrationOptionsModel := new(watsonxdatav2.UpdateBucketRegistrationOptions)
				updateBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				updateBucketRegistrationOptionsModel.Body = bucketRegistrationPatchModelAsPatch
				updateBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdateBucketRegistration(updateBucketRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateActivateBucket(createActivateBucketOptions *CreateActivateBucketOptions) - Operation response error`, func() {
		createActivateBucketPath := "/bucket_registrations/testString/activate"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createActivateBucketPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateActivateBucket with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateActivateBucketOptions model
				createActivateBucketOptionsModel := new(watsonxdatav2.CreateActivateBucketOptions)
				createActivateBucketOptionsModel.BucketID = core.StringPtr("testString")
				createActivateBucketOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createActivateBucketOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateActivateBucket(createActivateBucketOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateActivateBucket(createActivateBucketOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateActivateBucket(createActivateBucketOptions *CreateActivateBucketOptions)`, func() {
		createActivateBucketPath := "/bucket_registrations/testString/activate"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createActivateBucketPath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke CreateActivateBucket successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreateActivateBucketOptions model
				createActivateBucketOptionsModel := new(watsonxdatav2.CreateActivateBucketOptions)
				createActivateBucketOptionsModel.BucketID = core.StringPtr("testString")
				createActivateBucketOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createActivateBucketOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateActivateBucketWithContext(ctx, createActivateBucketOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateActivateBucket(createActivateBucketOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateActivateBucketWithContext(ctx, createActivateBucketOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createActivateBucketPath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke CreateActivateBucket successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateActivateBucket(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreateActivateBucketOptions model
				createActivateBucketOptionsModel := new(watsonxdatav2.CreateActivateBucketOptions)
				createActivateBucketOptionsModel.BucketID = core.StringPtr("testString")
				createActivateBucketOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createActivateBucketOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateActivateBucket(createActivateBucketOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateActivateBucket with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateActivateBucketOptions model
				createActivateBucketOptionsModel := new(watsonxdatav2.CreateActivateBucketOptions)
				createActivateBucketOptionsModel.BucketID = core.StringPtr("testString")
				createActivateBucketOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createActivateBucketOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateActivateBucket(createActivateBucketOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateActivateBucketOptions model with no property values
				createActivateBucketOptionsModelNew := new(watsonxdatav2.CreateActivateBucketOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateActivateBucket(createActivateBucketOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateActivateBucket successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateActivateBucketOptions model
				createActivateBucketOptionsModel := new(watsonxdatav2.CreateActivateBucketOptions)
				createActivateBucketOptionsModel.BucketID = core.StringPtr("testString")
				createActivateBucketOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createActivateBucketOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateActivateBucket(createActivateBucketOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteDeactivateBucket(deleteDeactivateBucketOptions *DeleteDeactivateBucketOptions)`, func() {
		deleteDeactivateBucketPath := "/bucket_registrations/testString/deactivate"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteDeactivateBucketPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteDeactivateBucket successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteDeactivateBucket(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteDeactivateBucketOptions model
				deleteDeactivateBucketOptionsModel := new(watsonxdatav2.DeleteDeactivateBucketOptions)
				deleteDeactivateBucketOptionsModel.BucketID = core.StringPtr("testString")
				deleteDeactivateBucketOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteDeactivateBucketOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteDeactivateBucket(deleteDeactivateBucketOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteDeactivateBucket with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteDeactivateBucketOptions model
				deleteDeactivateBucketOptionsModel := new(watsonxdatav2.DeleteDeactivateBucketOptions)
				deleteDeactivateBucketOptionsModel.BucketID = core.StringPtr("testString")
				deleteDeactivateBucketOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteDeactivateBucketOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteDeactivateBucket(deleteDeactivateBucketOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteDeactivateBucketOptions model with no property values
				deleteDeactivateBucketOptionsModelNew := new(watsonxdatav2.DeleteDeactivateBucketOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteDeactivateBucket(deleteDeactivateBucketOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListBucketObjects(listBucketObjectsOptions *ListBucketObjectsOptions) - Operation response error`, func() {
		listBucketObjectsPath := "/bucket_registrations/testString/objects"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listBucketObjectsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["path"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListBucketObjects with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListBucketObjectsOptions model
				listBucketObjectsOptionsModel := new(watsonxdatav2.ListBucketObjectsOptions)
				listBucketObjectsOptionsModel.BucketID = core.StringPtr("testString")
				listBucketObjectsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listBucketObjectsOptionsModel.Path = core.StringPtr("testString")
				listBucketObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListBucketObjects(listBucketObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListBucketObjects(listBucketObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListBucketObjects(listBucketObjectsOptions *ListBucketObjectsOptions)`, func() {
		listBucketObjectsPath := "/bucket_registrations/testString/objects"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listBucketObjectsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["path"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"objects": ["Objects"]}`)
				}))
			})
			It(`Invoke ListBucketObjects successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListBucketObjectsOptions model
				listBucketObjectsOptionsModel := new(watsonxdatav2.ListBucketObjectsOptions)
				listBucketObjectsOptionsModel.BucketID = core.StringPtr("testString")
				listBucketObjectsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listBucketObjectsOptionsModel.Path = core.StringPtr("testString")
				listBucketObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListBucketObjectsWithContext(ctx, listBucketObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListBucketObjects(listBucketObjectsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListBucketObjectsWithContext(ctx, listBucketObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listBucketObjectsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["path"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"objects": ["Objects"]}`)
				}))
			})
			It(`Invoke ListBucketObjects successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListBucketObjects(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListBucketObjectsOptions model
				listBucketObjectsOptionsModel := new(watsonxdatav2.ListBucketObjectsOptions)
				listBucketObjectsOptionsModel.BucketID = core.StringPtr("testString")
				listBucketObjectsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listBucketObjectsOptionsModel.Path = core.StringPtr("testString")
				listBucketObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListBucketObjects(listBucketObjectsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListBucketObjects with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListBucketObjectsOptions model
				listBucketObjectsOptionsModel := new(watsonxdatav2.ListBucketObjectsOptions)
				listBucketObjectsOptionsModel.BucketID = core.StringPtr("testString")
				listBucketObjectsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listBucketObjectsOptionsModel.Path = core.StringPtr("testString")
				listBucketObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListBucketObjects(listBucketObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListBucketObjectsOptions model with no property values
				listBucketObjectsOptionsModelNew := new(watsonxdatav2.ListBucketObjectsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListBucketObjects(listBucketObjectsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListBucketObjects successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListBucketObjectsOptions model
				listBucketObjectsOptionsModel := new(watsonxdatav2.ListBucketObjectsOptions)
				listBucketObjectsOptionsModel.BucketID = core.StringPtr("testString")
				listBucketObjectsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listBucketObjectsOptionsModel.Path = core.StringPtr("testString")
				listBucketObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListBucketObjects(listBucketObjectsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetBucketObjectProperties(getBucketObjectPropertiesOptions *GetBucketObjectPropertiesOptions) - Operation response error`, func() {
		getBucketObjectPropertiesPath := "/bucket_registrations/testString/object_properties"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getBucketObjectPropertiesPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetBucketObjectProperties with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the Path model
				pathModel := new(watsonxdatav2.Path)
				pathModel.Path = core.StringPtr("string")

				// Construct an instance of the GetBucketObjectPropertiesOptions model
				getBucketObjectPropertiesOptionsModel := new(watsonxdatav2.GetBucketObjectPropertiesOptions)
				getBucketObjectPropertiesOptionsModel.BucketID = core.StringPtr("testString")
				getBucketObjectPropertiesOptionsModel.Paths = []watsonxdatav2.Path{*pathModel}
				getBucketObjectPropertiesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getBucketObjectPropertiesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetBucketObjectProperties(getBucketObjectPropertiesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetBucketObjectProperties(getBucketObjectPropertiesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetBucketObjectProperties(getBucketObjectPropertiesOptions *GetBucketObjectPropertiesOptions)`, func() {
		getBucketObjectPropertiesPath := "/bucket_registrations/testString/object_properties"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getBucketObjectPropertiesPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"object_properties": [{"content_type": "string", "file_type": "string", "last_modified": "utc-2014-07", "metadata": {"mapKey": "Inner"}, "path": "abc/abc/data", "size": "1024"}]}`)
				}))
			})
			It(`Invoke GetBucketObjectProperties successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the Path model
				pathModel := new(watsonxdatav2.Path)
				pathModel.Path = core.StringPtr("string")

				// Construct an instance of the GetBucketObjectPropertiesOptions model
				getBucketObjectPropertiesOptionsModel := new(watsonxdatav2.GetBucketObjectPropertiesOptions)
				getBucketObjectPropertiesOptionsModel.BucketID = core.StringPtr("testString")
				getBucketObjectPropertiesOptionsModel.Paths = []watsonxdatav2.Path{*pathModel}
				getBucketObjectPropertiesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getBucketObjectPropertiesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetBucketObjectPropertiesWithContext(ctx, getBucketObjectPropertiesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetBucketObjectProperties(getBucketObjectPropertiesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetBucketObjectPropertiesWithContext(ctx, getBucketObjectPropertiesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getBucketObjectPropertiesPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"object_properties": [{"content_type": "string", "file_type": "string", "last_modified": "utc-2014-07", "metadata": {"mapKey": "Inner"}, "path": "abc/abc/data", "size": "1024"}]}`)
				}))
			})
			It(`Invoke GetBucketObjectProperties successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetBucketObjectProperties(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Path model
				pathModel := new(watsonxdatav2.Path)
				pathModel.Path = core.StringPtr("string")

				// Construct an instance of the GetBucketObjectPropertiesOptions model
				getBucketObjectPropertiesOptionsModel := new(watsonxdatav2.GetBucketObjectPropertiesOptions)
				getBucketObjectPropertiesOptionsModel.BucketID = core.StringPtr("testString")
				getBucketObjectPropertiesOptionsModel.Paths = []watsonxdatav2.Path{*pathModel}
				getBucketObjectPropertiesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getBucketObjectPropertiesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetBucketObjectProperties(getBucketObjectPropertiesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetBucketObjectProperties with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the Path model
				pathModel := new(watsonxdatav2.Path)
				pathModel.Path = core.StringPtr("string")

				// Construct an instance of the GetBucketObjectPropertiesOptions model
				getBucketObjectPropertiesOptionsModel := new(watsonxdatav2.GetBucketObjectPropertiesOptions)
				getBucketObjectPropertiesOptionsModel.BucketID = core.StringPtr("testString")
				getBucketObjectPropertiesOptionsModel.Paths = []watsonxdatav2.Path{*pathModel}
				getBucketObjectPropertiesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getBucketObjectPropertiesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetBucketObjectProperties(getBucketObjectPropertiesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetBucketObjectPropertiesOptions model with no property values
				getBucketObjectPropertiesOptionsModelNew := new(watsonxdatav2.GetBucketObjectPropertiesOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetBucketObjectProperties(getBucketObjectPropertiesOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke GetBucketObjectProperties successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the Path model
				pathModel := new(watsonxdatav2.Path)
				pathModel.Path = core.StringPtr("string")

				// Construct an instance of the GetBucketObjectPropertiesOptions model
				getBucketObjectPropertiesOptionsModel := new(watsonxdatav2.GetBucketObjectPropertiesOptions)
				getBucketObjectPropertiesOptionsModel.BucketID = core.StringPtr("testString")
				getBucketObjectPropertiesOptionsModel.Paths = []watsonxdatav2.Path{*pathModel}
				getBucketObjectPropertiesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getBucketObjectPropertiesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetBucketObjectProperties(getBucketObjectPropertiesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateHdfsStorage(createHdfsStorageOptions *CreateHdfsStorageOptions) - Operation response error`, func() {
		createHdfsStoragePath := "/storage_hdfs_registrations"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createHdfsStoragePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateHdfsStorage with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateHdfsStorageOptions model
				createHdfsStorageOptionsModel := new(watsonxdatav2.CreateHdfsStorageOptions)
				createHdfsStorageOptionsModel.BucketDisplayName = core.StringPtr("testString")
				createHdfsStorageOptionsModel.BucketType = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HmsThriftURI = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HmsThriftPort = core.Int64Ptr(int64(1))
				createHdfsStorageOptionsModel.CoreSite = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HdfsSite = core.StringPtr("testString")
				createHdfsStorageOptionsModel.Kerberos = core.StringPtr("testString")
				createHdfsStorageOptionsModel.CatalogName = core.StringPtr("testString")
				createHdfsStorageOptionsModel.CatalogType = core.StringPtr("testString")
				createHdfsStorageOptionsModel.Krb5Config = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HiveKeytab = CreateMockReader("This is a mock file.")
				createHdfsStorageOptionsModel.HiveKeytabContentType = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HdfsKeytab = CreateMockReader("This is a mock file.")
				createHdfsStorageOptionsModel.HdfsKeytabContentType = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HiveServerPrincipal = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HiveClientPrincipal = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HdfsPrincipal = core.StringPtr("testString")
				createHdfsStorageOptionsModel.Description = core.StringPtr("testString")
				createHdfsStorageOptionsModel.CreatedOn = core.StringPtr("testString")
				createHdfsStorageOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createHdfsStorageOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateHdfsStorage(createHdfsStorageOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateHdfsStorage(createHdfsStorageOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateHdfsStorage(createHdfsStorageOptions *CreateHdfsStorageOptions)`, func() {
		createHdfsStoragePath := "/storage_hdfs_registrations"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createHdfsStoragePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "bucket_display_name": "sample hdfs displayname", "bucket_id": "hdfs123", "bucket_type": "hdfs", "created_by": "<username>@<domain>.com", "created_on": "1686120645", "description": "HDFS description for storage", "managed_by": "customer", "state": "active", "tags": ["Tags"]}`)
				}))
			})
			It(`Invoke CreateHdfsStorage successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreateHdfsStorageOptions model
				createHdfsStorageOptionsModel := new(watsonxdatav2.CreateHdfsStorageOptions)
				createHdfsStorageOptionsModel.BucketDisplayName = core.StringPtr("testString")
				createHdfsStorageOptionsModel.BucketType = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HmsThriftURI = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HmsThriftPort = core.Int64Ptr(int64(1))
				createHdfsStorageOptionsModel.CoreSite = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HdfsSite = core.StringPtr("testString")
				createHdfsStorageOptionsModel.Kerberos = core.StringPtr("testString")
				createHdfsStorageOptionsModel.CatalogName = core.StringPtr("testString")
				createHdfsStorageOptionsModel.CatalogType = core.StringPtr("testString")
				createHdfsStorageOptionsModel.Krb5Config = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HiveKeytab = CreateMockReader("This is a mock file.")
				createHdfsStorageOptionsModel.HiveKeytabContentType = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HdfsKeytab = CreateMockReader("This is a mock file.")
				createHdfsStorageOptionsModel.HdfsKeytabContentType = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HiveServerPrincipal = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HiveClientPrincipal = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HdfsPrincipal = core.StringPtr("testString")
				createHdfsStorageOptionsModel.Description = core.StringPtr("testString")
				createHdfsStorageOptionsModel.CreatedOn = core.StringPtr("testString")
				createHdfsStorageOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createHdfsStorageOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateHdfsStorageWithContext(ctx, createHdfsStorageOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateHdfsStorage(createHdfsStorageOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateHdfsStorageWithContext(ctx, createHdfsStorageOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createHdfsStoragePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "bucket_display_name": "sample hdfs displayname", "bucket_id": "hdfs123", "bucket_type": "hdfs", "created_by": "<username>@<domain>.com", "created_on": "1686120645", "description": "HDFS description for storage", "managed_by": "customer", "state": "active", "tags": ["Tags"]}`)
				}))
			})
			It(`Invoke CreateHdfsStorage successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateHdfsStorage(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreateHdfsStorageOptions model
				createHdfsStorageOptionsModel := new(watsonxdatav2.CreateHdfsStorageOptions)
				createHdfsStorageOptionsModel.BucketDisplayName = core.StringPtr("testString")
				createHdfsStorageOptionsModel.BucketType = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HmsThriftURI = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HmsThriftPort = core.Int64Ptr(int64(1))
				createHdfsStorageOptionsModel.CoreSite = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HdfsSite = core.StringPtr("testString")
				createHdfsStorageOptionsModel.Kerberos = core.StringPtr("testString")
				createHdfsStorageOptionsModel.CatalogName = core.StringPtr("testString")
				createHdfsStorageOptionsModel.CatalogType = core.StringPtr("testString")
				createHdfsStorageOptionsModel.Krb5Config = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HiveKeytab = CreateMockReader("This is a mock file.")
				createHdfsStorageOptionsModel.HiveKeytabContentType = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HdfsKeytab = CreateMockReader("This is a mock file.")
				createHdfsStorageOptionsModel.HdfsKeytabContentType = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HiveServerPrincipal = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HiveClientPrincipal = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HdfsPrincipal = core.StringPtr("testString")
				createHdfsStorageOptionsModel.Description = core.StringPtr("testString")
				createHdfsStorageOptionsModel.CreatedOn = core.StringPtr("testString")
				createHdfsStorageOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createHdfsStorageOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateHdfsStorage(createHdfsStorageOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateHdfsStorage with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateHdfsStorageOptions model
				createHdfsStorageOptionsModel := new(watsonxdatav2.CreateHdfsStorageOptions)
				createHdfsStorageOptionsModel.BucketDisplayName = core.StringPtr("testString")
				createHdfsStorageOptionsModel.BucketType = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HmsThriftURI = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HmsThriftPort = core.Int64Ptr(int64(1))
				createHdfsStorageOptionsModel.CoreSite = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HdfsSite = core.StringPtr("testString")
				createHdfsStorageOptionsModel.Kerberos = core.StringPtr("testString")
				createHdfsStorageOptionsModel.CatalogName = core.StringPtr("testString")
				createHdfsStorageOptionsModel.CatalogType = core.StringPtr("testString")
				createHdfsStorageOptionsModel.Krb5Config = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HiveKeytab = CreateMockReader("This is a mock file.")
				createHdfsStorageOptionsModel.HiveKeytabContentType = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HdfsKeytab = CreateMockReader("This is a mock file.")
				createHdfsStorageOptionsModel.HdfsKeytabContentType = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HiveServerPrincipal = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HiveClientPrincipal = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HdfsPrincipal = core.StringPtr("testString")
				createHdfsStorageOptionsModel.Description = core.StringPtr("testString")
				createHdfsStorageOptionsModel.CreatedOn = core.StringPtr("testString")
				createHdfsStorageOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createHdfsStorageOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateHdfsStorage(createHdfsStorageOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateHdfsStorageOptions model with no property values
				createHdfsStorageOptionsModelNew := new(watsonxdatav2.CreateHdfsStorageOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateHdfsStorage(createHdfsStorageOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateHdfsStorage successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateHdfsStorageOptions model
				createHdfsStorageOptionsModel := new(watsonxdatav2.CreateHdfsStorageOptions)
				createHdfsStorageOptionsModel.BucketDisplayName = core.StringPtr("testString")
				createHdfsStorageOptionsModel.BucketType = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HmsThriftURI = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HmsThriftPort = core.Int64Ptr(int64(1))
				createHdfsStorageOptionsModel.CoreSite = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HdfsSite = core.StringPtr("testString")
				createHdfsStorageOptionsModel.Kerberos = core.StringPtr("testString")
				createHdfsStorageOptionsModel.CatalogName = core.StringPtr("testString")
				createHdfsStorageOptionsModel.CatalogType = core.StringPtr("testString")
				createHdfsStorageOptionsModel.Krb5Config = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HiveKeytab = CreateMockReader("This is a mock file.")
				createHdfsStorageOptionsModel.HiveKeytabContentType = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HdfsKeytab = CreateMockReader("This is a mock file.")
				createHdfsStorageOptionsModel.HdfsKeytabContentType = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HiveServerPrincipal = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HiveClientPrincipal = core.StringPtr("testString")
				createHdfsStorageOptionsModel.HdfsPrincipal = core.StringPtr("testString")
				createHdfsStorageOptionsModel.Description = core.StringPtr("testString")
				createHdfsStorageOptionsModel.CreatedOn = core.StringPtr("testString")
				createHdfsStorageOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createHdfsStorageOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateHdfsStorage(createHdfsStorageOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListDatabaseRegistrations(listDatabaseRegistrationsOptions *ListDatabaseRegistrationsOptions) - Operation response error`, func() {
		listDatabaseRegistrationsPath := "/database_registrations"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listDatabaseRegistrationsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListDatabaseRegistrations with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListDatabaseRegistrationsOptions model
				listDatabaseRegistrationsOptionsModel := new(watsonxdatav2.ListDatabaseRegistrationsOptions)
				listDatabaseRegistrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listDatabaseRegistrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListDatabaseRegistrations(listDatabaseRegistrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListDatabaseRegistrations(listDatabaseRegistrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListDatabaseRegistrations(listDatabaseRegistrationsOptions *ListDatabaseRegistrationsOptions)`, func() {
		listDatabaseRegistrationsPath := "/database_registrations"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listDatabaseRegistrationsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"database_registrations": [{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "catalog_name": "sampleCatalog", "created_by": "user1@bim.com", "created_on": "1686792721", "database_details": {"authentication_type": "LDAP", "authentication_value": "LDAP", "broker_authentication_password": "samplepassword", "broker_authentication_type": "PASSWORD", "broker_authentication_user": "sampleuser", "broker_host": "samplehost", "broker_port": 4553, "certificate": "contents of a pem/crt file", "certificate_extension": "pem/crt", "connection_method": "basic, apikey", "connection_mode": "service_name", "connection_mode_value": "orclpdb", "connection_type": "JDBC, Arrow flight", "controller_authentication_password": "samplepassword", "controller_authentication_type": "PASSWORD", "controller_authentication_user": "sampleuser", "coordinator_host": "samplehost", "coordinator_port": 4553, "cpd_hostname": "samplecpdhostname", "credentials_key": "eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......", "database_name": "new_database", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "hostname": "db2@<hostname>.com", "hostname_in_certificate": "samplehostname", "hosts": "abc.com:1234,xyz.com:4321", "informix_server": "ol_informix1410", "password": "samplepassword", "port": 4553, "project_id": "conops-bigquery", "sasl": true, "sasl_mechanism": "plain", "schema_name": "sampleSchema", "schemas": "redis__name", "service_api_key": "sampleapikey", "service_hostname": "api.dataplatform.dev.cloud.ibm.com", "service_password": "samplepassword", "service_port": 443, "service_ssl": true, "service_token_url": "sampletoakenurl", "service_username": "sampleusername", "ssl": true, "tables": "kafka_table_name, redis_table_name", "username": "sampleuser", "validate_server_certificate": true, "verify_host_name": true, "warehouse_name": "samplewrehouse"}, "database_display_name": "new_database", "database_id": "new_database_id", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "database_type": "netezza", "tables": [{"created_on": "1686792721", "file_contents": "sample file content", "file_name": "sample file name", "schema_name": "customer", "table_name": "customer"}], "description": "Description of the external database", "tags": ["Tags"], "topics": [{"created_on": "1686792721", "file_contents": "sample file content", "file_name": "sample file name", "topic_name": "customer"}]}]}`)
				}))
			})
			It(`Invoke ListDatabaseRegistrations successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListDatabaseRegistrationsOptions model
				listDatabaseRegistrationsOptionsModel := new(watsonxdatav2.ListDatabaseRegistrationsOptions)
				listDatabaseRegistrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listDatabaseRegistrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListDatabaseRegistrationsWithContext(ctx, listDatabaseRegistrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListDatabaseRegistrations(listDatabaseRegistrationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListDatabaseRegistrationsWithContext(ctx, listDatabaseRegistrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listDatabaseRegistrationsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"database_registrations": [{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "catalog_name": "sampleCatalog", "created_by": "user1@bim.com", "created_on": "1686792721", "database_details": {"authentication_type": "LDAP", "authentication_value": "LDAP", "broker_authentication_password": "samplepassword", "broker_authentication_type": "PASSWORD", "broker_authentication_user": "sampleuser", "broker_host": "samplehost", "broker_port": 4553, "certificate": "contents of a pem/crt file", "certificate_extension": "pem/crt", "connection_method": "basic, apikey", "connection_mode": "service_name", "connection_mode_value": "orclpdb", "connection_type": "JDBC, Arrow flight", "controller_authentication_password": "samplepassword", "controller_authentication_type": "PASSWORD", "controller_authentication_user": "sampleuser", "coordinator_host": "samplehost", "coordinator_port": 4553, "cpd_hostname": "samplecpdhostname", "credentials_key": "eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......", "database_name": "new_database", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "hostname": "db2@<hostname>.com", "hostname_in_certificate": "samplehostname", "hosts": "abc.com:1234,xyz.com:4321", "informix_server": "ol_informix1410", "password": "samplepassword", "port": 4553, "project_id": "conops-bigquery", "sasl": true, "sasl_mechanism": "plain", "schema_name": "sampleSchema", "schemas": "redis__name", "service_api_key": "sampleapikey", "service_hostname": "api.dataplatform.dev.cloud.ibm.com", "service_password": "samplepassword", "service_port": 443, "service_ssl": true, "service_token_url": "sampletoakenurl", "service_username": "sampleusername", "ssl": true, "tables": "kafka_table_name, redis_table_name", "username": "sampleuser", "validate_server_certificate": true, "verify_host_name": true, "warehouse_name": "samplewrehouse"}, "database_display_name": "new_database", "database_id": "new_database_id", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "database_type": "netezza", "tables": [{"created_on": "1686792721", "file_contents": "sample file content", "file_name": "sample file name", "schema_name": "customer", "table_name": "customer"}], "description": "Description of the external database", "tags": ["Tags"], "topics": [{"created_on": "1686792721", "file_contents": "sample file content", "file_name": "sample file name", "topic_name": "customer"}]}]}`)
				}))
			})
			It(`Invoke ListDatabaseRegistrations successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListDatabaseRegistrations(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListDatabaseRegistrationsOptions model
				listDatabaseRegistrationsOptionsModel := new(watsonxdatav2.ListDatabaseRegistrationsOptions)
				listDatabaseRegistrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listDatabaseRegistrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListDatabaseRegistrations(listDatabaseRegistrationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListDatabaseRegistrations with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListDatabaseRegistrationsOptions model
				listDatabaseRegistrationsOptionsModel := new(watsonxdatav2.ListDatabaseRegistrationsOptions)
				listDatabaseRegistrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listDatabaseRegistrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListDatabaseRegistrations(listDatabaseRegistrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListDatabaseRegistrations successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListDatabaseRegistrationsOptions model
				listDatabaseRegistrationsOptionsModel := new(watsonxdatav2.ListDatabaseRegistrationsOptions)
				listDatabaseRegistrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listDatabaseRegistrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListDatabaseRegistrations(listDatabaseRegistrationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateDatabaseRegistration(createDatabaseRegistrationOptions *CreateDatabaseRegistrationOptions) - Operation response error`, func() {
		createDatabaseRegistrationPath := "/database_registrations"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createDatabaseRegistrationPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateDatabaseRegistration with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DatabaseCatalog model
				databaseCatalogModel := new(watsonxdatav2.DatabaseCatalog)
				databaseCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				databaseCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				databaseCatalogModel.CatalogType = core.StringPtr("iceberg")

				// Construct an instance of the DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems model
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems)
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")

				// Construct an instance of the DatabaseDetails model
				databaseDetailsModel := new(watsonxdatav2.DatabaseDetails)
				databaseDetailsModel.AuthenticationType = core.StringPtr("LDAP")
				databaseDetailsModel.AuthenticationValue = core.StringPtr("LDAP")
				databaseDetailsModel.BrokerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseDetailsModel.BrokerAuthenticationType = core.StringPtr("PASSWORD")
				databaseDetailsModel.BrokerAuthenticationUser = core.StringPtr("sampleuser")
				databaseDetailsModel.BrokerHost = core.StringPtr("samplehost")
				databaseDetailsModel.BrokerPort = core.Int64Ptr(int64(4553))
				databaseDetailsModel.Certificate = core.StringPtr("contents of a pem/crt file")
				databaseDetailsModel.CertificateExtension = core.StringPtr("pem/crt")
				databaseDetailsModel.ConnectionMethod = core.StringPtr("basic, apikey")
				databaseDetailsModel.ConnectionMode = core.StringPtr("service_name")
				databaseDetailsModel.ConnectionModeValue = core.StringPtr("orclpdb")
				databaseDetailsModel.ConnectionType = core.StringPtr("JDBC, Arrow flight")
				databaseDetailsModel.ControllerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseDetailsModel.ControllerAuthenticationType = core.StringPtr("PASSWORD")
				databaseDetailsModel.ControllerAuthenticationUser = core.StringPtr("sampleuser")
				databaseDetailsModel.CoordinatorHost = core.StringPtr("samplehost")
				databaseDetailsModel.CoordinatorPort = core.Int64Ptr(int64(4553))
				databaseDetailsModel.CpdHostname = core.StringPtr("samplecpdhostname")
				databaseDetailsModel.CredentialsKey = core.StringPtr("eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......")
				databaseDetailsModel.DatabaseName = core.StringPtr("new_database")
				databaseDetailsModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems{*databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel}
				databaseDetailsModel.Hostname = core.StringPtr("db2@<hostname>.com")
				databaseDetailsModel.HostnameInCertificate = core.StringPtr("samplehostname")
				databaseDetailsModel.Hosts = core.StringPtr("abc.com:1234,xyz.com:4321")
				databaseDetailsModel.InformixServer = core.StringPtr("ol_informix1410")
				databaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseDetailsModel.Port = core.Int64Ptr(int64(4553))
				databaseDetailsModel.ProjectID = core.StringPtr("conops-bigquery")
				databaseDetailsModel.Sasl = core.BoolPtr(true)
				databaseDetailsModel.SaslMechanism = core.StringPtr("plain")
				databaseDetailsModel.SchemaName = core.StringPtr("sampleSchema")
				databaseDetailsModel.Schemas = core.StringPtr("redis__name")
				databaseDetailsModel.ServiceApiKey = core.StringPtr("sampleapikey")
				databaseDetailsModel.ServiceHostname = core.StringPtr("api.dataplatform.dev.cloud.ibm.com")
				databaseDetailsModel.ServicePassword = core.StringPtr("samplepassword")
				databaseDetailsModel.ServicePort = core.Int64Ptr(int64(443))
				databaseDetailsModel.ServiceSsl = core.BoolPtr(true)
				databaseDetailsModel.ServiceTokenURL = core.StringPtr("sampletoakenurl")
				databaseDetailsModel.ServiceUsername = core.StringPtr("sampleusername")
				databaseDetailsModel.Ssl = core.BoolPtr(true)
				databaseDetailsModel.Tables = core.StringPtr("kafka_table_name, redis_table_name")
				databaseDetailsModel.Username = core.StringPtr("sampleuser")
				databaseDetailsModel.ValidateServerCertificate = core.BoolPtr(true)
				databaseDetailsModel.VerifyHostName = core.BoolPtr(true)
				databaseDetailsModel.WarehouseName = core.StringPtr("samplewrehouse")

				// Construct an instance of the DatabaseRegistrationPrototypeDatabasePropertiesItems model
				databaseRegistrationPrototypeDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")

				// Construct an instance of the CreateDatabaseRegistrationOptions model
				createDatabaseRegistrationOptionsModel := new(watsonxdatav2.CreateDatabaseRegistrationOptions)
				createDatabaseRegistrationOptionsModel.DatabaseDisplayName = core.StringPtr("new_database")
				createDatabaseRegistrationOptionsModel.DatabaseType = core.StringPtr("db2")
				createDatabaseRegistrationOptionsModel.AssociatedCatalog = databaseCatalogModel
				createDatabaseRegistrationOptionsModel.CreatedOn = core.StringPtr("1686792721")
				createDatabaseRegistrationOptionsModel.DatabaseDetails = databaseDetailsModel
				createDatabaseRegistrationOptionsModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems{*databaseRegistrationPrototypeDatabasePropertiesItemsModel}
				createDatabaseRegistrationOptionsModel.Description = core.StringPtr("db2 extenal database description")
				createDatabaseRegistrationOptionsModel.Tags = []string{"testdatabase", "userdatabase"}
				createDatabaseRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createDatabaseRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateDatabaseRegistration(createDatabaseRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateDatabaseRegistration(createDatabaseRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateDatabaseRegistration(createDatabaseRegistrationOptions *CreateDatabaseRegistrationOptions)`, func() {
		createDatabaseRegistrationPath := "/database_registrations"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createDatabaseRegistrationPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "catalog_name": "sampleCatalog", "created_by": "user1@bim.com", "created_on": "1686792721", "database_details": {"authentication_type": "LDAP", "authentication_value": "LDAP", "broker_authentication_password": "samplepassword", "broker_authentication_type": "PASSWORD", "broker_authentication_user": "sampleuser", "broker_host": "samplehost", "broker_port": 4553, "certificate": "contents of a pem/crt file", "certificate_extension": "pem/crt", "connection_method": "basic, apikey", "connection_mode": "service_name", "connection_mode_value": "orclpdb", "connection_type": "JDBC, Arrow flight", "controller_authentication_password": "samplepassword", "controller_authentication_type": "PASSWORD", "controller_authentication_user": "sampleuser", "coordinator_host": "samplehost", "coordinator_port": 4553, "cpd_hostname": "samplecpdhostname", "credentials_key": "eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......", "database_name": "new_database", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "hostname": "db2@<hostname>.com", "hostname_in_certificate": "samplehostname", "hosts": "abc.com:1234,xyz.com:4321", "informix_server": "ol_informix1410", "password": "samplepassword", "port": 4553, "project_id": "conops-bigquery", "sasl": true, "sasl_mechanism": "plain", "schema_name": "sampleSchema", "schemas": "redis__name", "service_api_key": "sampleapikey", "service_hostname": "api.dataplatform.dev.cloud.ibm.com", "service_password": "samplepassword", "service_port": 443, "service_ssl": true, "service_token_url": "sampletoakenurl", "service_username": "sampleusername", "ssl": true, "tables": "kafka_table_name, redis_table_name", "username": "sampleuser", "validate_server_certificate": true, "verify_host_name": true, "warehouse_name": "samplewrehouse"}, "database_display_name": "new_database", "database_id": "new_database_id", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "database_type": "netezza", "tables": [{"created_on": "1686792721", "file_contents": "sample file content", "file_name": "sample file name", "schema_name": "customer", "table_name": "customer"}], "description": "Description of the external database", "tags": ["Tags"], "topics": [{"created_on": "1686792721", "file_contents": "sample file content", "file_name": "sample file name", "topic_name": "customer"}]}`)
				}))
			})
			It(`Invoke CreateDatabaseRegistration successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the DatabaseCatalog model
				databaseCatalogModel := new(watsonxdatav2.DatabaseCatalog)
				databaseCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				databaseCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				databaseCatalogModel.CatalogType = core.StringPtr("iceberg")

				// Construct an instance of the DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems model
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems)
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")

				// Construct an instance of the DatabaseDetails model
				databaseDetailsModel := new(watsonxdatav2.DatabaseDetails)
				databaseDetailsModel.AuthenticationType = core.StringPtr("LDAP")
				databaseDetailsModel.AuthenticationValue = core.StringPtr("LDAP")
				databaseDetailsModel.BrokerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseDetailsModel.BrokerAuthenticationType = core.StringPtr("PASSWORD")
				databaseDetailsModel.BrokerAuthenticationUser = core.StringPtr("sampleuser")
				databaseDetailsModel.BrokerHost = core.StringPtr("samplehost")
				databaseDetailsModel.BrokerPort = core.Int64Ptr(int64(4553))
				databaseDetailsModel.Certificate = core.StringPtr("contents of a pem/crt file")
				databaseDetailsModel.CertificateExtension = core.StringPtr("pem/crt")
				databaseDetailsModel.ConnectionMethod = core.StringPtr("basic, apikey")
				databaseDetailsModel.ConnectionMode = core.StringPtr("service_name")
				databaseDetailsModel.ConnectionModeValue = core.StringPtr("orclpdb")
				databaseDetailsModel.ConnectionType = core.StringPtr("JDBC, Arrow flight")
				databaseDetailsModel.ControllerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseDetailsModel.ControllerAuthenticationType = core.StringPtr("PASSWORD")
				databaseDetailsModel.ControllerAuthenticationUser = core.StringPtr("sampleuser")
				databaseDetailsModel.CoordinatorHost = core.StringPtr("samplehost")
				databaseDetailsModel.CoordinatorPort = core.Int64Ptr(int64(4553))
				databaseDetailsModel.CpdHostname = core.StringPtr("samplecpdhostname")
				databaseDetailsModel.CredentialsKey = core.StringPtr("eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......")
				databaseDetailsModel.DatabaseName = core.StringPtr("new_database")
				databaseDetailsModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems{*databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel}
				databaseDetailsModel.Hostname = core.StringPtr("db2@<hostname>.com")
				databaseDetailsModel.HostnameInCertificate = core.StringPtr("samplehostname")
				databaseDetailsModel.Hosts = core.StringPtr("abc.com:1234,xyz.com:4321")
				databaseDetailsModel.InformixServer = core.StringPtr("ol_informix1410")
				databaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseDetailsModel.Port = core.Int64Ptr(int64(4553))
				databaseDetailsModel.ProjectID = core.StringPtr("conops-bigquery")
				databaseDetailsModel.Sasl = core.BoolPtr(true)
				databaseDetailsModel.SaslMechanism = core.StringPtr("plain")
				databaseDetailsModel.SchemaName = core.StringPtr("sampleSchema")
				databaseDetailsModel.Schemas = core.StringPtr("redis__name")
				databaseDetailsModel.ServiceApiKey = core.StringPtr("sampleapikey")
				databaseDetailsModel.ServiceHostname = core.StringPtr("api.dataplatform.dev.cloud.ibm.com")
				databaseDetailsModel.ServicePassword = core.StringPtr("samplepassword")
				databaseDetailsModel.ServicePort = core.Int64Ptr(int64(443))
				databaseDetailsModel.ServiceSsl = core.BoolPtr(true)
				databaseDetailsModel.ServiceTokenURL = core.StringPtr("sampletoakenurl")
				databaseDetailsModel.ServiceUsername = core.StringPtr("sampleusername")
				databaseDetailsModel.Ssl = core.BoolPtr(true)
				databaseDetailsModel.Tables = core.StringPtr("kafka_table_name, redis_table_name")
				databaseDetailsModel.Username = core.StringPtr("sampleuser")
				databaseDetailsModel.ValidateServerCertificate = core.BoolPtr(true)
				databaseDetailsModel.VerifyHostName = core.BoolPtr(true)
				databaseDetailsModel.WarehouseName = core.StringPtr("samplewrehouse")

				// Construct an instance of the DatabaseRegistrationPrototypeDatabasePropertiesItems model
				databaseRegistrationPrototypeDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")

				// Construct an instance of the CreateDatabaseRegistrationOptions model
				createDatabaseRegistrationOptionsModel := new(watsonxdatav2.CreateDatabaseRegistrationOptions)
				createDatabaseRegistrationOptionsModel.DatabaseDisplayName = core.StringPtr("new_database")
				createDatabaseRegistrationOptionsModel.DatabaseType = core.StringPtr("db2")
				createDatabaseRegistrationOptionsModel.AssociatedCatalog = databaseCatalogModel
				createDatabaseRegistrationOptionsModel.CreatedOn = core.StringPtr("1686792721")
				createDatabaseRegistrationOptionsModel.DatabaseDetails = databaseDetailsModel
				createDatabaseRegistrationOptionsModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems{*databaseRegistrationPrototypeDatabasePropertiesItemsModel}
				createDatabaseRegistrationOptionsModel.Description = core.StringPtr("db2 extenal database description")
				createDatabaseRegistrationOptionsModel.Tags = []string{"testdatabase", "userdatabase"}
				createDatabaseRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createDatabaseRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateDatabaseRegistrationWithContext(ctx, createDatabaseRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateDatabaseRegistration(createDatabaseRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateDatabaseRegistrationWithContext(ctx, createDatabaseRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createDatabaseRegistrationPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "catalog_name": "sampleCatalog", "created_by": "user1@bim.com", "created_on": "1686792721", "database_details": {"authentication_type": "LDAP", "authentication_value": "LDAP", "broker_authentication_password": "samplepassword", "broker_authentication_type": "PASSWORD", "broker_authentication_user": "sampleuser", "broker_host": "samplehost", "broker_port": 4553, "certificate": "contents of a pem/crt file", "certificate_extension": "pem/crt", "connection_method": "basic, apikey", "connection_mode": "service_name", "connection_mode_value": "orclpdb", "connection_type": "JDBC, Arrow flight", "controller_authentication_password": "samplepassword", "controller_authentication_type": "PASSWORD", "controller_authentication_user": "sampleuser", "coordinator_host": "samplehost", "coordinator_port": 4553, "cpd_hostname": "samplecpdhostname", "credentials_key": "eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......", "database_name": "new_database", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "hostname": "db2@<hostname>.com", "hostname_in_certificate": "samplehostname", "hosts": "abc.com:1234,xyz.com:4321", "informix_server": "ol_informix1410", "password": "samplepassword", "port": 4553, "project_id": "conops-bigquery", "sasl": true, "sasl_mechanism": "plain", "schema_name": "sampleSchema", "schemas": "redis__name", "service_api_key": "sampleapikey", "service_hostname": "api.dataplatform.dev.cloud.ibm.com", "service_password": "samplepassword", "service_port": 443, "service_ssl": true, "service_token_url": "sampletoakenurl", "service_username": "sampleusername", "ssl": true, "tables": "kafka_table_name, redis_table_name", "username": "sampleuser", "validate_server_certificate": true, "verify_host_name": true, "warehouse_name": "samplewrehouse"}, "database_display_name": "new_database", "database_id": "new_database_id", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "database_type": "netezza", "tables": [{"created_on": "1686792721", "file_contents": "sample file content", "file_name": "sample file name", "schema_name": "customer", "table_name": "customer"}], "description": "Description of the external database", "tags": ["Tags"], "topics": [{"created_on": "1686792721", "file_contents": "sample file content", "file_name": "sample file name", "topic_name": "customer"}]}`)
				}))
			})
			It(`Invoke CreateDatabaseRegistration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateDatabaseRegistration(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the DatabaseCatalog model
				databaseCatalogModel := new(watsonxdatav2.DatabaseCatalog)
				databaseCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				databaseCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				databaseCatalogModel.CatalogType = core.StringPtr("iceberg")

				// Construct an instance of the DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems model
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems)
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")

				// Construct an instance of the DatabaseDetails model
				databaseDetailsModel := new(watsonxdatav2.DatabaseDetails)
				databaseDetailsModel.AuthenticationType = core.StringPtr("LDAP")
				databaseDetailsModel.AuthenticationValue = core.StringPtr("LDAP")
				databaseDetailsModel.BrokerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseDetailsModel.BrokerAuthenticationType = core.StringPtr("PASSWORD")
				databaseDetailsModel.BrokerAuthenticationUser = core.StringPtr("sampleuser")
				databaseDetailsModel.BrokerHost = core.StringPtr("samplehost")
				databaseDetailsModel.BrokerPort = core.Int64Ptr(int64(4553))
				databaseDetailsModel.Certificate = core.StringPtr("contents of a pem/crt file")
				databaseDetailsModel.CertificateExtension = core.StringPtr("pem/crt")
				databaseDetailsModel.ConnectionMethod = core.StringPtr("basic, apikey")
				databaseDetailsModel.ConnectionMode = core.StringPtr("service_name")
				databaseDetailsModel.ConnectionModeValue = core.StringPtr("orclpdb")
				databaseDetailsModel.ConnectionType = core.StringPtr("JDBC, Arrow flight")
				databaseDetailsModel.ControllerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseDetailsModel.ControllerAuthenticationType = core.StringPtr("PASSWORD")
				databaseDetailsModel.ControllerAuthenticationUser = core.StringPtr("sampleuser")
				databaseDetailsModel.CoordinatorHost = core.StringPtr("samplehost")
				databaseDetailsModel.CoordinatorPort = core.Int64Ptr(int64(4553))
				databaseDetailsModel.CpdHostname = core.StringPtr("samplecpdhostname")
				databaseDetailsModel.CredentialsKey = core.StringPtr("eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......")
				databaseDetailsModel.DatabaseName = core.StringPtr("new_database")
				databaseDetailsModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems{*databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel}
				databaseDetailsModel.Hostname = core.StringPtr("db2@<hostname>.com")
				databaseDetailsModel.HostnameInCertificate = core.StringPtr("samplehostname")
				databaseDetailsModel.Hosts = core.StringPtr("abc.com:1234,xyz.com:4321")
				databaseDetailsModel.InformixServer = core.StringPtr("ol_informix1410")
				databaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseDetailsModel.Port = core.Int64Ptr(int64(4553))
				databaseDetailsModel.ProjectID = core.StringPtr("conops-bigquery")
				databaseDetailsModel.Sasl = core.BoolPtr(true)
				databaseDetailsModel.SaslMechanism = core.StringPtr("plain")
				databaseDetailsModel.SchemaName = core.StringPtr("sampleSchema")
				databaseDetailsModel.Schemas = core.StringPtr("redis__name")
				databaseDetailsModel.ServiceApiKey = core.StringPtr("sampleapikey")
				databaseDetailsModel.ServiceHostname = core.StringPtr("api.dataplatform.dev.cloud.ibm.com")
				databaseDetailsModel.ServicePassword = core.StringPtr("samplepassword")
				databaseDetailsModel.ServicePort = core.Int64Ptr(int64(443))
				databaseDetailsModel.ServiceSsl = core.BoolPtr(true)
				databaseDetailsModel.ServiceTokenURL = core.StringPtr("sampletoakenurl")
				databaseDetailsModel.ServiceUsername = core.StringPtr("sampleusername")
				databaseDetailsModel.Ssl = core.BoolPtr(true)
				databaseDetailsModel.Tables = core.StringPtr("kafka_table_name, redis_table_name")
				databaseDetailsModel.Username = core.StringPtr("sampleuser")
				databaseDetailsModel.ValidateServerCertificate = core.BoolPtr(true)
				databaseDetailsModel.VerifyHostName = core.BoolPtr(true)
				databaseDetailsModel.WarehouseName = core.StringPtr("samplewrehouse")

				// Construct an instance of the DatabaseRegistrationPrototypeDatabasePropertiesItems model
				databaseRegistrationPrototypeDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")

				// Construct an instance of the CreateDatabaseRegistrationOptions model
				createDatabaseRegistrationOptionsModel := new(watsonxdatav2.CreateDatabaseRegistrationOptions)
				createDatabaseRegistrationOptionsModel.DatabaseDisplayName = core.StringPtr("new_database")
				createDatabaseRegistrationOptionsModel.DatabaseType = core.StringPtr("db2")
				createDatabaseRegistrationOptionsModel.AssociatedCatalog = databaseCatalogModel
				createDatabaseRegistrationOptionsModel.CreatedOn = core.StringPtr("1686792721")
				createDatabaseRegistrationOptionsModel.DatabaseDetails = databaseDetailsModel
				createDatabaseRegistrationOptionsModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems{*databaseRegistrationPrototypeDatabasePropertiesItemsModel}
				createDatabaseRegistrationOptionsModel.Description = core.StringPtr("db2 extenal database description")
				createDatabaseRegistrationOptionsModel.Tags = []string{"testdatabase", "userdatabase"}
				createDatabaseRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createDatabaseRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateDatabaseRegistration(createDatabaseRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateDatabaseRegistration with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DatabaseCatalog model
				databaseCatalogModel := new(watsonxdatav2.DatabaseCatalog)
				databaseCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				databaseCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				databaseCatalogModel.CatalogType = core.StringPtr("iceberg")

				// Construct an instance of the DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems model
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems)
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")

				// Construct an instance of the DatabaseDetails model
				databaseDetailsModel := new(watsonxdatav2.DatabaseDetails)
				databaseDetailsModel.AuthenticationType = core.StringPtr("LDAP")
				databaseDetailsModel.AuthenticationValue = core.StringPtr("LDAP")
				databaseDetailsModel.BrokerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseDetailsModel.BrokerAuthenticationType = core.StringPtr("PASSWORD")
				databaseDetailsModel.BrokerAuthenticationUser = core.StringPtr("sampleuser")
				databaseDetailsModel.BrokerHost = core.StringPtr("samplehost")
				databaseDetailsModel.BrokerPort = core.Int64Ptr(int64(4553))
				databaseDetailsModel.Certificate = core.StringPtr("contents of a pem/crt file")
				databaseDetailsModel.CertificateExtension = core.StringPtr("pem/crt")
				databaseDetailsModel.ConnectionMethod = core.StringPtr("basic, apikey")
				databaseDetailsModel.ConnectionMode = core.StringPtr("service_name")
				databaseDetailsModel.ConnectionModeValue = core.StringPtr("orclpdb")
				databaseDetailsModel.ConnectionType = core.StringPtr("JDBC, Arrow flight")
				databaseDetailsModel.ControllerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseDetailsModel.ControllerAuthenticationType = core.StringPtr("PASSWORD")
				databaseDetailsModel.ControllerAuthenticationUser = core.StringPtr("sampleuser")
				databaseDetailsModel.CoordinatorHost = core.StringPtr("samplehost")
				databaseDetailsModel.CoordinatorPort = core.Int64Ptr(int64(4553))
				databaseDetailsModel.CpdHostname = core.StringPtr("samplecpdhostname")
				databaseDetailsModel.CredentialsKey = core.StringPtr("eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......")
				databaseDetailsModel.DatabaseName = core.StringPtr("new_database")
				databaseDetailsModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems{*databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel}
				databaseDetailsModel.Hostname = core.StringPtr("db2@<hostname>.com")
				databaseDetailsModel.HostnameInCertificate = core.StringPtr("samplehostname")
				databaseDetailsModel.Hosts = core.StringPtr("abc.com:1234,xyz.com:4321")
				databaseDetailsModel.InformixServer = core.StringPtr("ol_informix1410")
				databaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseDetailsModel.Port = core.Int64Ptr(int64(4553))
				databaseDetailsModel.ProjectID = core.StringPtr("conops-bigquery")
				databaseDetailsModel.Sasl = core.BoolPtr(true)
				databaseDetailsModel.SaslMechanism = core.StringPtr("plain")
				databaseDetailsModel.SchemaName = core.StringPtr("sampleSchema")
				databaseDetailsModel.Schemas = core.StringPtr("redis__name")
				databaseDetailsModel.ServiceApiKey = core.StringPtr("sampleapikey")
				databaseDetailsModel.ServiceHostname = core.StringPtr("api.dataplatform.dev.cloud.ibm.com")
				databaseDetailsModel.ServicePassword = core.StringPtr("samplepassword")
				databaseDetailsModel.ServicePort = core.Int64Ptr(int64(443))
				databaseDetailsModel.ServiceSsl = core.BoolPtr(true)
				databaseDetailsModel.ServiceTokenURL = core.StringPtr("sampletoakenurl")
				databaseDetailsModel.ServiceUsername = core.StringPtr("sampleusername")
				databaseDetailsModel.Ssl = core.BoolPtr(true)
				databaseDetailsModel.Tables = core.StringPtr("kafka_table_name, redis_table_name")
				databaseDetailsModel.Username = core.StringPtr("sampleuser")
				databaseDetailsModel.ValidateServerCertificate = core.BoolPtr(true)
				databaseDetailsModel.VerifyHostName = core.BoolPtr(true)
				databaseDetailsModel.WarehouseName = core.StringPtr("samplewrehouse")

				// Construct an instance of the DatabaseRegistrationPrototypeDatabasePropertiesItems model
				databaseRegistrationPrototypeDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")

				// Construct an instance of the CreateDatabaseRegistrationOptions model
				createDatabaseRegistrationOptionsModel := new(watsonxdatav2.CreateDatabaseRegistrationOptions)
				createDatabaseRegistrationOptionsModel.DatabaseDisplayName = core.StringPtr("new_database")
				createDatabaseRegistrationOptionsModel.DatabaseType = core.StringPtr("db2")
				createDatabaseRegistrationOptionsModel.AssociatedCatalog = databaseCatalogModel
				createDatabaseRegistrationOptionsModel.CreatedOn = core.StringPtr("1686792721")
				createDatabaseRegistrationOptionsModel.DatabaseDetails = databaseDetailsModel
				createDatabaseRegistrationOptionsModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems{*databaseRegistrationPrototypeDatabasePropertiesItemsModel}
				createDatabaseRegistrationOptionsModel.Description = core.StringPtr("db2 extenal database description")
				createDatabaseRegistrationOptionsModel.Tags = []string{"testdatabase", "userdatabase"}
				createDatabaseRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createDatabaseRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateDatabaseRegistration(createDatabaseRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateDatabaseRegistrationOptions model with no property values
				createDatabaseRegistrationOptionsModelNew := new(watsonxdatav2.CreateDatabaseRegistrationOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateDatabaseRegistration(createDatabaseRegistrationOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateDatabaseRegistration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DatabaseCatalog model
				databaseCatalogModel := new(watsonxdatav2.DatabaseCatalog)
				databaseCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				databaseCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				databaseCatalogModel.CatalogType = core.StringPtr("iceberg")

				// Construct an instance of the DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems model
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems)
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")

				// Construct an instance of the DatabaseDetails model
				databaseDetailsModel := new(watsonxdatav2.DatabaseDetails)
				databaseDetailsModel.AuthenticationType = core.StringPtr("LDAP")
				databaseDetailsModel.AuthenticationValue = core.StringPtr("LDAP")
				databaseDetailsModel.BrokerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseDetailsModel.BrokerAuthenticationType = core.StringPtr("PASSWORD")
				databaseDetailsModel.BrokerAuthenticationUser = core.StringPtr("sampleuser")
				databaseDetailsModel.BrokerHost = core.StringPtr("samplehost")
				databaseDetailsModel.BrokerPort = core.Int64Ptr(int64(4553))
				databaseDetailsModel.Certificate = core.StringPtr("contents of a pem/crt file")
				databaseDetailsModel.CertificateExtension = core.StringPtr("pem/crt")
				databaseDetailsModel.ConnectionMethod = core.StringPtr("basic, apikey")
				databaseDetailsModel.ConnectionMode = core.StringPtr("service_name")
				databaseDetailsModel.ConnectionModeValue = core.StringPtr("orclpdb")
				databaseDetailsModel.ConnectionType = core.StringPtr("JDBC, Arrow flight")
				databaseDetailsModel.ControllerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseDetailsModel.ControllerAuthenticationType = core.StringPtr("PASSWORD")
				databaseDetailsModel.ControllerAuthenticationUser = core.StringPtr("sampleuser")
				databaseDetailsModel.CoordinatorHost = core.StringPtr("samplehost")
				databaseDetailsModel.CoordinatorPort = core.Int64Ptr(int64(4553))
				databaseDetailsModel.CpdHostname = core.StringPtr("samplecpdhostname")
				databaseDetailsModel.CredentialsKey = core.StringPtr("eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......")
				databaseDetailsModel.DatabaseName = core.StringPtr("new_database")
				databaseDetailsModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems{*databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel}
				databaseDetailsModel.Hostname = core.StringPtr("db2@<hostname>.com")
				databaseDetailsModel.HostnameInCertificate = core.StringPtr("samplehostname")
				databaseDetailsModel.Hosts = core.StringPtr("abc.com:1234,xyz.com:4321")
				databaseDetailsModel.InformixServer = core.StringPtr("ol_informix1410")
				databaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseDetailsModel.Port = core.Int64Ptr(int64(4553))
				databaseDetailsModel.ProjectID = core.StringPtr("conops-bigquery")
				databaseDetailsModel.Sasl = core.BoolPtr(true)
				databaseDetailsModel.SaslMechanism = core.StringPtr("plain")
				databaseDetailsModel.SchemaName = core.StringPtr("sampleSchema")
				databaseDetailsModel.Schemas = core.StringPtr("redis__name")
				databaseDetailsModel.ServiceApiKey = core.StringPtr("sampleapikey")
				databaseDetailsModel.ServiceHostname = core.StringPtr("api.dataplatform.dev.cloud.ibm.com")
				databaseDetailsModel.ServicePassword = core.StringPtr("samplepassword")
				databaseDetailsModel.ServicePort = core.Int64Ptr(int64(443))
				databaseDetailsModel.ServiceSsl = core.BoolPtr(true)
				databaseDetailsModel.ServiceTokenURL = core.StringPtr("sampletoakenurl")
				databaseDetailsModel.ServiceUsername = core.StringPtr("sampleusername")
				databaseDetailsModel.Ssl = core.BoolPtr(true)
				databaseDetailsModel.Tables = core.StringPtr("kafka_table_name, redis_table_name")
				databaseDetailsModel.Username = core.StringPtr("sampleuser")
				databaseDetailsModel.ValidateServerCertificate = core.BoolPtr(true)
				databaseDetailsModel.VerifyHostName = core.BoolPtr(true)
				databaseDetailsModel.WarehouseName = core.StringPtr("samplewrehouse")

				// Construct an instance of the DatabaseRegistrationPrototypeDatabasePropertiesItems model
				databaseRegistrationPrototypeDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")

				// Construct an instance of the CreateDatabaseRegistrationOptions model
				createDatabaseRegistrationOptionsModel := new(watsonxdatav2.CreateDatabaseRegistrationOptions)
				createDatabaseRegistrationOptionsModel.DatabaseDisplayName = core.StringPtr("new_database")
				createDatabaseRegistrationOptionsModel.DatabaseType = core.StringPtr("db2")
				createDatabaseRegistrationOptionsModel.AssociatedCatalog = databaseCatalogModel
				createDatabaseRegistrationOptionsModel.CreatedOn = core.StringPtr("1686792721")
				createDatabaseRegistrationOptionsModel.DatabaseDetails = databaseDetailsModel
				createDatabaseRegistrationOptionsModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems{*databaseRegistrationPrototypeDatabasePropertiesItemsModel}
				createDatabaseRegistrationOptionsModel.Description = core.StringPtr("db2 extenal database description")
				createDatabaseRegistrationOptionsModel.Tags = []string{"testdatabase", "userdatabase"}
				createDatabaseRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createDatabaseRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateDatabaseRegistration(createDatabaseRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetDatabase(getDatabaseOptions *GetDatabaseOptions) - Operation response error`, func() {
		getDatabasePath := "/database_registrations/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getDatabasePath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetDatabase with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetDatabaseOptions model
				getDatabaseOptionsModel := new(watsonxdatav2.GetDatabaseOptions)
				getDatabaseOptionsModel.DatabaseID = core.StringPtr("testString")
				getDatabaseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getDatabaseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetDatabase(getDatabaseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetDatabase(getDatabaseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetDatabase(getDatabaseOptions *GetDatabaseOptions)`, func() {
		getDatabasePath := "/database_registrations/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getDatabasePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "catalog_name": "sampleCatalog", "created_by": "user1@bim.com", "created_on": "1686792721", "database_details": {"authentication_type": "LDAP", "authentication_value": "LDAP", "broker_authentication_password": "samplepassword", "broker_authentication_type": "PASSWORD", "broker_authentication_user": "sampleuser", "broker_host": "samplehost", "broker_port": 4553, "certificate": "contents of a pem/crt file", "certificate_extension": "pem/crt", "connection_method": "basic, apikey", "connection_mode": "service_name", "connection_mode_value": "orclpdb", "connection_type": "JDBC, Arrow flight", "controller_authentication_password": "samplepassword", "controller_authentication_type": "PASSWORD", "controller_authentication_user": "sampleuser", "coordinator_host": "samplehost", "coordinator_port": 4553, "cpd_hostname": "samplecpdhostname", "credentials_key": "eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......", "database_name": "new_database", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "hostname": "db2@<hostname>.com", "hostname_in_certificate": "samplehostname", "hosts": "abc.com:1234,xyz.com:4321", "informix_server": "ol_informix1410", "password": "samplepassword", "port": 4553, "project_id": "conops-bigquery", "sasl": true, "sasl_mechanism": "plain", "schema_name": "sampleSchema", "schemas": "redis__name", "service_api_key": "sampleapikey", "service_hostname": "api.dataplatform.dev.cloud.ibm.com", "service_password": "samplepassword", "service_port": 443, "service_ssl": true, "service_token_url": "sampletoakenurl", "service_username": "sampleusername", "ssl": true, "tables": "kafka_table_name, redis_table_name", "username": "sampleuser", "validate_server_certificate": true, "verify_host_name": true, "warehouse_name": "samplewrehouse"}, "database_display_name": "new_database", "database_id": "new_database_id", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "database_type": "netezza", "tables": [{"created_on": "1686792721", "file_contents": "sample file content", "file_name": "sample file name", "schema_name": "customer", "table_name": "customer"}], "description": "Description of the external database", "tags": ["Tags"], "topics": [{"created_on": "1686792721", "file_contents": "sample file content", "file_name": "sample file name", "topic_name": "customer"}]}`)
				}))
			})
			It(`Invoke GetDatabase successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetDatabaseOptions model
				getDatabaseOptionsModel := new(watsonxdatav2.GetDatabaseOptions)
				getDatabaseOptionsModel.DatabaseID = core.StringPtr("testString")
				getDatabaseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getDatabaseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetDatabaseWithContext(ctx, getDatabaseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetDatabase(getDatabaseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetDatabaseWithContext(ctx, getDatabaseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getDatabasePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "catalog_name": "sampleCatalog", "created_by": "user1@bim.com", "created_on": "1686792721", "database_details": {"authentication_type": "LDAP", "authentication_value": "LDAP", "broker_authentication_password": "samplepassword", "broker_authentication_type": "PASSWORD", "broker_authentication_user": "sampleuser", "broker_host": "samplehost", "broker_port": 4553, "certificate": "contents of a pem/crt file", "certificate_extension": "pem/crt", "connection_method": "basic, apikey", "connection_mode": "service_name", "connection_mode_value": "orclpdb", "connection_type": "JDBC, Arrow flight", "controller_authentication_password": "samplepassword", "controller_authentication_type": "PASSWORD", "controller_authentication_user": "sampleuser", "coordinator_host": "samplehost", "coordinator_port": 4553, "cpd_hostname": "samplecpdhostname", "credentials_key": "eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......", "database_name": "new_database", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "hostname": "db2@<hostname>.com", "hostname_in_certificate": "samplehostname", "hosts": "abc.com:1234,xyz.com:4321", "informix_server": "ol_informix1410", "password": "samplepassword", "port": 4553, "project_id": "conops-bigquery", "sasl": true, "sasl_mechanism": "plain", "schema_name": "sampleSchema", "schemas": "redis__name", "service_api_key": "sampleapikey", "service_hostname": "api.dataplatform.dev.cloud.ibm.com", "service_password": "samplepassword", "service_port": 443, "service_ssl": true, "service_token_url": "sampletoakenurl", "service_username": "sampleusername", "ssl": true, "tables": "kafka_table_name, redis_table_name", "username": "sampleuser", "validate_server_certificate": true, "verify_host_name": true, "warehouse_name": "samplewrehouse"}, "database_display_name": "new_database", "database_id": "new_database_id", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "database_type": "netezza", "tables": [{"created_on": "1686792721", "file_contents": "sample file content", "file_name": "sample file name", "schema_name": "customer", "table_name": "customer"}], "description": "Description of the external database", "tags": ["Tags"], "topics": [{"created_on": "1686792721", "file_contents": "sample file content", "file_name": "sample file name", "topic_name": "customer"}]}`)
				}))
			})
			It(`Invoke GetDatabase successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetDatabase(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetDatabaseOptions model
				getDatabaseOptionsModel := new(watsonxdatav2.GetDatabaseOptions)
				getDatabaseOptionsModel.DatabaseID = core.StringPtr("testString")
				getDatabaseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getDatabaseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetDatabase(getDatabaseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetDatabase with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetDatabaseOptions model
				getDatabaseOptionsModel := new(watsonxdatav2.GetDatabaseOptions)
				getDatabaseOptionsModel.DatabaseID = core.StringPtr("testString")
				getDatabaseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getDatabaseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetDatabase(getDatabaseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetDatabaseOptions model with no property values
				getDatabaseOptionsModelNew := new(watsonxdatav2.GetDatabaseOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetDatabase(getDatabaseOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetDatabase successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetDatabaseOptions model
				getDatabaseOptionsModel := new(watsonxdatav2.GetDatabaseOptions)
				getDatabaseOptionsModel.DatabaseID = core.StringPtr("testString")
				getDatabaseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getDatabaseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetDatabase(getDatabaseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteDatabaseCatalog(deleteDatabaseCatalogOptions *DeleteDatabaseCatalogOptions)`, func() {
		deleteDatabaseCatalogPath := "/database_registrations/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteDatabaseCatalogPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteDatabaseCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteDatabaseCatalog(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteDatabaseCatalogOptions model
				deleteDatabaseCatalogOptionsModel := new(watsonxdatav2.DeleteDatabaseCatalogOptions)
				deleteDatabaseCatalogOptionsModel.DatabaseID = core.StringPtr("testString")
				deleteDatabaseCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteDatabaseCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteDatabaseCatalog(deleteDatabaseCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteDatabaseCatalog with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteDatabaseCatalogOptions model
				deleteDatabaseCatalogOptionsModel := new(watsonxdatav2.DeleteDatabaseCatalogOptions)
				deleteDatabaseCatalogOptionsModel.DatabaseID = core.StringPtr("testString")
				deleteDatabaseCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteDatabaseCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteDatabaseCatalog(deleteDatabaseCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteDatabaseCatalogOptions model with no property values
				deleteDatabaseCatalogOptionsModelNew := new(watsonxdatav2.DeleteDatabaseCatalogOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteDatabaseCatalog(deleteDatabaseCatalogOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateDatabase(updateDatabaseOptions *UpdateDatabaseOptions) - Operation response error`, func() {
		updateDatabasePath := "/database_registrations/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateDatabasePath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateDatabase with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems model
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems)
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")

				// Construct an instance of the DatabaseRegistrationPatchDatabaseDetails model
				databaseRegistrationPatchDatabaseDetailsModel := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetails)
				databaseRegistrationPatchDatabaseDetailsModel.AuthenticationValue = core.StringPtr("LDAP")
				databaseRegistrationPatchDatabaseDetailsModel.BrokerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseRegistrationPatchDatabaseDetailsModel.BrokerAuthenticationType = core.StringPtr("PASSWORD")
				databaseRegistrationPatchDatabaseDetailsModel.BrokerAuthenticationUser = core.StringPtr("sampleuser")
				databaseRegistrationPatchDatabaseDetailsModel.ControllerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseRegistrationPatchDatabaseDetailsModel.ControllerAuthenticationType = core.StringPtr("PASSWORD")
				databaseRegistrationPatchDatabaseDetailsModel.ControllerAuthenticationUser = core.StringPtr("sampleuser")
				databaseRegistrationPatchDatabaseDetailsModel.CredentialsKey = core.StringPtr("eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......")
				databaseRegistrationPatchDatabaseDetailsModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems{*databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel}
				databaseRegistrationPatchDatabaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseRegistrationPatchDatabaseDetailsModel.Username = core.StringPtr("sampleuser")

				// Construct an instance of the DatabaseRegistrationPatchTablesItems model
				databaseRegistrationPatchTablesItemsModel := new(watsonxdatav2.DatabaseRegistrationPatchTablesItems)
				databaseRegistrationPatchTablesItemsModel.CreatedOn = core.StringPtr("1686792721")
				databaseRegistrationPatchTablesItemsModel.FileContents = core.StringPtr("sample file content")
				databaseRegistrationPatchTablesItemsModel.FileName = core.StringPtr("sample file name")
				databaseRegistrationPatchTablesItemsModel.SchemaName = core.StringPtr("customer")
				databaseRegistrationPatchTablesItemsModel.TableName = core.StringPtr("customer")

				// Construct an instance of the DatabaseRegistrationPatchTopicsItems model
				databaseRegistrationPatchTopicsItemsModel := new(watsonxdatav2.DatabaseRegistrationPatchTopicsItems)
				databaseRegistrationPatchTopicsItemsModel.CreatedOn = core.StringPtr("1686792721")
				databaseRegistrationPatchTopicsItemsModel.FileContents = core.StringPtr("sample file contents")
				databaseRegistrationPatchTopicsItemsModel.FileName = core.StringPtr("sample file name")
				databaseRegistrationPatchTopicsItemsModel.TopicName = core.StringPtr("customer")

				// Construct an instance of the DatabaseRegistrationPatch model
				databaseRegistrationPatchModel := new(watsonxdatav2.DatabaseRegistrationPatch)
				databaseRegistrationPatchModel.DatabaseDetails = databaseRegistrationPatchDatabaseDetailsModel
				databaseRegistrationPatchModel.DatabaseDisplayName = core.StringPtr("new_database")
				databaseRegistrationPatchModel.Description = core.StringPtr("External database description")
				databaseRegistrationPatchModel.Tables = []watsonxdatav2.DatabaseRegistrationPatchTablesItems{*databaseRegistrationPatchTablesItemsModel}
				databaseRegistrationPatchModel.Tags = []string{"testdatabase", "userdatabase"}
				databaseRegistrationPatchModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems{*databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel}
				databaseRegistrationPatchModel.Topics = []watsonxdatav2.DatabaseRegistrationPatchTopicsItems{*databaseRegistrationPatchTopicsItemsModel}
				databaseRegistrationPatchModelAsPatch, asPatchErr := databaseRegistrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateDatabaseOptions model
				updateDatabaseOptionsModel := new(watsonxdatav2.UpdateDatabaseOptions)
				updateDatabaseOptionsModel.DatabaseID = core.StringPtr("testString")
				updateDatabaseOptionsModel.Body = databaseRegistrationPatchModelAsPatch
				updateDatabaseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateDatabaseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdateDatabase(updateDatabaseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdateDatabase(updateDatabaseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateDatabase(updateDatabaseOptions *UpdateDatabaseOptions)`, func() {
		updateDatabasePath := "/database_registrations/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateDatabasePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "catalog_name": "sampleCatalog", "created_by": "user1@bim.com", "created_on": "1686792721", "database_details": {"authentication_type": "LDAP", "authentication_value": "LDAP", "broker_authentication_password": "samplepassword", "broker_authentication_type": "PASSWORD", "broker_authentication_user": "sampleuser", "broker_host": "samplehost", "broker_port": 4553, "certificate": "contents of a pem/crt file", "certificate_extension": "pem/crt", "connection_method": "basic, apikey", "connection_mode": "service_name", "connection_mode_value": "orclpdb", "connection_type": "JDBC, Arrow flight", "controller_authentication_password": "samplepassword", "controller_authentication_type": "PASSWORD", "controller_authentication_user": "sampleuser", "coordinator_host": "samplehost", "coordinator_port": 4553, "cpd_hostname": "samplecpdhostname", "credentials_key": "eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......", "database_name": "new_database", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "hostname": "db2@<hostname>.com", "hostname_in_certificate": "samplehostname", "hosts": "abc.com:1234,xyz.com:4321", "informix_server": "ol_informix1410", "password": "samplepassword", "port": 4553, "project_id": "conops-bigquery", "sasl": true, "sasl_mechanism": "plain", "schema_name": "sampleSchema", "schemas": "redis__name", "service_api_key": "sampleapikey", "service_hostname": "api.dataplatform.dev.cloud.ibm.com", "service_password": "samplepassword", "service_port": 443, "service_ssl": true, "service_token_url": "sampletoakenurl", "service_username": "sampleusername", "ssl": true, "tables": "kafka_table_name, redis_table_name", "username": "sampleuser", "validate_server_certificate": true, "verify_host_name": true, "warehouse_name": "samplewrehouse"}, "database_display_name": "new_database", "database_id": "new_database_id", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "database_type": "netezza", "tables": [{"created_on": "1686792721", "file_contents": "sample file content", "file_name": "sample file name", "schema_name": "customer", "table_name": "customer"}], "description": "Description of the external database", "tags": ["Tags"], "topics": [{"created_on": "1686792721", "file_contents": "sample file content", "file_name": "sample file name", "topic_name": "customer"}]}`)
				}))
			})
			It(`Invoke UpdateDatabase successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems model
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems)
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")

				// Construct an instance of the DatabaseRegistrationPatchDatabaseDetails model
				databaseRegistrationPatchDatabaseDetailsModel := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetails)
				databaseRegistrationPatchDatabaseDetailsModel.AuthenticationValue = core.StringPtr("LDAP")
				databaseRegistrationPatchDatabaseDetailsModel.BrokerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseRegistrationPatchDatabaseDetailsModel.BrokerAuthenticationType = core.StringPtr("PASSWORD")
				databaseRegistrationPatchDatabaseDetailsModel.BrokerAuthenticationUser = core.StringPtr("sampleuser")
				databaseRegistrationPatchDatabaseDetailsModel.ControllerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseRegistrationPatchDatabaseDetailsModel.ControllerAuthenticationType = core.StringPtr("PASSWORD")
				databaseRegistrationPatchDatabaseDetailsModel.ControllerAuthenticationUser = core.StringPtr("sampleuser")
				databaseRegistrationPatchDatabaseDetailsModel.CredentialsKey = core.StringPtr("eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......")
				databaseRegistrationPatchDatabaseDetailsModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems{*databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel}
				databaseRegistrationPatchDatabaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseRegistrationPatchDatabaseDetailsModel.Username = core.StringPtr("sampleuser")

				// Construct an instance of the DatabaseRegistrationPatchTablesItems model
				databaseRegistrationPatchTablesItemsModel := new(watsonxdatav2.DatabaseRegistrationPatchTablesItems)
				databaseRegistrationPatchTablesItemsModel.CreatedOn = core.StringPtr("1686792721")
				databaseRegistrationPatchTablesItemsModel.FileContents = core.StringPtr("sample file content")
				databaseRegistrationPatchTablesItemsModel.FileName = core.StringPtr("sample file name")
				databaseRegistrationPatchTablesItemsModel.SchemaName = core.StringPtr("customer")
				databaseRegistrationPatchTablesItemsModel.TableName = core.StringPtr("customer")

				// Construct an instance of the DatabaseRegistrationPatchTopicsItems model
				databaseRegistrationPatchTopicsItemsModel := new(watsonxdatav2.DatabaseRegistrationPatchTopicsItems)
				databaseRegistrationPatchTopicsItemsModel.CreatedOn = core.StringPtr("1686792721")
				databaseRegistrationPatchTopicsItemsModel.FileContents = core.StringPtr("sample file contents")
				databaseRegistrationPatchTopicsItemsModel.FileName = core.StringPtr("sample file name")
				databaseRegistrationPatchTopicsItemsModel.TopicName = core.StringPtr("customer")

				// Construct an instance of the DatabaseRegistrationPatch model
				databaseRegistrationPatchModel := new(watsonxdatav2.DatabaseRegistrationPatch)
				databaseRegistrationPatchModel.DatabaseDetails = databaseRegistrationPatchDatabaseDetailsModel
				databaseRegistrationPatchModel.DatabaseDisplayName = core.StringPtr("new_database")
				databaseRegistrationPatchModel.Description = core.StringPtr("External database description")
				databaseRegistrationPatchModel.Tables = []watsonxdatav2.DatabaseRegistrationPatchTablesItems{*databaseRegistrationPatchTablesItemsModel}
				databaseRegistrationPatchModel.Tags = []string{"testdatabase", "userdatabase"}
				databaseRegistrationPatchModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems{*databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel}
				databaseRegistrationPatchModel.Topics = []watsonxdatav2.DatabaseRegistrationPatchTopicsItems{*databaseRegistrationPatchTopicsItemsModel}
				databaseRegistrationPatchModelAsPatch, asPatchErr := databaseRegistrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateDatabaseOptions model
				updateDatabaseOptionsModel := new(watsonxdatav2.UpdateDatabaseOptions)
				updateDatabaseOptionsModel.DatabaseID = core.StringPtr("testString")
				updateDatabaseOptionsModel.Body = databaseRegistrationPatchModelAsPatch
				updateDatabaseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateDatabaseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdateDatabaseWithContext(ctx, updateDatabaseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdateDatabase(updateDatabaseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdateDatabaseWithContext(ctx, updateDatabaseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateDatabasePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "catalog_name": "sampleCatalog", "created_by": "user1@bim.com", "created_on": "1686792721", "database_details": {"authentication_type": "LDAP", "authentication_value": "LDAP", "broker_authentication_password": "samplepassword", "broker_authentication_type": "PASSWORD", "broker_authentication_user": "sampleuser", "broker_host": "samplehost", "broker_port": 4553, "certificate": "contents of a pem/crt file", "certificate_extension": "pem/crt", "connection_method": "basic, apikey", "connection_mode": "service_name", "connection_mode_value": "orclpdb", "connection_type": "JDBC, Arrow flight", "controller_authentication_password": "samplepassword", "controller_authentication_type": "PASSWORD", "controller_authentication_user": "sampleuser", "coordinator_host": "samplehost", "coordinator_port": 4553, "cpd_hostname": "samplecpdhostname", "credentials_key": "eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......", "database_name": "new_database", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "hostname": "db2@<hostname>.com", "hostname_in_certificate": "samplehostname", "hosts": "abc.com:1234,xyz.com:4321", "informix_server": "ol_informix1410", "password": "samplepassword", "port": 4553, "project_id": "conops-bigquery", "sasl": true, "sasl_mechanism": "plain", "schema_name": "sampleSchema", "schemas": "redis__name", "service_api_key": "sampleapikey", "service_hostname": "api.dataplatform.dev.cloud.ibm.com", "service_password": "samplepassword", "service_port": 443, "service_ssl": true, "service_token_url": "sampletoakenurl", "service_username": "sampleusername", "ssl": true, "tables": "kafka_table_name, redis_table_name", "username": "sampleuser", "validate_server_certificate": true, "verify_host_name": true, "warehouse_name": "samplewrehouse"}, "database_display_name": "new_database", "database_id": "new_database_id", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "database_type": "netezza", "tables": [{"created_on": "1686792721", "file_contents": "sample file content", "file_name": "sample file name", "schema_name": "customer", "table_name": "customer"}], "description": "Description of the external database", "tags": ["Tags"], "topics": [{"created_on": "1686792721", "file_contents": "sample file content", "file_name": "sample file name", "topic_name": "customer"}]}`)
				}))
			})
			It(`Invoke UpdateDatabase successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdateDatabase(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems model
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems)
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")

				// Construct an instance of the DatabaseRegistrationPatchDatabaseDetails model
				databaseRegistrationPatchDatabaseDetailsModel := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetails)
				databaseRegistrationPatchDatabaseDetailsModel.AuthenticationValue = core.StringPtr("LDAP")
				databaseRegistrationPatchDatabaseDetailsModel.BrokerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseRegistrationPatchDatabaseDetailsModel.BrokerAuthenticationType = core.StringPtr("PASSWORD")
				databaseRegistrationPatchDatabaseDetailsModel.BrokerAuthenticationUser = core.StringPtr("sampleuser")
				databaseRegistrationPatchDatabaseDetailsModel.ControllerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseRegistrationPatchDatabaseDetailsModel.ControllerAuthenticationType = core.StringPtr("PASSWORD")
				databaseRegistrationPatchDatabaseDetailsModel.ControllerAuthenticationUser = core.StringPtr("sampleuser")
				databaseRegistrationPatchDatabaseDetailsModel.CredentialsKey = core.StringPtr("eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......")
				databaseRegistrationPatchDatabaseDetailsModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems{*databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel}
				databaseRegistrationPatchDatabaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseRegistrationPatchDatabaseDetailsModel.Username = core.StringPtr("sampleuser")

				// Construct an instance of the DatabaseRegistrationPatchTablesItems model
				databaseRegistrationPatchTablesItemsModel := new(watsonxdatav2.DatabaseRegistrationPatchTablesItems)
				databaseRegistrationPatchTablesItemsModel.CreatedOn = core.StringPtr("1686792721")
				databaseRegistrationPatchTablesItemsModel.FileContents = core.StringPtr("sample file content")
				databaseRegistrationPatchTablesItemsModel.FileName = core.StringPtr("sample file name")
				databaseRegistrationPatchTablesItemsModel.SchemaName = core.StringPtr("customer")
				databaseRegistrationPatchTablesItemsModel.TableName = core.StringPtr("customer")

				// Construct an instance of the DatabaseRegistrationPatchTopicsItems model
				databaseRegistrationPatchTopicsItemsModel := new(watsonxdatav2.DatabaseRegistrationPatchTopicsItems)
				databaseRegistrationPatchTopicsItemsModel.CreatedOn = core.StringPtr("1686792721")
				databaseRegistrationPatchTopicsItemsModel.FileContents = core.StringPtr("sample file contents")
				databaseRegistrationPatchTopicsItemsModel.FileName = core.StringPtr("sample file name")
				databaseRegistrationPatchTopicsItemsModel.TopicName = core.StringPtr("customer")

				// Construct an instance of the DatabaseRegistrationPatch model
				databaseRegistrationPatchModel := new(watsonxdatav2.DatabaseRegistrationPatch)
				databaseRegistrationPatchModel.DatabaseDetails = databaseRegistrationPatchDatabaseDetailsModel
				databaseRegistrationPatchModel.DatabaseDisplayName = core.StringPtr("new_database")
				databaseRegistrationPatchModel.Description = core.StringPtr("External database description")
				databaseRegistrationPatchModel.Tables = []watsonxdatav2.DatabaseRegistrationPatchTablesItems{*databaseRegistrationPatchTablesItemsModel}
				databaseRegistrationPatchModel.Tags = []string{"testdatabase", "userdatabase"}
				databaseRegistrationPatchModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems{*databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel}
				databaseRegistrationPatchModel.Topics = []watsonxdatav2.DatabaseRegistrationPatchTopicsItems{*databaseRegistrationPatchTopicsItemsModel}
				databaseRegistrationPatchModelAsPatch, asPatchErr := databaseRegistrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateDatabaseOptions model
				updateDatabaseOptionsModel := new(watsonxdatav2.UpdateDatabaseOptions)
				updateDatabaseOptionsModel.DatabaseID = core.StringPtr("testString")
				updateDatabaseOptionsModel.Body = databaseRegistrationPatchModelAsPatch
				updateDatabaseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateDatabaseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdateDatabase(updateDatabaseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateDatabase with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems model
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems)
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")

				// Construct an instance of the DatabaseRegistrationPatchDatabaseDetails model
				databaseRegistrationPatchDatabaseDetailsModel := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetails)
				databaseRegistrationPatchDatabaseDetailsModel.AuthenticationValue = core.StringPtr("LDAP")
				databaseRegistrationPatchDatabaseDetailsModel.BrokerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseRegistrationPatchDatabaseDetailsModel.BrokerAuthenticationType = core.StringPtr("PASSWORD")
				databaseRegistrationPatchDatabaseDetailsModel.BrokerAuthenticationUser = core.StringPtr("sampleuser")
				databaseRegistrationPatchDatabaseDetailsModel.ControllerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseRegistrationPatchDatabaseDetailsModel.ControllerAuthenticationType = core.StringPtr("PASSWORD")
				databaseRegistrationPatchDatabaseDetailsModel.ControllerAuthenticationUser = core.StringPtr("sampleuser")
				databaseRegistrationPatchDatabaseDetailsModel.CredentialsKey = core.StringPtr("eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......")
				databaseRegistrationPatchDatabaseDetailsModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems{*databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel}
				databaseRegistrationPatchDatabaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseRegistrationPatchDatabaseDetailsModel.Username = core.StringPtr("sampleuser")

				// Construct an instance of the DatabaseRegistrationPatchTablesItems model
				databaseRegistrationPatchTablesItemsModel := new(watsonxdatav2.DatabaseRegistrationPatchTablesItems)
				databaseRegistrationPatchTablesItemsModel.CreatedOn = core.StringPtr("1686792721")
				databaseRegistrationPatchTablesItemsModel.FileContents = core.StringPtr("sample file content")
				databaseRegistrationPatchTablesItemsModel.FileName = core.StringPtr("sample file name")
				databaseRegistrationPatchTablesItemsModel.SchemaName = core.StringPtr("customer")
				databaseRegistrationPatchTablesItemsModel.TableName = core.StringPtr("customer")

				// Construct an instance of the DatabaseRegistrationPatchTopicsItems model
				databaseRegistrationPatchTopicsItemsModel := new(watsonxdatav2.DatabaseRegistrationPatchTopicsItems)
				databaseRegistrationPatchTopicsItemsModel.CreatedOn = core.StringPtr("1686792721")
				databaseRegistrationPatchTopicsItemsModel.FileContents = core.StringPtr("sample file contents")
				databaseRegistrationPatchTopicsItemsModel.FileName = core.StringPtr("sample file name")
				databaseRegistrationPatchTopicsItemsModel.TopicName = core.StringPtr("customer")

				// Construct an instance of the DatabaseRegistrationPatch model
				databaseRegistrationPatchModel := new(watsonxdatav2.DatabaseRegistrationPatch)
				databaseRegistrationPatchModel.DatabaseDetails = databaseRegistrationPatchDatabaseDetailsModel
				databaseRegistrationPatchModel.DatabaseDisplayName = core.StringPtr("new_database")
				databaseRegistrationPatchModel.Description = core.StringPtr("External database description")
				databaseRegistrationPatchModel.Tables = []watsonxdatav2.DatabaseRegistrationPatchTablesItems{*databaseRegistrationPatchTablesItemsModel}
				databaseRegistrationPatchModel.Tags = []string{"testdatabase", "userdatabase"}
				databaseRegistrationPatchModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems{*databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel}
				databaseRegistrationPatchModel.Topics = []watsonxdatav2.DatabaseRegistrationPatchTopicsItems{*databaseRegistrationPatchTopicsItemsModel}
				databaseRegistrationPatchModelAsPatch, asPatchErr := databaseRegistrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateDatabaseOptions model
				updateDatabaseOptionsModel := new(watsonxdatav2.UpdateDatabaseOptions)
				updateDatabaseOptionsModel.DatabaseID = core.StringPtr("testString")
				updateDatabaseOptionsModel.Body = databaseRegistrationPatchModelAsPatch
				updateDatabaseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateDatabaseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdateDatabase(updateDatabaseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateDatabaseOptions model with no property values
				updateDatabaseOptionsModelNew := new(watsonxdatav2.UpdateDatabaseOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdateDatabase(updateDatabaseOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateDatabase successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems model
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems)
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")

				// Construct an instance of the DatabaseRegistrationPatchDatabaseDetails model
				databaseRegistrationPatchDatabaseDetailsModel := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetails)
				databaseRegistrationPatchDatabaseDetailsModel.AuthenticationValue = core.StringPtr("LDAP")
				databaseRegistrationPatchDatabaseDetailsModel.BrokerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseRegistrationPatchDatabaseDetailsModel.BrokerAuthenticationType = core.StringPtr("PASSWORD")
				databaseRegistrationPatchDatabaseDetailsModel.BrokerAuthenticationUser = core.StringPtr("sampleuser")
				databaseRegistrationPatchDatabaseDetailsModel.ControllerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseRegistrationPatchDatabaseDetailsModel.ControllerAuthenticationType = core.StringPtr("PASSWORD")
				databaseRegistrationPatchDatabaseDetailsModel.ControllerAuthenticationUser = core.StringPtr("sampleuser")
				databaseRegistrationPatchDatabaseDetailsModel.CredentialsKey = core.StringPtr("eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......")
				databaseRegistrationPatchDatabaseDetailsModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems{*databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel}
				databaseRegistrationPatchDatabaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseRegistrationPatchDatabaseDetailsModel.Username = core.StringPtr("sampleuser")

				// Construct an instance of the DatabaseRegistrationPatchTablesItems model
				databaseRegistrationPatchTablesItemsModel := new(watsonxdatav2.DatabaseRegistrationPatchTablesItems)
				databaseRegistrationPatchTablesItemsModel.CreatedOn = core.StringPtr("1686792721")
				databaseRegistrationPatchTablesItemsModel.FileContents = core.StringPtr("sample file content")
				databaseRegistrationPatchTablesItemsModel.FileName = core.StringPtr("sample file name")
				databaseRegistrationPatchTablesItemsModel.SchemaName = core.StringPtr("customer")
				databaseRegistrationPatchTablesItemsModel.TableName = core.StringPtr("customer")

				// Construct an instance of the DatabaseRegistrationPatchTopicsItems model
				databaseRegistrationPatchTopicsItemsModel := new(watsonxdatav2.DatabaseRegistrationPatchTopicsItems)
				databaseRegistrationPatchTopicsItemsModel.CreatedOn = core.StringPtr("1686792721")
				databaseRegistrationPatchTopicsItemsModel.FileContents = core.StringPtr("sample file contents")
				databaseRegistrationPatchTopicsItemsModel.FileName = core.StringPtr("sample file name")
				databaseRegistrationPatchTopicsItemsModel.TopicName = core.StringPtr("customer")

				// Construct an instance of the DatabaseRegistrationPatch model
				databaseRegistrationPatchModel := new(watsonxdatav2.DatabaseRegistrationPatch)
				databaseRegistrationPatchModel.DatabaseDetails = databaseRegistrationPatchDatabaseDetailsModel
				databaseRegistrationPatchModel.DatabaseDisplayName = core.StringPtr("new_database")
				databaseRegistrationPatchModel.Description = core.StringPtr("External database description")
				databaseRegistrationPatchModel.Tables = []watsonxdatav2.DatabaseRegistrationPatchTablesItems{*databaseRegistrationPatchTablesItemsModel}
				databaseRegistrationPatchModel.Tags = []string{"testdatabase", "userdatabase"}
				databaseRegistrationPatchModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems{*databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel}
				databaseRegistrationPatchModel.Topics = []watsonxdatav2.DatabaseRegistrationPatchTopicsItems{*databaseRegistrationPatchTopicsItemsModel}
				databaseRegistrationPatchModelAsPatch, asPatchErr := databaseRegistrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateDatabaseOptions model
				updateDatabaseOptionsModel := new(watsonxdatav2.UpdateDatabaseOptions)
				updateDatabaseOptionsModel.DatabaseID = core.StringPtr("testString")
				updateDatabaseOptionsModel.Body = databaseRegistrationPatchModelAsPatch
				updateDatabaseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateDatabaseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdateDatabase(updateDatabaseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListOtherEngines(listOtherEnginesOptions *ListOtherEnginesOptions) - Operation response error`, func() {
		listOtherEnginesPath := "/other_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOtherEnginesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListOtherEngines with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListOtherEnginesOptions model
				listOtherEnginesOptionsModel := new(watsonxdatav2.ListOtherEnginesOptions)
				listOtherEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listOtherEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListOtherEngines(listOtherEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListOtherEngines(listOtherEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListOtherEngines(listOtherEnginesOptions *ListOtherEnginesOptions)`, func() {
		listOtherEnginesPath := "/other_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOtherEnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"other_engines": [{"actions": ["Actions"], "created_by": "<username>@<domain>.com", "created_on": 9, "description": "engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "engine_type": "netezza", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-netezza-01-netezza-svc", "origin": "ibm", "port": 4, "status": "registered", "tags": ["Tags"], "type": "external"}]}`)
				}))
			})
			It(`Invoke ListOtherEngines successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListOtherEnginesOptions model
				listOtherEnginesOptionsModel := new(watsonxdatav2.ListOtherEnginesOptions)
				listOtherEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listOtherEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListOtherEnginesWithContext(ctx, listOtherEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListOtherEngines(listOtherEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListOtherEnginesWithContext(ctx, listOtherEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOtherEnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"other_engines": [{"actions": ["Actions"], "created_by": "<username>@<domain>.com", "created_on": 9, "description": "engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "engine_type": "netezza", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-netezza-01-netezza-svc", "origin": "ibm", "port": 4, "status": "registered", "tags": ["Tags"], "type": "external"}]}`)
				}))
			})
			It(`Invoke ListOtherEngines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListOtherEngines(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListOtherEnginesOptions model
				listOtherEnginesOptionsModel := new(watsonxdatav2.ListOtherEnginesOptions)
				listOtherEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listOtherEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListOtherEngines(listOtherEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListOtherEngines with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListOtherEnginesOptions model
				listOtherEnginesOptionsModel := new(watsonxdatav2.ListOtherEnginesOptions)
				listOtherEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listOtherEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListOtherEngines(listOtherEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListOtherEngines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListOtherEnginesOptions model
				listOtherEnginesOptionsModel := new(watsonxdatav2.ListOtherEnginesOptions)
				listOtherEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listOtherEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListOtherEngines(listOtherEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateOtherEngine(createOtherEngineOptions *CreateOtherEngineOptions) - Operation response error`, func() {
		createOtherEnginePath := "/other_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createOtherEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateOtherEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the OtherEngineDetailsBody model
				otherEngineDetailsBodyModel := new(watsonxdatav2.OtherEngineDetailsBody)
				otherEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				otherEngineDetailsBodyModel.EngineType = core.StringPtr("netezza")

				// Construct an instance of the CreateOtherEngineOptions model
				createOtherEngineOptionsModel := new(watsonxdatav2.CreateOtherEngineOptions)
				createOtherEngineOptionsModel.EngineDetails = otherEngineDetailsBodyModel
				createOtherEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine01")
				createOtherEngineOptionsModel.Description = core.StringPtr("external engine description")
				createOtherEngineOptionsModel.Origin = core.StringPtr("external")
				createOtherEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createOtherEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createOtherEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateOtherEngine(createOtherEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateOtherEngine(createOtherEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateOtherEngine(createOtherEngineOptions *CreateOtherEngineOptions)`, func() {
		createOtherEnginePath := "/other_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createOtherEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "created_by": "<username>@<domain>.com", "created_on": 9, "description": "engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "engine_type": "netezza", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-netezza-01-netezza-svc", "origin": "ibm", "port": 4, "status": "registered", "tags": ["Tags"], "type": "external"}`)
				}))
			})
			It(`Invoke CreateOtherEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the OtherEngineDetailsBody model
				otherEngineDetailsBodyModel := new(watsonxdatav2.OtherEngineDetailsBody)
				otherEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				otherEngineDetailsBodyModel.EngineType = core.StringPtr("netezza")

				// Construct an instance of the CreateOtherEngineOptions model
				createOtherEngineOptionsModel := new(watsonxdatav2.CreateOtherEngineOptions)
				createOtherEngineOptionsModel.EngineDetails = otherEngineDetailsBodyModel
				createOtherEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine01")
				createOtherEngineOptionsModel.Description = core.StringPtr("external engine description")
				createOtherEngineOptionsModel.Origin = core.StringPtr("external")
				createOtherEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createOtherEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createOtherEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateOtherEngineWithContext(ctx, createOtherEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateOtherEngine(createOtherEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateOtherEngineWithContext(ctx, createOtherEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createOtherEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "created_by": "<username>@<domain>.com", "created_on": 9, "description": "engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "engine_type": "netezza", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-netezza-01-netezza-svc", "origin": "ibm", "port": 4, "status": "registered", "tags": ["Tags"], "type": "external"}`)
				}))
			})
			It(`Invoke CreateOtherEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateOtherEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the OtherEngineDetailsBody model
				otherEngineDetailsBodyModel := new(watsonxdatav2.OtherEngineDetailsBody)
				otherEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				otherEngineDetailsBodyModel.EngineType = core.StringPtr("netezza")

				// Construct an instance of the CreateOtherEngineOptions model
				createOtherEngineOptionsModel := new(watsonxdatav2.CreateOtherEngineOptions)
				createOtherEngineOptionsModel.EngineDetails = otherEngineDetailsBodyModel
				createOtherEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine01")
				createOtherEngineOptionsModel.Description = core.StringPtr("external engine description")
				createOtherEngineOptionsModel.Origin = core.StringPtr("external")
				createOtherEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createOtherEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createOtherEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateOtherEngine(createOtherEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateOtherEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the OtherEngineDetailsBody model
				otherEngineDetailsBodyModel := new(watsonxdatav2.OtherEngineDetailsBody)
				otherEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				otherEngineDetailsBodyModel.EngineType = core.StringPtr("netezza")

				// Construct an instance of the CreateOtherEngineOptions model
				createOtherEngineOptionsModel := new(watsonxdatav2.CreateOtherEngineOptions)
				createOtherEngineOptionsModel.EngineDetails = otherEngineDetailsBodyModel
				createOtherEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine01")
				createOtherEngineOptionsModel.Description = core.StringPtr("external engine description")
				createOtherEngineOptionsModel.Origin = core.StringPtr("external")
				createOtherEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createOtherEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createOtherEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateOtherEngine(createOtherEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateOtherEngineOptions model with no property values
				createOtherEngineOptionsModelNew := new(watsonxdatav2.CreateOtherEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateOtherEngine(createOtherEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateOtherEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the OtherEngineDetailsBody model
				otherEngineDetailsBodyModel := new(watsonxdatav2.OtherEngineDetailsBody)
				otherEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				otherEngineDetailsBodyModel.EngineType = core.StringPtr("netezza")

				// Construct an instance of the CreateOtherEngineOptions model
				createOtherEngineOptionsModel := new(watsonxdatav2.CreateOtherEngineOptions)
				createOtherEngineOptionsModel.EngineDetails = otherEngineDetailsBodyModel
				createOtherEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine01")
				createOtherEngineOptionsModel.Description = core.StringPtr("external engine description")
				createOtherEngineOptionsModel.Origin = core.StringPtr("external")
				createOtherEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createOtherEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createOtherEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateOtherEngine(createOtherEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteOtherEngine(deleteOtherEngineOptions *DeleteOtherEngineOptions)`, func() {
		deleteOtherEnginePath := "/other_engines/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteOtherEnginePath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteOtherEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteOtherEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteOtherEngineOptions model
				deleteOtherEngineOptionsModel := new(watsonxdatav2.DeleteOtherEngineOptions)
				deleteOtherEngineOptionsModel.EngineID = core.StringPtr("testString")
				deleteOtherEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteOtherEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteOtherEngine(deleteOtherEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteOtherEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteOtherEngineOptions model
				deleteOtherEngineOptionsModel := new(watsonxdatav2.DeleteOtherEngineOptions)
				deleteOtherEngineOptionsModel.EngineID = core.StringPtr("testString")
				deleteOtherEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteOtherEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteOtherEngine(deleteOtherEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteOtherEngineOptions model with no property values
				deleteOtherEngineOptionsModelNew := new(watsonxdatav2.DeleteOtherEngineOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteOtherEngine(deleteOtherEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListAllIntegrations(listAllIntegrationsOptions *ListAllIntegrationsOptions) - Operation response error`, func() {
		listAllIntegrationsPath := "/integrations"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listAllIntegrationsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.Header["Secret"]).ToNot(BeNil())
					Expect(req.Header["Secret"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["service_type"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListAllIntegrations with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListAllIntegrationsOptions model
				listAllIntegrationsOptionsModel := new(watsonxdatav2.ListAllIntegrationsOptions)
				listAllIntegrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listAllIntegrationsOptionsModel.Secret = core.StringPtr("testString")
				listAllIntegrationsOptionsModel.ServiceType = core.StringPtr("testString")
				listAllIntegrationsOptionsModel.State = []string{"testString"}
				listAllIntegrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListAllIntegrations(listAllIntegrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListAllIntegrations(listAllIntegrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListAllIntegrations(listAllIntegrationsOptions *ListAllIntegrationsOptions)`, func() {
		listAllIntegrationsPath := "/integrations"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listAllIntegrationsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.Header["Secret"]).ToNot(BeNil())
					Expect(req.Header["Secret"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["service_type"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"integrations": [{"apikey": "apikey", "config_properties": "ikc-env.password=ibmlhenc__0001__uMkFATDDZNnxJ7z6BA/QqA==\nikc-env.url=ikc\nikc-enabled-catalogs=\nikc-username=\nlh-unique-identifier=1711796957622126\nlh-crn=1711796957622126", "enable_data_policy_within_wxd": false, "governance_properties": "query-governance.name=external", "integration_id": "presto01", "modified_at": 10, "modified_by": "<username>@<domain>.com", "password": "password", "resource": "presto01", "service_type": "ikc", "state": "active", "storage_catalogs": ["StorageCatalogs"], "url": "ikc.url", "username": "username@email.com"}]}`)
				}))
			})
			It(`Invoke ListAllIntegrations successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListAllIntegrationsOptions model
				listAllIntegrationsOptionsModel := new(watsonxdatav2.ListAllIntegrationsOptions)
				listAllIntegrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listAllIntegrationsOptionsModel.Secret = core.StringPtr("testString")
				listAllIntegrationsOptionsModel.ServiceType = core.StringPtr("testString")
				listAllIntegrationsOptionsModel.State = []string{"testString"}
				listAllIntegrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListAllIntegrationsWithContext(ctx, listAllIntegrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListAllIntegrations(listAllIntegrationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListAllIntegrationsWithContext(ctx, listAllIntegrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listAllIntegrationsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.Header["Secret"]).ToNot(BeNil())
					Expect(req.Header["Secret"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["service_type"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"integrations": [{"apikey": "apikey", "config_properties": "ikc-env.password=ibmlhenc__0001__uMkFATDDZNnxJ7z6BA/QqA==\nikc-env.url=ikc\nikc-enabled-catalogs=\nikc-username=\nlh-unique-identifier=1711796957622126\nlh-crn=1711796957622126", "enable_data_policy_within_wxd": false, "governance_properties": "query-governance.name=external", "integration_id": "presto01", "modified_at": 10, "modified_by": "<username>@<domain>.com", "password": "password", "resource": "presto01", "service_type": "ikc", "state": "active", "storage_catalogs": ["StorageCatalogs"], "url": "ikc.url", "username": "username@email.com"}]}`)
				}))
			})
			It(`Invoke ListAllIntegrations successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListAllIntegrations(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListAllIntegrationsOptions model
				listAllIntegrationsOptionsModel := new(watsonxdatav2.ListAllIntegrationsOptions)
				listAllIntegrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listAllIntegrationsOptionsModel.Secret = core.StringPtr("testString")
				listAllIntegrationsOptionsModel.ServiceType = core.StringPtr("testString")
				listAllIntegrationsOptionsModel.State = []string{"testString"}
				listAllIntegrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListAllIntegrations(listAllIntegrationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListAllIntegrations with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListAllIntegrationsOptions model
				listAllIntegrationsOptionsModel := new(watsonxdatav2.ListAllIntegrationsOptions)
				listAllIntegrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listAllIntegrationsOptionsModel.Secret = core.StringPtr("testString")
				listAllIntegrationsOptionsModel.ServiceType = core.StringPtr("testString")
				listAllIntegrationsOptionsModel.State = []string{"testString"}
				listAllIntegrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListAllIntegrations(listAllIntegrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListAllIntegrations successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListAllIntegrationsOptions model
				listAllIntegrationsOptionsModel := new(watsonxdatav2.ListAllIntegrationsOptions)
				listAllIntegrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listAllIntegrationsOptionsModel.Secret = core.StringPtr("testString")
				listAllIntegrationsOptionsModel.ServiceType = core.StringPtr("testString")
				listAllIntegrationsOptionsModel.State = []string{"testString"}
				listAllIntegrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListAllIntegrations(listAllIntegrationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateIntegration(createIntegrationOptions *CreateIntegrationOptions) - Operation response error`, func() {
		createIntegrationPath := "/integrations"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createIntegrationPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateIntegration with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateIntegrationOptions model
				createIntegrationOptionsModel := new(watsonxdatav2.CreateIntegrationOptions)
				createIntegrationOptionsModel.Apikey = core.StringPtr("testString")
				createIntegrationOptionsModel.EnableDataPolicyWithinWxd = core.BoolPtr(false)
				createIntegrationOptionsModel.Password = core.StringPtr("password")
				createIntegrationOptionsModel.Resource = core.StringPtr("resource_name")
				createIntegrationOptionsModel.ServiceType = core.StringPtr("ranger")
				createIntegrationOptionsModel.StorageCatalogs = []string{"testString"}
				createIntegrationOptionsModel.URL = core.StringPtr("http://abcd.efgh.com:9876/")
				createIntegrationOptionsModel.Username = core.StringPtr("username")
				createIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateIntegration(createIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateIntegration(createIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateIntegration(createIntegrationOptions *CreateIntegrationOptions)`, func() {
		createIntegrationPath := "/integrations"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createIntegrationPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"apikey": "apikey", "config_properties": "ikc-env.password=ibmlhenc__0001__uMkFATDDZNnxJ7z6BA/QqA==\nikc-env.url=ikc\nikc-enabled-catalogs=\nikc-username=\nlh-unique-identifier=1711796957622126\nlh-crn=1711796957622126", "enable_data_policy_within_wxd": false, "governance_properties": "query-governance.name=external", "integration_id": "presto01", "modified_at": 10, "modified_by": "<username>@<domain>.com", "password": "password", "resource": "presto01", "service_type": "ikc", "state": "active", "storage_catalogs": ["StorageCatalogs"], "url": "ikc.url", "username": "username@email.com"}`)
				}))
			})
			It(`Invoke CreateIntegration successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreateIntegrationOptions model
				createIntegrationOptionsModel := new(watsonxdatav2.CreateIntegrationOptions)
				createIntegrationOptionsModel.Apikey = core.StringPtr("testString")
				createIntegrationOptionsModel.EnableDataPolicyWithinWxd = core.BoolPtr(false)
				createIntegrationOptionsModel.Password = core.StringPtr("password")
				createIntegrationOptionsModel.Resource = core.StringPtr("resource_name")
				createIntegrationOptionsModel.ServiceType = core.StringPtr("ranger")
				createIntegrationOptionsModel.StorageCatalogs = []string{"testString"}
				createIntegrationOptionsModel.URL = core.StringPtr("http://abcd.efgh.com:9876/")
				createIntegrationOptionsModel.Username = core.StringPtr("username")
				createIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateIntegrationWithContext(ctx, createIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateIntegration(createIntegrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateIntegrationWithContext(ctx, createIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createIntegrationPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"apikey": "apikey", "config_properties": "ikc-env.password=ibmlhenc__0001__uMkFATDDZNnxJ7z6BA/QqA==\nikc-env.url=ikc\nikc-enabled-catalogs=\nikc-username=\nlh-unique-identifier=1711796957622126\nlh-crn=1711796957622126", "enable_data_policy_within_wxd": false, "governance_properties": "query-governance.name=external", "integration_id": "presto01", "modified_at": 10, "modified_by": "<username>@<domain>.com", "password": "password", "resource": "presto01", "service_type": "ikc", "state": "active", "storage_catalogs": ["StorageCatalogs"], "url": "ikc.url", "username": "username@email.com"}`)
				}))
			})
			It(`Invoke CreateIntegration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateIntegration(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreateIntegrationOptions model
				createIntegrationOptionsModel := new(watsonxdatav2.CreateIntegrationOptions)
				createIntegrationOptionsModel.Apikey = core.StringPtr("testString")
				createIntegrationOptionsModel.EnableDataPolicyWithinWxd = core.BoolPtr(false)
				createIntegrationOptionsModel.Password = core.StringPtr("password")
				createIntegrationOptionsModel.Resource = core.StringPtr("resource_name")
				createIntegrationOptionsModel.ServiceType = core.StringPtr("ranger")
				createIntegrationOptionsModel.StorageCatalogs = []string{"testString"}
				createIntegrationOptionsModel.URL = core.StringPtr("http://abcd.efgh.com:9876/")
				createIntegrationOptionsModel.Username = core.StringPtr("username")
				createIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateIntegration(createIntegrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateIntegration with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateIntegrationOptions model
				createIntegrationOptionsModel := new(watsonxdatav2.CreateIntegrationOptions)
				createIntegrationOptionsModel.Apikey = core.StringPtr("testString")
				createIntegrationOptionsModel.EnableDataPolicyWithinWxd = core.BoolPtr(false)
				createIntegrationOptionsModel.Password = core.StringPtr("password")
				createIntegrationOptionsModel.Resource = core.StringPtr("resource_name")
				createIntegrationOptionsModel.ServiceType = core.StringPtr("ranger")
				createIntegrationOptionsModel.StorageCatalogs = []string{"testString"}
				createIntegrationOptionsModel.URL = core.StringPtr("http://abcd.efgh.com:9876/")
				createIntegrationOptionsModel.Username = core.StringPtr("username")
				createIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateIntegration(createIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateIntegration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateIntegrationOptions model
				createIntegrationOptionsModel := new(watsonxdatav2.CreateIntegrationOptions)
				createIntegrationOptionsModel.Apikey = core.StringPtr("testString")
				createIntegrationOptionsModel.EnableDataPolicyWithinWxd = core.BoolPtr(false)
				createIntegrationOptionsModel.Password = core.StringPtr("password")
				createIntegrationOptionsModel.Resource = core.StringPtr("resource_name")
				createIntegrationOptionsModel.ServiceType = core.StringPtr("ranger")
				createIntegrationOptionsModel.StorageCatalogs = []string{"testString"}
				createIntegrationOptionsModel.URL = core.StringPtr("http://abcd.efgh.com:9876/")
				createIntegrationOptionsModel.Username = core.StringPtr("username")
				createIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateIntegration(createIntegrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetIntegrations(getIntegrationsOptions *GetIntegrationsOptions) - Operation response error`, func() {
		getIntegrationsPath := "/integrations/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getIntegrationsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.Header["Secret"]).ToNot(BeNil())
					Expect(req.Header["Secret"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetIntegrations with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetIntegrationsOptions model
				getIntegrationsOptionsModel := new(watsonxdatav2.GetIntegrationsOptions)
				getIntegrationsOptionsModel.IntegrationID = core.StringPtr("testString")
				getIntegrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getIntegrationsOptionsModel.Secret = core.StringPtr("testString")
				getIntegrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetIntegrations(getIntegrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetIntegrations(getIntegrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetIntegrations(getIntegrationsOptions *GetIntegrationsOptions)`, func() {
		getIntegrationsPath := "/integrations/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getIntegrationsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.Header["Secret"]).ToNot(BeNil())
					Expect(req.Header["Secret"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"apikey": "apikey", "config_properties": "ikc-env.password=ibmlhenc__0001__uMkFATDDZNnxJ7z6BA/QqA==\nikc-env.url=ikc\nikc-enabled-catalogs=\nikc-username=\nlh-unique-identifier=1711796957622126\nlh-crn=1711796957622126", "enable_data_policy_within_wxd": false, "governance_properties": "query-governance.name=external", "integration_id": "presto01", "modified_at": 10, "modified_by": "<username>@<domain>.com", "password": "password", "resource": "presto01", "service_type": "ikc", "state": "active", "storage_catalogs": ["StorageCatalogs"], "url": "ikc.url", "username": "username@email.com"}`)
				}))
			})
			It(`Invoke GetIntegrations successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetIntegrationsOptions model
				getIntegrationsOptionsModel := new(watsonxdatav2.GetIntegrationsOptions)
				getIntegrationsOptionsModel.IntegrationID = core.StringPtr("testString")
				getIntegrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getIntegrationsOptionsModel.Secret = core.StringPtr("testString")
				getIntegrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetIntegrationsWithContext(ctx, getIntegrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetIntegrations(getIntegrationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetIntegrationsWithContext(ctx, getIntegrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getIntegrationsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.Header["Secret"]).ToNot(BeNil())
					Expect(req.Header["Secret"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"apikey": "apikey", "config_properties": "ikc-env.password=ibmlhenc__0001__uMkFATDDZNnxJ7z6BA/QqA==\nikc-env.url=ikc\nikc-enabled-catalogs=\nikc-username=\nlh-unique-identifier=1711796957622126\nlh-crn=1711796957622126", "enable_data_policy_within_wxd": false, "governance_properties": "query-governance.name=external", "integration_id": "presto01", "modified_at": 10, "modified_by": "<username>@<domain>.com", "password": "password", "resource": "presto01", "service_type": "ikc", "state": "active", "storage_catalogs": ["StorageCatalogs"], "url": "ikc.url", "username": "username@email.com"}`)
				}))
			})
			It(`Invoke GetIntegrations successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetIntegrations(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetIntegrationsOptions model
				getIntegrationsOptionsModel := new(watsonxdatav2.GetIntegrationsOptions)
				getIntegrationsOptionsModel.IntegrationID = core.StringPtr("testString")
				getIntegrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getIntegrationsOptionsModel.Secret = core.StringPtr("testString")
				getIntegrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetIntegrations(getIntegrationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetIntegrations with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetIntegrationsOptions model
				getIntegrationsOptionsModel := new(watsonxdatav2.GetIntegrationsOptions)
				getIntegrationsOptionsModel.IntegrationID = core.StringPtr("testString")
				getIntegrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getIntegrationsOptionsModel.Secret = core.StringPtr("testString")
				getIntegrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetIntegrations(getIntegrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetIntegrationsOptions model with no property values
				getIntegrationsOptionsModelNew := new(watsonxdatav2.GetIntegrationsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetIntegrations(getIntegrationsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetIntegrations successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetIntegrationsOptions model
				getIntegrationsOptionsModel := new(watsonxdatav2.GetIntegrationsOptions)
				getIntegrationsOptionsModel.IntegrationID = core.StringPtr("testString")
				getIntegrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getIntegrationsOptionsModel.Secret = core.StringPtr("testString")
				getIntegrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetIntegrations(getIntegrationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteIntegration(deleteIntegrationOptions *DeleteIntegrationOptions)`, func() {
		deleteIntegrationPath := "/integrations/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteIntegrationPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteIntegration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteIntegration(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteIntegrationOptions model
				deleteIntegrationOptionsModel := new(watsonxdatav2.DeleteIntegrationOptions)
				deleteIntegrationOptionsModel.IntegrationID = core.StringPtr("testString")
				deleteIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteIntegration(deleteIntegrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteIntegration with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteIntegrationOptions model
				deleteIntegrationOptionsModel := new(watsonxdatav2.DeleteIntegrationOptions)
				deleteIntegrationOptionsModel.IntegrationID = core.StringPtr("testString")
				deleteIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteIntegration(deleteIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteIntegrationOptions model with no property values
				deleteIntegrationOptionsModelNew := new(watsonxdatav2.DeleteIntegrationOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteIntegration(deleteIntegrationOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateIntegration(updateIntegrationOptions *UpdateIntegrationOptions) - Operation response error`, func() {
		updateIntegrationPath := "/integrations/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateIntegrationPath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateIntegration with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the IntegrationPatch model
				integrationPatchModel := new(watsonxdatav2.IntegrationPatch)
				integrationPatchModel.Apikey = core.StringPtr("apikey")
				integrationPatchModel.EnableDataPolicyWithinWxd = core.BoolPtr(true)
				integrationPatchModel.Password = core.StringPtr("password")
				integrationPatchModel.Resource = core.StringPtr("resource_name")
				integrationPatchModel.StorageCatalogs = []string{"iceberg_data", "hive_data"}
				integrationPatchModel.URL = core.StringPtr("http://abcd.efgh.com:9876/")
				integrationPatchModel.Username = core.StringPtr("username")
				integrationPatchModelAsPatch, asPatchErr := integrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateIntegrationOptions model
				updateIntegrationOptionsModel := new(watsonxdatav2.UpdateIntegrationOptions)
				updateIntegrationOptionsModel.IntegrationID = core.StringPtr("testString")
				updateIntegrationOptionsModel.IntegrationPatch = integrationPatchModelAsPatch
				updateIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdateIntegration(updateIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdateIntegration(updateIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateIntegration(updateIntegrationOptions *UpdateIntegrationOptions)`, func() {
		updateIntegrationPath := "/integrations/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateIntegrationPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"apikey": "apikey", "config_properties": "ikc-env.password=ibmlhenc__0001__uMkFATDDZNnxJ7z6BA/QqA==\nikc-env.url=ikc\nikc-enabled-catalogs=\nikc-username=\nlh-unique-identifier=1711796957622126\nlh-crn=1711796957622126", "enable_data_policy_within_wxd": false, "governance_properties": "query-governance.name=external", "integration_id": "presto01", "modified_at": 10, "modified_by": "<username>@<domain>.com", "password": "password", "resource": "presto01", "service_type": "ikc", "state": "active", "storage_catalogs": ["StorageCatalogs"], "url": "ikc.url", "username": "username@email.com"}`)
				}))
			})
			It(`Invoke UpdateIntegration successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the IntegrationPatch model
				integrationPatchModel := new(watsonxdatav2.IntegrationPatch)
				integrationPatchModel.Apikey = core.StringPtr("apikey")
				integrationPatchModel.EnableDataPolicyWithinWxd = core.BoolPtr(true)
				integrationPatchModel.Password = core.StringPtr("password")
				integrationPatchModel.Resource = core.StringPtr("resource_name")
				integrationPatchModel.StorageCatalogs = []string{"iceberg_data", "hive_data"}
				integrationPatchModel.URL = core.StringPtr("http://abcd.efgh.com:9876/")
				integrationPatchModel.Username = core.StringPtr("username")
				integrationPatchModelAsPatch, asPatchErr := integrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateIntegrationOptions model
				updateIntegrationOptionsModel := new(watsonxdatav2.UpdateIntegrationOptions)
				updateIntegrationOptionsModel.IntegrationID = core.StringPtr("testString")
				updateIntegrationOptionsModel.IntegrationPatch = integrationPatchModelAsPatch
				updateIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdateIntegrationWithContext(ctx, updateIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdateIntegration(updateIntegrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdateIntegrationWithContext(ctx, updateIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateIntegrationPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"apikey": "apikey", "config_properties": "ikc-env.password=ibmlhenc__0001__uMkFATDDZNnxJ7z6BA/QqA==\nikc-env.url=ikc\nikc-enabled-catalogs=\nikc-username=\nlh-unique-identifier=1711796957622126\nlh-crn=1711796957622126", "enable_data_policy_within_wxd": false, "governance_properties": "query-governance.name=external", "integration_id": "presto01", "modified_at": 10, "modified_by": "<username>@<domain>.com", "password": "password", "resource": "presto01", "service_type": "ikc", "state": "active", "storage_catalogs": ["StorageCatalogs"], "url": "ikc.url", "username": "username@email.com"}`)
				}))
			})
			It(`Invoke UpdateIntegration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdateIntegration(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the IntegrationPatch model
				integrationPatchModel := new(watsonxdatav2.IntegrationPatch)
				integrationPatchModel.Apikey = core.StringPtr("apikey")
				integrationPatchModel.EnableDataPolicyWithinWxd = core.BoolPtr(true)
				integrationPatchModel.Password = core.StringPtr("password")
				integrationPatchModel.Resource = core.StringPtr("resource_name")
				integrationPatchModel.StorageCatalogs = []string{"iceberg_data", "hive_data"}
				integrationPatchModel.URL = core.StringPtr("http://abcd.efgh.com:9876/")
				integrationPatchModel.Username = core.StringPtr("username")
				integrationPatchModelAsPatch, asPatchErr := integrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateIntegrationOptions model
				updateIntegrationOptionsModel := new(watsonxdatav2.UpdateIntegrationOptions)
				updateIntegrationOptionsModel.IntegrationID = core.StringPtr("testString")
				updateIntegrationOptionsModel.IntegrationPatch = integrationPatchModelAsPatch
				updateIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdateIntegration(updateIntegrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateIntegration with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the IntegrationPatch model
				integrationPatchModel := new(watsonxdatav2.IntegrationPatch)
				integrationPatchModel.Apikey = core.StringPtr("apikey")
				integrationPatchModel.EnableDataPolicyWithinWxd = core.BoolPtr(true)
				integrationPatchModel.Password = core.StringPtr("password")
				integrationPatchModel.Resource = core.StringPtr("resource_name")
				integrationPatchModel.StorageCatalogs = []string{"iceberg_data", "hive_data"}
				integrationPatchModel.URL = core.StringPtr("http://abcd.efgh.com:9876/")
				integrationPatchModel.Username = core.StringPtr("username")
				integrationPatchModelAsPatch, asPatchErr := integrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateIntegrationOptions model
				updateIntegrationOptionsModel := new(watsonxdatav2.UpdateIntegrationOptions)
				updateIntegrationOptionsModel.IntegrationID = core.StringPtr("testString")
				updateIntegrationOptionsModel.IntegrationPatch = integrationPatchModelAsPatch
				updateIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdateIntegration(updateIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateIntegrationOptions model with no property values
				updateIntegrationOptionsModelNew := new(watsonxdatav2.UpdateIntegrationOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdateIntegration(updateIntegrationOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateIntegration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the IntegrationPatch model
				integrationPatchModel := new(watsonxdatav2.IntegrationPatch)
				integrationPatchModel.Apikey = core.StringPtr("apikey")
				integrationPatchModel.EnableDataPolicyWithinWxd = core.BoolPtr(true)
				integrationPatchModel.Password = core.StringPtr("password")
				integrationPatchModel.Resource = core.StringPtr("resource_name")
				integrationPatchModel.StorageCatalogs = []string{"iceberg_data", "hive_data"}
				integrationPatchModel.URL = core.StringPtr("http://abcd.efgh.com:9876/")
				integrationPatchModel.Username = core.StringPtr("username")
				integrationPatchModelAsPatch, asPatchErr := integrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateIntegrationOptions model
				updateIntegrationOptionsModel := new(watsonxdatav2.UpdateIntegrationOptions)
				updateIntegrationOptionsModel.IntegrationID = core.StringPtr("testString")
				updateIntegrationOptionsModel.IntegrationPatch = integrationPatchModelAsPatch
				updateIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdateIntegration(updateIntegrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListDb2Engines(listDb2EnginesOptions *ListDb2EnginesOptions) - Operation response error`, func() {
		listDb2EnginesPath := "/db2_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listDb2EnginesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListDb2Engines with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListDb2EnginesOptions model
				listDb2EnginesOptionsModel := new(watsonxdatav2.ListDb2EnginesOptions)
				listDb2EnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listDb2EnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListDb2Engines(listDb2EnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListDb2Engines(listDb2EnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListDb2Engines(listDb2EnginesOptions *ListDb2EnginesOptions)`, func() {
		listDb2EnginesPath := "/db2_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listDb2EnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"db2_engines": [{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "db2 engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-db2-01-db2-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "db2"}]}`)
				}))
			})
			It(`Invoke ListDb2Engines successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListDb2EnginesOptions model
				listDb2EnginesOptionsModel := new(watsonxdatav2.ListDb2EnginesOptions)
				listDb2EnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listDb2EnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListDb2EnginesWithContext(ctx, listDb2EnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListDb2Engines(listDb2EnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListDb2EnginesWithContext(ctx, listDb2EnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listDb2EnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"db2_engines": [{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "db2 engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-db2-01-db2-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "db2"}]}`)
				}))
			})
			It(`Invoke ListDb2Engines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListDb2Engines(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListDb2EnginesOptions model
				listDb2EnginesOptionsModel := new(watsonxdatav2.ListDb2EnginesOptions)
				listDb2EnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listDb2EnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListDb2Engines(listDb2EnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListDb2Engines with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListDb2EnginesOptions model
				listDb2EnginesOptionsModel := new(watsonxdatav2.ListDb2EnginesOptions)
				listDb2EnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listDb2EnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListDb2Engines(listDb2EnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListDb2Engines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListDb2EnginesOptions model
				listDb2EnginesOptionsModel := new(watsonxdatav2.ListDb2EnginesOptions)
				listDb2EnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listDb2EnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListDb2Engines(listDb2EnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateDb2Engine(createDb2EngineOptions *CreateDb2EngineOptions) - Operation response error`, func() {
		createDb2EnginePath := "/db2_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createDb2EnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateDb2Engine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the Db2EngineDetailsBody model
				db2EngineDetailsBodyModel := new(watsonxdatav2.Db2EngineDetailsBody)
				db2EngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")

				// Construct an instance of the CreateDb2EngineOptions model
				createDb2EngineOptionsModel := new(watsonxdatav2.CreateDb2EngineOptions)
				createDb2EngineOptionsModel.Origin = core.StringPtr("external")
				createDb2EngineOptionsModel.Description = core.StringPtr("db2 engine description")
				createDb2EngineOptionsModel.EngineDetails = db2EngineDetailsBodyModel
				createDb2EngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createDb2EngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateDb2Engine(createDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateDb2Engine(createDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateDb2Engine(createDb2EngineOptions *CreateDb2EngineOptions)`, func() {
		createDb2EnginePath := "/db2_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createDb2EnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "db2 engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-db2-01-db2-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "db2"}`)
				}))
			})
			It(`Invoke CreateDb2Engine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the Db2EngineDetailsBody model
				db2EngineDetailsBodyModel := new(watsonxdatav2.Db2EngineDetailsBody)
				db2EngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")

				// Construct an instance of the CreateDb2EngineOptions model
				createDb2EngineOptionsModel := new(watsonxdatav2.CreateDb2EngineOptions)
				createDb2EngineOptionsModel.Origin = core.StringPtr("external")
				createDb2EngineOptionsModel.Description = core.StringPtr("db2 engine description")
				createDb2EngineOptionsModel.EngineDetails = db2EngineDetailsBodyModel
				createDb2EngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createDb2EngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateDb2EngineWithContext(ctx, createDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateDb2Engine(createDb2EngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateDb2EngineWithContext(ctx, createDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createDb2EnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "db2 engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-db2-01-db2-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "db2"}`)
				}))
			})
			It(`Invoke CreateDb2Engine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateDb2Engine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Db2EngineDetailsBody model
				db2EngineDetailsBodyModel := new(watsonxdatav2.Db2EngineDetailsBody)
				db2EngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")

				// Construct an instance of the CreateDb2EngineOptions model
				createDb2EngineOptionsModel := new(watsonxdatav2.CreateDb2EngineOptions)
				createDb2EngineOptionsModel.Origin = core.StringPtr("external")
				createDb2EngineOptionsModel.Description = core.StringPtr("db2 engine description")
				createDb2EngineOptionsModel.EngineDetails = db2EngineDetailsBodyModel
				createDb2EngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createDb2EngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateDb2Engine(createDb2EngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateDb2Engine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the Db2EngineDetailsBody model
				db2EngineDetailsBodyModel := new(watsonxdatav2.Db2EngineDetailsBody)
				db2EngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")

				// Construct an instance of the CreateDb2EngineOptions model
				createDb2EngineOptionsModel := new(watsonxdatav2.CreateDb2EngineOptions)
				createDb2EngineOptionsModel.Origin = core.StringPtr("external")
				createDb2EngineOptionsModel.Description = core.StringPtr("db2 engine description")
				createDb2EngineOptionsModel.EngineDetails = db2EngineDetailsBodyModel
				createDb2EngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createDb2EngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateDb2Engine(createDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateDb2EngineOptions model with no property values
				createDb2EngineOptionsModelNew := new(watsonxdatav2.CreateDb2EngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateDb2Engine(createDb2EngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateDb2Engine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the Db2EngineDetailsBody model
				db2EngineDetailsBodyModel := new(watsonxdatav2.Db2EngineDetailsBody)
				db2EngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")

				// Construct an instance of the CreateDb2EngineOptions model
				createDb2EngineOptionsModel := new(watsonxdatav2.CreateDb2EngineOptions)
				createDb2EngineOptionsModel.Origin = core.StringPtr("external")
				createDb2EngineOptionsModel.Description = core.StringPtr("db2 engine description")
				createDb2EngineOptionsModel.EngineDetails = db2EngineDetailsBodyModel
				createDb2EngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createDb2EngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateDb2Engine(createDb2EngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteDb2Engine(deleteDb2EngineOptions *DeleteDb2EngineOptions)`, func() {
		deleteDb2EnginePath := "/db2_engines/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteDb2EnginePath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteDb2Engine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteDb2Engine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteDb2EngineOptions model
				deleteDb2EngineOptionsModel := new(watsonxdatav2.DeleteDb2EngineOptions)
				deleteDb2EngineOptionsModel.EngineID = core.StringPtr("testString")
				deleteDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteDb2Engine(deleteDb2EngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteDb2Engine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteDb2EngineOptions model
				deleteDb2EngineOptionsModel := new(watsonxdatav2.DeleteDb2EngineOptions)
				deleteDb2EngineOptionsModel.EngineID = core.StringPtr("testString")
				deleteDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteDb2Engine(deleteDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteDb2EngineOptions model with no property values
				deleteDb2EngineOptionsModelNew := new(watsonxdatav2.DeleteDb2EngineOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteDb2Engine(deleteDb2EngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateDb2Engine(updateDb2EngineOptions *UpdateDb2EngineOptions) - Operation response error`, func() {
		updateDb2EnginePath := "/db2_engines/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateDb2EnginePath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateDb2Engine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the Db2EnginePatch model
				db2EnginePatchModel := new(watsonxdatav2.Db2EnginePatch)
				db2EnginePatchModel.Description = core.StringPtr("db2 engine updated description")
				db2EnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				db2EnginePatchModel.Tags = []string{"tag1", "tag2"}
				db2EnginePatchModelAsPatch, asPatchErr := db2EnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateDb2EngineOptions model
				updateDb2EngineOptionsModel := new(watsonxdatav2.UpdateDb2EngineOptions)
				updateDb2EngineOptionsModel.EngineID = core.StringPtr("testString")
				updateDb2EngineOptionsModel.Body = db2EnginePatchModelAsPatch
				updateDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdateDb2Engine(updateDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdateDb2Engine(updateDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateDb2Engine(updateDb2EngineOptions *UpdateDb2EngineOptions)`, func() {
		updateDb2EnginePath := "/db2_engines/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateDb2EnginePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "db2 engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-db2-01-db2-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "db2"}`)
				}))
			})
			It(`Invoke UpdateDb2Engine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the Db2EnginePatch model
				db2EnginePatchModel := new(watsonxdatav2.Db2EnginePatch)
				db2EnginePatchModel.Description = core.StringPtr("db2 engine updated description")
				db2EnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				db2EnginePatchModel.Tags = []string{"tag1", "tag2"}
				db2EnginePatchModelAsPatch, asPatchErr := db2EnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateDb2EngineOptions model
				updateDb2EngineOptionsModel := new(watsonxdatav2.UpdateDb2EngineOptions)
				updateDb2EngineOptionsModel.EngineID = core.StringPtr("testString")
				updateDb2EngineOptionsModel.Body = db2EnginePatchModelAsPatch
				updateDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdateDb2EngineWithContext(ctx, updateDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdateDb2Engine(updateDb2EngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdateDb2EngineWithContext(ctx, updateDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateDb2EnginePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "db2 engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-db2-01-db2-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "db2"}`)
				}))
			})
			It(`Invoke UpdateDb2Engine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdateDb2Engine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Db2EnginePatch model
				db2EnginePatchModel := new(watsonxdatav2.Db2EnginePatch)
				db2EnginePatchModel.Description = core.StringPtr("db2 engine updated description")
				db2EnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				db2EnginePatchModel.Tags = []string{"tag1", "tag2"}
				db2EnginePatchModelAsPatch, asPatchErr := db2EnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateDb2EngineOptions model
				updateDb2EngineOptionsModel := new(watsonxdatav2.UpdateDb2EngineOptions)
				updateDb2EngineOptionsModel.EngineID = core.StringPtr("testString")
				updateDb2EngineOptionsModel.Body = db2EnginePatchModelAsPatch
				updateDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdateDb2Engine(updateDb2EngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateDb2Engine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the Db2EnginePatch model
				db2EnginePatchModel := new(watsonxdatav2.Db2EnginePatch)
				db2EnginePatchModel.Description = core.StringPtr("db2 engine updated description")
				db2EnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				db2EnginePatchModel.Tags = []string{"tag1", "tag2"}
				db2EnginePatchModelAsPatch, asPatchErr := db2EnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateDb2EngineOptions model
				updateDb2EngineOptionsModel := new(watsonxdatav2.UpdateDb2EngineOptions)
				updateDb2EngineOptionsModel.EngineID = core.StringPtr("testString")
				updateDb2EngineOptionsModel.Body = db2EnginePatchModelAsPatch
				updateDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdateDb2Engine(updateDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateDb2EngineOptions model with no property values
				updateDb2EngineOptionsModelNew := new(watsonxdatav2.UpdateDb2EngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdateDb2Engine(updateDb2EngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateDb2Engine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the Db2EnginePatch model
				db2EnginePatchModel := new(watsonxdatav2.Db2EnginePatch)
				db2EnginePatchModel.Description = core.StringPtr("db2 engine updated description")
				db2EnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				db2EnginePatchModel.Tags = []string{"tag1", "tag2"}
				db2EnginePatchModelAsPatch, asPatchErr := db2EnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateDb2EngineOptions model
				updateDb2EngineOptionsModel := new(watsonxdatav2.UpdateDb2EngineOptions)
				updateDb2EngineOptionsModel.EngineID = core.StringPtr("testString")
				updateDb2EngineOptionsModel.Body = db2EnginePatchModelAsPatch
				updateDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdateDb2Engine(updateDb2EngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListNetezzaEngines(listNetezzaEnginesOptions *ListNetezzaEnginesOptions) - Operation response error`, func() {
		listNetezzaEnginesPath := "/netezza_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listNetezzaEnginesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListNetezzaEngines with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListNetezzaEnginesOptions model
				listNetezzaEnginesOptionsModel := new(watsonxdatav2.ListNetezzaEnginesOptions)
				listNetezzaEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listNetezzaEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListNetezzaEngines(listNetezzaEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListNetezzaEngines(listNetezzaEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListNetezzaEngines(listNetezzaEnginesOptions *ListNetezzaEnginesOptions)`, func() {
		listNetezzaEnginesPath := "/netezza_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listNetezzaEnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"netezza_engines": [{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "netezza engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-netezza-01-netezza-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "netezza"}]}`)
				}))
			})
			It(`Invoke ListNetezzaEngines successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListNetezzaEnginesOptions model
				listNetezzaEnginesOptionsModel := new(watsonxdatav2.ListNetezzaEnginesOptions)
				listNetezzaEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listNetezzaEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListNetezzaEnginesWithContext(ctx, listNetezzaEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListNetezzaEngines(listNetezzaEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListNetezzaEnginesWithContext(ctx, listNetezzaEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listNetezzaEnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"netezza_engines": [{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "netezza engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-netezza-01-netezza-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "netezza"}]}`)
				}))
			})
			It(`Invoke ListNetezzaEngines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListNetezzaEngines(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListNetezzaEnginesOptions model
				listNetezzaEnginesOptionsModel := new(watsonxdatav2.ListNetezzaEnginesOptions)
				listNetezzaEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listNetezzaEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListNetezzaEngines(listNetezzaEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListNetezzaEngines with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListNetezzaEnginesOptions model
				listNetezzaEnginesOptionsModel := new(watsonxdatav2.ListNetezzaEnginesOptions)
				listNetezzaEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listNetezzaEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListNetezzaEngines(listNetezzaEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListNetezzaEngines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListNetezzaEnginesOptions model
				listNetezzaEnginesOptionsModel := new(watsonxdatav2.ListNetezzaEnginesOptions)
				listNetezzaEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listNetezzaEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListNetezzaEngines(listNetezzaEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateNetezzaEngine(createNetezzaEngineOptions *CreateNetezzaEngineOptions) - Operation response error`, func() {
		createNetezzaEnginePath := "/netezza_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createNetezzaEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateNetezzaEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NetezzaEngineDetailsBody model
				netezzaEngineDetailsBodyModel := new(watsonxdatav2.NetezzaEngineDetailsBody)
				netezzaEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")

				// Construct an instance of the CreateNetezzaEngineOptions model
				createNetezzaEngineOptionsModel := new(watsonxdatav2.CreateNetezzaEngineOptions)
				createNetezzaEngineOptionsModel.Origin = core.StringPtr("external")
				createNetezzaEngineOptionsModel.Description = core.StringPtr("netezza engine description")
				createNetezzaEngineOptionsModel.EngineDetails = netezzaEngineDetailsBodyModel
				createNetezzaEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createNetezzaEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateNetezzaEngine(createNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateNetezzaEngine(createNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateNetezzaEngine(createNetezzaEngineOptions *CreateNetezzaEngineOptions)`, func() {
		createNetezzaEnginePath := "/netezza_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createNetezzaEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "netezza engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-netezza-01-netezza-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "netezza"}`)
				}))
			})
			It(`Invoke CreateNetezzaEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the NetezzaEngineDetailsBody model
				netezzaEngineDetailsBodyModel := new(watsonxdatav2.NetezzaEngineDetailsBody)
				netezzaEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")

				// Construct an instance of the CreateNetezzaEngineOptions model
				createNetezzaEngineOptionsModel := new(watsonxdatav2.CreateNetezzaEngineOptions)
				createNetezzaEngineOptionsModel.Origin = core.StringPtr("external")
				createNetezzaEngineOptionsModel.Description = core.StringPtr("netezza engine description")
				createNetezzaEngineOptionsModel.EngineDetails = netezzaEngineDetailsBodyModel
				createNetezzaEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createNetezzaEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateNetezzaEngineWithContext(ctx, createNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateNetezzaEngine(createNetezzaEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateNetezzaEngineWithContext(ctx, createNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createNetezzaEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "netezza engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-netezza-01-netezza-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "netezza"}`)
				}))
			})
			It(`Invoke CreateNetezzaEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateNetezzaEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the NetezzaEngineDetailsBody model
				netezzaEngineDetailsBodyModel := new(watsonxdatav2.NetezzaEngineDetailsBody)
				netezzaEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")

				// Construct an instance of the CreateNetezzaEngineOptions model
				createNetezzaEngineOptionsModel := new(watsonxdatav2.CreateNetezzaEngineOptions)
				createNetezzaEngineOptionsModel.Origin = core.StringPtr("external")
				createNetezzaEngineOptionsModel.Description = core.StringPtr("netezza engine description")
				createNetezzaEngineOptionsModel.EngineDetails = netezzaEngineDetailsBodyModel
				createNetezzaEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createNetezzaEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateNetezzaEngine(createNetezzaEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateNetezzaEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NetezzaEngineDetailsBody model
				netezzaEngineDetailsBodyModel := new(watsonxdatav2.NetezzaEngineDetailsBody)
				netezzaEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")

				// Construct an instance of the CreateNetezzaEngineOptions model
				createNetezzaEngineOptionsModel := new(watsonxdatav2.CreateNetezzaEngineOptions)
				createNetezzaEngineOptionsModel.Origin = core.StringPtr("external")
				createNetezzaEngineOptionsModel.Description = core.StringPtr("netezza engine description")
				createNetezzaEngineOptionsModel.EngineDetails = netezzaEngineDetailsBodyModel
				createNetezzaEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createNetezzaEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateNetezzaEngine(createNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateNetezzaEngineOptions model with no property values
				createNetezzaEngineOptionsModelNew := new(watsonxdatav2.CreateNetezzaEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateNetezzaEngine(createNetezzaEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateNetezzaEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NetezzaEngineDetailsBody model
				netezzaEngineDetailsBodyModel := new(watsonxdatav2.NetezzaEngineDetailsBody)
				netezzaEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")

				// Construct an instance of the CreateNetezzaEngineOptions model
				createNetezzaEngineOptionsModel := new(watsonxdatav2.CreateNetezzaEngineOptions)
				createNetezzaEngineOptionsModel.Origin = core.StringPtr("external")
				createNetezzaEngineOptionsModel.Description = core.StringPtr("netezza engine description")
				createNetezzaEngineOptionsModel.EngineDetails = netezzaEngineDetailsBodyModel
				createNetezzaEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createNetezzaEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateNetezzaEngine(createNetezzaEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteNetezzaEngine(deleteNetezzaEngineOptions *DeleteNetezzaEngineOptions)`, func() {
		deleteNetezzaEnginePath := "/netezza_engines/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteNetezzaEnginePath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteNetezzaEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteNetezzaEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteNetezzaEngineOptions model
				deleteNetezzaEngineOptionsModel := new(watsonxdatav2.DeleteNetezzaEngineOptions)
				deleteNetezzaEngineOptionsModel.EngineID = core.StringPtr("testString")
				deleteNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteNetezzaEngine(deleteNetezzaEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteNetezzaEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteNetezzaEngineOptions model
				deleteNetezzaEngineOptionsModel := new(watsonxdatav2.DeleteNetezzaEngineOptions)
				deleteNetezzaEngineOptionsModel.EngineID = core.StringPtr("testString")
				deleteNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteNetezzaEngine(deleteNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteNetezzaEngineOptions model with no property values
				deleteNetezzaEngineOptionsModelNew := new(watsonxdatav2.DeleteNetezzaEngineOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteNetezzaEngine(deleteNetezzaEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateNetezzaEngine(updateNetezzaEngineOptions *UpdateNetezzaEngineOptions) - Operation response error`, func() {
		updateNetezzaEnginePath := "/netezza_engines/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateNetezzaEnginePath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateNetezzaEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NetezzaEnginePatch model
				netezzaEnginePatchModel := new(watsonxdatav2.NetezzaEnginePatch)
				netezzaEnginePatchModel.Description = core.StringPtr("netezza engine updated description")
				netezzaEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				netezzaEnginePatchModel.Tags = []string{"tag1", "tag2"}
				netezzaEnginePatchModelAsPatch, asPatchErr := netezzaEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateNetezzaEngineOptions model
				updateNetezzaEngineOptionsModel := new(watsonxdatav2.UpdateNetezzaEngineOptions)
				updateNetezzaEngineOptionsModel.EngineID = core.StringPtr("testString")
				updateNetezzaEngineOptionsModel.Body = netezzaEnginePatchModelAsPatch
				updateNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdateNetezzaEngine(updateNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdateNetezzaEngine(updateNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateNetezzaEngine(updateNetezzaEngineOptions *UpdateNetezzaEngineOptions)`, func() {
		updateNetezzaEnginePath := "/netezza_engines/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateNetezzaEnginePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "netezza engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-netezza-01-netezza-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "netezza"}`)
				}))
			})
			It(`Invoke UpdateNetezzaEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the NetezzaEnginePatch model
				netezzaEnginePatchModel := new(watsonxdatav2.NetezzaEnginePatch)
				netezzaEnginePatchModel.Description = core.StringPtr("netezza engine updated description")
				netezzaEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				netezzaEnginePatchModel.Tags = []string{"tag1", "tag2"}
				netezzaEnginePatchModelAsPatch, asPatchErr := netezzaEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateNetezzaEngineOptions model
				updateNetezzaEngineOptionsModel := new(watsonxdatav2.UpdateNetezzaEngineOptions)
				updateNetezzaEngineOptionsModel.EngineID = core.StringPtr("testString")
				updateNetezzaEngineOptionsModel.Body = netezzaEnginePatchModelAsPatch
				updateNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdateNetezzaEngineWithContext(ctx, updateNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdateNetezzaEngine(updateNetezzaEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdateNetezzaEngineWithContext(ctx, updateNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateNetezzaEnginePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "netezza engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-netezza-01-netezza-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "netezza"}`)
				}))
			})
			It(`Invoke UpdateNetezzaEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdateNetezzaEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the NetezzaEnginePatch model
				netezzaEnginePatchModel := new(watsonxdatav2.NetezzaEnginePatch)
				netezzaEnginePatchModel.Description = core.StringPtr("netezza engine updated description")
				netezzaEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				netezzaEnginePatchModel.Tags = []string{"tag1", "tag2"}
				netezzaEnginePatchModelAsPatch, asPatchErr := netezzaEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateNetezzaEngineOptions model
				updateNetezzaEngineOptionsModel := new(watsonxdatav2.UpdateNetezzaEngineOptions)
				updateNetezzaEngineOptionsModel.EngineID = core.StringPtr("testString")
				updateNetezzaEngineOptionsModel.Body = netezzaEnginePatchModelAsPatch
				updateNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdateNetezzaEngine(updateNetezzaEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateNetezzaEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NetezzaEnginePatch model
				netezzaEnginePatchModel := new(watsonxdatav2.NetezzaEnginePatch)
				netezzaEnginePatchModel.Description = core.StringPtr("netezza engine updated description")
				netezzaEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				netezzaEnginePatchModel.Tags = []string{"tag1", "tag2"}
				netezzaEnginePatchModelAsPatch, asPatchErr := netezzaEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateNetezzaEngineOptions model
				updateNetezzaEngineOptionsModel := new(watsonxdatav2.UpdateNetezzaEngineOptions)
				updateNetezzaEngineOptionsModel.EngineID = core.StringPtr("testString")
				updateNetezzaEngineOptionsModel.Body = netezzaEnginePatchModelAsPatch
				updateNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdateNetezzaEngine(updateNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateNetezzaEngineOptions model with no property values
				updateNetezzaEngineOptionsModelNew := new(watsonxdatav2.UpdateNetezzaEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdateNetezzaEngine(updateNetezzaEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateNetezzaEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NetezzaEnginePatch model
				netezzaEnginePatchModel := new(watsonxdatav2.NetezzaEnginePatch)
				netezzaEnginePatchModel.Description = core.StringPtr("netezza engine updated description")
				netezzaEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				netezzaEnginePatchModel.Tags = []string{"tag1", "tag2"}
				netezzaEnginePatchModelAsPatch, asPatchErr := netezzaEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateNetezzaEngineOptions model
				updateNetezzaEngineOptionsModel := new(watsonxdatav2.UpdateNetezzaEngineOptions)
				updateNetezzaEngineOptionsModel.EngineID = core.StringPtr("testString")
				updateNetezzaEngineOptionsModel.Body = netezzaEnginePatchModelAsPatch
				updateNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdateNetezzaEngine(updateNetezzaEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateExecuteQuery(createExecuteQueryOptions *CreateExecuteQueryOptions) - Operation response error`, func() {
		createExecuteQueryPath := "/queries/execute/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createExecuteQueryPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateExecuteQuery with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateExecuteQueryOptions model
				createExecuteQueryOptionsModel := new(watsonxdatav2.CreateExecuteQueryOptions)
				createExecuteQueryOptionsModel.EngineID = core.StringPtr("testString")
				createExecuteQueryOptionsModel.SqlString = core.StringPtr("select expenses from expenditure")
				createExecuteQueryOptionsModel.CatalogName = core.StringPtr("sampleCatalog")
				createExecuteQueryOptionsModel.SchemaName = core.StringPtr("SampleSchema1")
				createExecuteQueryOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createExecuteQueryOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateExecuteQuery(createExecuteQueryOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateExecuteQuery(createExecuteQueryOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateExecuteQuery(createExecuteQueryOptions *CreateExecuteQueryOptions)`, func() {
		createExecuteQueryPath := "/queries/execute/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createExecuteQueryPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"response": {"result": [{"mapKey": "Inner"}]}}`)
				}))
			})
			It(`Invoke CreateExecuteQuery successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreateExecuteQueryOptions model
				createExecuteQueryOptionsModel := new(watsonxdatav2.CreateExecuteQueryOptions)
				createExecuteQueryOptionsModel.EngineID = core.StringPtr("testString")
				createExecuteQueryOptionsModel.SqlString = core.StringPtr("select expenses from expenditure")
				createExecuteQueryOptionsModel.CatalogName = core.StringPtr("sampleCatalog")
				createExecuteQueryOptionsModel.SchemaName = core.StringPtr("SampleSchema1")
				createExecuteQueryOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createExecuteQueryOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateExecuteQueryWithContext(ctx, createExecuteQueryOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateExecuteQuery(createExecuteQueryOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateExecuteQueryWithContext(ctx, createExecuteQueryOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createExecuteQueryPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"response": {"result": [{"mapKey": "Inner"}]}}`)
				}))
			})
			It(`Invoke CreateExecuteQuery successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateExecuteQuery(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreateExecuteQueryOptions model
				createExecuteQueryOptionsModel := new(watsonxdatav2.CreateExecuteQueryOptions)
				createExecuteQueryOptionsModel.EngineID = core.StringPtr("testString")
				createExecuteQueryOptionsModel.SqlString = core.StringPtr("select expenses from expenditure")
				createExecuteQueryOptionsModel.CatalogName = core.StringPtr("sampleCatalog")
				createExecuteQueryOptionsModel.SchemaName = core.StringPtr("SampleSchema1")
				createExecuteQueryOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createExecuteQueryOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateExecuteQuery(createExecuteQueryOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateExecuteQuery with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateExecuteQueryOptions model
				createExecuteQueryOptionsModel := new(watsonxdatav2.CreateExecuteQueryOptions)
				createExecuteQueryOptionsModel.EngineID = core.StringPtr("testString")
				createExecuteQueryOptionsModel.SqlString = core.StringPtr("select expenses from expenditure")
				createExecuteQueryOptionsModel.CatalogName = core.StringPtr("sampleCatalog")
				createExecuteQueryOptionsModel.SchemaName = core.StringPtr("SampleSchema1")
				createExecuteQueryOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createExecuteQueryOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateExecuteQuery(createExecuteQueryOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateExecuteQueryOptions model with no property values
				createExecuteQueryOptionsModelNew := new(watsonxdatav2.CreateExecuteQueryOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateExecuteQuery(createExecuteQueryOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateExecuteQuery successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateExecuteQueryOptions model
				createExecuteQueryOptionsModel := new(watsonxdatav2.CreateExecuteQueryOptions)
				createExecuteQueryOptionsModel.EngineID = core.StringPtr("testString")
				createExecuteQueryOptionsModel.SqlString = core.StringPtr("select expenses from expenditure")
				createExecuteQueryOptionsModel.CatalogName = core.StringPtr("sampleCatalog")
				createExecuteQueryOptionsModel.SchemaName = core.StringPtr("SampleSchema1")
				createExecuteQueryOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createExecuteQueryOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateExecuteQuery(createExecuteQueryOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListPrestissimoEngines(listPrestissimoEnginesOptions *ListPrestissimoEnginesOptions) - Operation response error`, func() {
		listPrestissimoEnginesPath := "/prestissimo_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestissimoEnginesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListPrestissimoEngines with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestissimoEnginesOptions model
				listPrestissimoEnginesOptionsModel := new(watsonxdatav2.ListPrestissimoEnginesOptions)
				listPrestissimoEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestissimoEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListPrestissimoEngines(listPrestissimoEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListPrestissimoEngines(listPrestissimoEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListPrestissimoEngines(listPrestissimoEnginesOptions *ListPrestissimoEnginesOptions)`, func() {
		listPrestissimoEnginesPath := "/prestissimo_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestissimoEnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"prestissimo_engines": [{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "prestissimo engine for running sql queries", "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications"}, "instance_id": "instance_id", "managed_by": "fully/self", "metastore_host": "1.2.3.4", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "velox": {"velox_property": ["VeloxProperty"]}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "xyz-prestissimo-01-prestissimo-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"]}, "velox": ["Velox"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "prestissimo", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}]}`)
				}))
			})
			It(`Invoke ListPrestissimoEngines successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListPrestissimoEnginesOptions model
				listPrestissimoEnginesOptionsModel := new(watsonxdatav2.ListPrestissimoEnginesOptions)
				listPrestissimoEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestissimoEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListPrestissimoEnginesWithContext(ctx, listPrestissimoEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListPrestissimoEngines(listPrestissimoEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListPrestissimoEnginesWithContext(ctx, listPrestissimoEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestissimoEnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"prestissimo_engines": [{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "prestissimo engine for running sql queries", "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications"}, "instance_id": "instance_id", "managed_by": "fully/self", "metastore_host": "1.2.3.4", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "velox": {"velox_property": ["VeloxProperty"]}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "xyz-prestissimo-01-prestissimo-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"]}, "velox": ["Velox"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "prestissimo", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}]}`)
				}))
			})
			It(`Invoke ListPrestissimoEngines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListPrestissimoEngines(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListPrestissimoEnginesOptions model
				listPrestissimoEnginesOptionsModel := new(watsonxdatav2.ListPrestissimoEnginesOptions)
				listPrestissimoEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestissimoEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListPrestissimoEngines(listPrestissimoEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListPrestissimoEngines with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestissimoEnginesOptions model
				listPrestissimoEnginesOptionsModel := new(watsonxdatav2.ListPrestissimoEnginesOptions)
				listPrestissimoEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestissimoEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListPrestissimoEngines(listPrestissimoEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListPrestissimoEngines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestissimoEnginesOptions model
				listPrestissimoEnginesOptionsModel := new(watsonxdatav2.ListPrestissimoEnginesOptions)
				listPrestissimoEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestissimoEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListPrestissimoEngines(listPrestissimoEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreatePrestissimoEngine(createPrestissimoEngineOptions *CreatePrestissimoEngineOptions) - Operation response error`, func() {
		createPrestissimoEnginePath := "/prestissimo_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreatePrestissimoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the PrestissimoEndpoints model
				prestissimoEndpointsModel := new(watsonxdatav2.PrestissimoEndpoints)
				prestissimoEndpointsModel.ApplicationsApi = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>")
				prestissimoEndpointsModel.HistoryServerEndpoint = core.StringPtr("$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server")
				prestissimoEndpointsModel.SparkAccessEndpoint = core.StringPtr("$HOST/analytics-engine/details/spark-<instance_id>")
				prestissimoEndpointsModel.SparkJobsV4Endpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications")
				prestissimoEndpointsModel.SparkKernelEndpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels")
				prestissimoEndpointsModel.ViewHistoryServer = core.StringPtr("testString")
				prestissimoEndpointsModel.WxdApplicationEndpoint = core.StringPtr("$HOST/v1/1698311655308796/engines/spark817/applications")

				// Construct an instance of the PrestissimoEngineDetails model
				prestissimoEngineDetailsModel := new(watsonxdatav2.PrestissimoEngineDetails)
				prestissimoEngineDetailsModel.ApiKey = core.StringPtr("<api_key>")
				prestissimoEngineDetailsModel.ConnectionString = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				prestissimoEngineDetailsModel.Endpoints = prestissimoEndpointsModel
				prestissimoEngineDetailsModel.InstanceID = core.StringPtr("instance_id")
				prestissimoEngineDetailsModel.ManagedBy = core.StringPtr("fully/self")
				prestissimoEngineDetailsModel.MetastoreHost = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.SizeConfig = core.StringPtr("starter")
				prestissimoEngineDetailsModel.Worker = prestissimoNodeDescriptionBodyModel

				// Construct an instance of the CreatePrestissimoEngineOptions model
				createPrestissimoEngineOptionsModel := new(watsonxdatav2.CreatePrestissimoEngineOptions)
				createPrestissimoEngineOptionsModel.Origin = core.StringPtr("native")
				createPrestissimoEngineOptionsModel.AssociatedCatalogs = []string{"hive_data"}
				createPrestissimoEngineOptionsModel.Description = core.StringPtr("prestissimo engine description")
				createPrestissimoEngineOptionsModel.EngineDetails = prestissimoEngineDetailsModel
				createPrestissimoEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createPrestissimoEngineOptionsModel.Region = core.StringPtr("us-south")
				createPrestissimoEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createPrestissimoEngineOptionsModel.Version = core.StringPtr("1.2.3")
				createPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreatePrestissimoEngine(createPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreatePrestissimoEngine(createPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreatePrestissimoEngine(createPrestissimoEngineOptions *CreatePrestissimoEngineOptions)`, func() {
		createPrestissimoEnginePath := "/prestissimo_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "prestissimo engine for running sql queries", "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications"}, "instance_id": "instance_id", "managed_by": "fully/self", "metastore_host": "1.2.3.4", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "velox": {"velox_property": ["VeloxProperty"]}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "xyz-prestissimo-01-prestissimo-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"]}, "velox": ["Velox"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "prestissimo", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke CreatePrestissimoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the PrestissimoEndpoints model
				prestissimoEndpointsModel := new(watsonxdatav2.PrestissimoEndpoints)
				prestissimoEndpointsModel.ApplicationsApi = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>")
				prestissimoEndpointsModel.HistoryServerEndpoint = core.StringPtr("$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server")
				prestissimoEndpointsModel.SparkAccessEndpoint = core.StringPtr("$HOST/analytics-engine/details/spark-<instance_id>")
				prestissimoEndpointsModel.SparkJobsV4Endpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications")
				prestissimoEndpointsModel.SparkKernelEndpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels")
				prestissimoEndpointsModel.ViewHistoryServer = core.StringPtr("testString")
				prestissimoEndpointsModel.WxdApplicationEndpoint = core.StringPtr("$HOST/v1/1698311655308796/engines/spark817/applications")

				// Construct an instance of the PrestissimoEngineDetails model
				prestissimoEngineDetailsModel := new(watsonxdatav2.PrestissimoEngineDetails)
				prestissimoEngineDetailsModel.ApiKey = core.StringPtr("<api_key>")
				prestissimoEngineDetailsModel.ConnectionString = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				prestissimoEngineDetailsModel.Endpoints = prestissimoEndpointsModel
				prestissimoEngineDetailsModel.InstanceID = core.StringPtr("instance_id")
				prestissimoEngineDetailsModel.ManagedBy = core.StringPtr("fully/self")
				prestissimoEngineDetailsModel.MetastoreHost = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.SizeConfig = core.StringPtr("starter")
				prestissimoEngineDetailsModel.Worker = prestissimoNodeDescriptionBodyModel

				// Construct an instance of the CreatePrestissimoEngineOptions model
				createPrestissimoEngineOptionsModel := new(watsonxdatav2.CreatePrestissimoEngineOptions)
				createPrestissimoEngineOptionsModel.Origin = core.StringPtr("native")
				createPrestissimoEngineOptionsModel.AssociatedCatalogs = []string{"hive_data"}
				createPrestissimoEngineOptionsModel.Description = core.StringPtr("prestissimo engine description")
				createPrestissimoEngineOptionsModel.EngineDetails = prestissimoEngineDetailsModel
				createPrestissimoEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createPrestissimoEngineOptionsModel.Region = core.StringPtr("us-south")
				createPrestissimoEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createPrestissimoEngineOptionsModel.Version = core.StringPtr("1.2.3")
				createPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreatePrestissimoEngineWithContext(ctx, createPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreatePrestissimoEngine(createPrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreatePrestissimoEngineWithContext(ctx, createPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "prestissimo engine for running sql queries", "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications"}, "instance_id": "instance_id", "managed_by": "fully/self", "metastore_host": "1.2.3.4", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "velox": {"velox_property": ["VeloxProperty"]}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "xyz-prestissimo-01-prestissimo-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"]}, "velox": ["Velox"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "prestissimo", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke CreatePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreatePrestissimoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the PrestissimoEndpoints model
				prestissimoEndpointsModel := new(watsonxdatav2.PrestissimoEndpoints)
				prestissimoEndpointsModel.ApplicationsApi = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>")
				prestissimoEndpointsModel.HistoryServerEndpoint = core.StringPtr("$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server")
				prestissimoEndpointsModel.SparkAccessEndpoint = core.StringPtr("$HOST/analytics-engine/details/spark-<instance_id>")
				prestissimoEndpointsModel.SparkJobsV4Endpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications")
				prestissimoEndpointsModel.SparkKernelEndpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels")
				prestissimoEndpointsModel.ViewHistoryServer = core.StringPtr("testString")
				prestissimoEndpointsModel.WxdApplicationEndpoint = core.StringPtr("$HOST/v1/1698311655308796/engines/spark817/applications")

				// Construct an instance of the PrestissimoEngineDetails model
				prestissimoEngineDetailsModel := new(watsonxdatav2.PrestissimoEngineDetails)
				prestissimoEngineDetailsModel.ApiKey = core.StringPtr("<api_key>")
				prestissimoEngineDetailsModel.ConnectionString = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				prestissimoEngineDetailsModel.Endpoints = prestissimoEndpointsModel
				prestissimoEngineDetailsModel.InstanceID = core.StringPtr("instance_id")
				prestissimoEngineDetailsModel.ManagedBy = core.StringPtr("fully/self")
				prestissimoEngineDetailsModel.MetastoreHost = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.SizeConfig = core.StringPtr("starter")
				prestissimoEngineDetailsModel.Worker = prestissimoNodeDescriptionBodyModel

				// Construct an instance of the CreatePrestissimoEngineOptions model
				createPrestissimoEngineOptionsModel := new(watsonxdatav2.CreatePrestissimoEngineOptions)
				createPrestissimoEngineOptionsModel.Origin = core.StringPtr("native")
				createPrestissimoEngineOptionsModel.AssociatedCatalogs = []string{"hive_data"}
				createPrestissimoEngineOptionsModel.Description = core.StringPtr("prestissimo engine description")
				createPrestissimoEngineOptionsModel.EngineDetails = prestissimoEngineDetailsModel
				createPrestissimoEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createPrestissimoEngineOptionsModel.Region = core.StringPtr("us-south")
				createPrestissimoEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createPrestissimoEngineOptionsModel.Version = core.StringPtr("1.2.3")
				createPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreatePrestissimoEngine(createPrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreatePrestissimoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the PrestissimoEndpoints model
				prestissimoEndpointsModel := new(watsonxdatav2.PrestissimoEndpoints)
				prestissimoEndpointsModel.ApplicationsApi = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>")
				prestissimoEndpointsModel.HistoryServerEndpoint = core.StringPtr("$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server")
				prestissimoEndpointsModel.SparkAccessEndpoint = core.StringPtr("$HOST/analytics-engine/details/spark-<instance_id>")
				prestissimoEndpointsModel.SparkJobsV4Endpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications")
				prestissimoEndpointsModel.SparkKernelEndpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels")
				prestissimoEndpointsModel.ViewHistoryServer = core.StringPtr("testString")
				prestissimoEndpointsModel.WxdApplicationEndpoint = core.StringPtr("$HOST/v1/1698311655308796/engines/spark817/applications")

				// Construct an instance of the PrestissimoEngineDetails model
				prestissimoEngineDetailsModel := new(watsonxdatav2.PrestissimoEngineDetails)
				prestissimoEngineDetailsModel.ApiKey = core.StringPtr("<api_key>")
				prestissimoEngineDetailsModel.ConnectionString = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				prestissimoEngineDetailsModel.Endpoints = prestissimoEndpointsModel
				prestissimoEngineDetailsModel.InstanceID = core.StringPtr("instance_id")
				prestissimoEngineDetailsModel.ManagedBy = core.StringPtr("fully/self")
				prestissimoEngineDetailsModel.MetastoreHost = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.SizeConfig = core.StringPtr("starter")
				prestissimoEngineDetailsModel.Worker = prestissimoNodeDescriptionBodyModel

				// Construct an instance of the CreatePrestissimoEngineOptions model
				createPrestissimoEngineOptionsModel := new(watsonxdatav2.CreatePrestissimoEngineOptions)
				createPrestissimoEngineOptionsModel.Origin = core.StringPtr("native")
				createPrestissimoEngineOptionsModel.AssociatedCatalogs = []string{"hive_data"}
				createPrestissimoEngineOptionsModel.Description = core.StringPtr("prestissimo engine description")
				createPrestissimoEngineOptionsModel.EngineDetails = prestissimoEngineDetailsModel
				createPrestissimoEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createPrestissimoEngineOptionsModel.Region = core.StringPtr("us-south")
				createPrestissimoEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createPrestissimoEngineOptionsModel.Version = core.StringPtr("1.2.3")
				createPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreatePrestissimoEngine(createPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreatePrestissimoEngineOptions model with no property values
				createPrestissimoEngineOptionsModelNew := new(watsonxdatav2.CreatePrestissimoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreatePrestissimoEngine(createPrestissimoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreatePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the PrestissimoEndpoints model
				prestissimoEndpointsModel := new(watsonxdatav2.PrestissimoEndpoints)
				prestissimoEndpointsModel.ApplicationsApi = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>")
				prestissimoEndpointsModel.HistoryServerEndpoint = core.StringPtr("$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server")
				prestissimoEndpointsModel.SparkAccessEndpoint = core.StringPtr("$HOST/analytics-engine/details/spark-<instance_id>")
				prestissimoEndpointsModel.SparkJobsV4Endpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications")
				prestissimoEndpointsModel.SparkKernelEndpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels")
				prestissimoEndpointsModel.ViewHistoryServer = core.StringPtr("testString")
				prestissimoEndpointsModel.WxdApplicationEndpoint = core.StringPtr("$HOST/v1/1698311655308796/engines/spark817/applications")

				// Construct an instance of the PrestissimoEngineDetails model
				prestissimoEngineDetailsModel := new(watsonxdatav2.PrestissimoEngineDetails)
				prestissimoEngineDetailsModel.ApiKey = core.StringPtr("<api_key>")
				prestissimoEngineDetailsModel.ConnectionString = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				prestissimoEngineDetailsModel.Endpoints = prestissimoEndpointsModel
				prestissimoEngineDetailsModel.InstanceID = core.StringPtr("instance_id")
				prestissimoEngineDetailsModel.ManagedBy = core.StringPtr("fully/self")
				prestissimoEngineDetailsModel.MetastoreHost = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.SizeConfig = core.StringPtr("starter")
				prestissimoEngineDetailsModel.Worker = prestissimoNodeDescriptionBodyModel

				// Construct an instance of the CreatePrestissimoEngineOptions model
				createPrestissimoEngineOptionsModel := new(watsonxdatav2.CreatePrestissimoEngineOptions)
				createPrestissimoEngineOptionsModel.Origin = core.StringPtr("native")
				createPrestissimoEngineOptionsModel.AssociatedCatalogs = []string{"hive_data"}
				createPrestissimoEngineOptionsModel.Description = core.StringPtr("prestissimo engine description")
				createPrestissimoEngineOptionsModel.EngineDetails = prestissimoEngineDetailsModel
				createPrestissimoEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createPrestissimoEngineOptionsModel.Region = core.StringPtr("us-south")
				createPrestissimoEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createPrestissimoEngineOptionsModel.Version = core.StringPtr("1.2.3")
				createPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreatePrestissimoEngine(createPrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPrestissimoEngine(getPrestissimoEngineOptions *GetPrestissimoEngineOptions) - Operation response error`, func() {
		getPrestissimoEnginePath := "/prestissimo_engines/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestissimoEnginePath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetPrestissimoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestissimoEngineOptions model
				getPrestissimoEngineOptionsModel := new(watsonxdatav2.GetPrestissimoEngineOptions)
				getPrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				getPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetPrestissimoEngine(getPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetPrestissimoEngine(getPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPrestissimoEngine(getPrestissimoEngineOptions *GetPrestissimoEngineOptions)`, func() {
		getPrestissimoEnginePath := "/prestissimo_engines/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestissimoEnginePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "prestissimo engine for running sql queries", "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications"}, "instance_id": "instance_id", "managed_by": "fully/self", "metastore_host": "1.2.3.4", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "velox": {"velox_property": ["VeloxProperty"]}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "xyz-prestissimo-01-prestissimo-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"]}, "velox": ["Velox"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "prestissimo", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke GetPrestissimoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetPrestissimoEngineOptions model
				getPrestissimoEngineOptionsModel := new(watsonxdatav2.GetPrestissimoEngineOptions)
				getPrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				getPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetPrestissimoEngineWithContext(ctx, getPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetPrestissimoEngine(getPrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetPrestissimoEngineWithContext(ctx, getPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestissimoEnginePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "prestissimo engine for running sql queries", "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications"}, "instance_id": "instance_id", "managed_by": "fully/self", "metastore_host": "1.2.3.4", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "velox": {"velox_property": ["VeloxProperty"]}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "xyz-prestissimo-01-prestissimo-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"]}, "velox": ["Velox"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "prestissimo", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke GetPrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetPrestissimoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetPrestissimoEngineOptions model
				getPrestissimoEngineOptionsModel := new(watsonxdatav2.GetPrestissimoEngineOptions)
				getPrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				getPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetPrestissimoEngine(getPrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetPrestissimoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestissimoEngineOptions model
				getPrestissimoEngineOptionsModel := new(watsonxdatav2.GetPrestissimoEngineOptions)
				getPrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				getPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetPrestissimoEngine(getPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetPrestissimoEngineOptions model with no property values
				getPrestissimoEngineOptionsModelNew := new(watsonxdatav2.GetPrestissimoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetPrestissimoEngine(getPrestissimoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetPrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestissimoEngineOptions model
				getPrestissimoEngineOptionsModel := new(watsonxdatav2.GetPrestissimoEngineOptions)
				getPrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				getPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetPrestissimoEngine(getPrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeletePrestissimoEngine(deletePrestissimoEngineOptions *DeletePrestissimoEngineOptions)`, func() {
		deletePrestissimoEnginePath := "/prestissimo_engines/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deletePrestissimoEnginePath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeletePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeletePrestissimoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeletePrestissimoEngineOptions model
				deletePrestissimoEngineOptionsModel := new(watsonxdatav2.DeletePrestissimoEngineOptions)
				deletePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				deletePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deletePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeletePrestissimoEngine(deletePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeletePrestissimoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeletePrestissimoEngineOptions model
				deletePrestissimoEngineOptionsModel := new(watsonxdatav2.DeletePrestissimoEngineOptions)
				deletePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				deletePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deletePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeletePrestissimoEngine(deletePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeletePrestissimoEngineOptions model with no property values
				deletePrestissimoEngineOptionsModelNew := new(watsonxdatav2.DeletePrestissimoEngineOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeletePrestissimoEngine(deletePrestissimoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdatePrestissimoEngine(updatePrestissimoEngineOptions *UpdatePrestissimoEngineOptions) - Operation response error`, func() {
		updatePrestissimoEnginePath := "/prestissimo_engines/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updatePrestissimoEnginePath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdatePrestissimoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestissimoEnginePropertiesCatalog model
				prestissimoEnginePropertiesCatalogModel := new(watsonxdatav2.PrestissimoEnginePropertiesCatalog)
				prestissimoEnginePropertiesCatalogModel.CatalogName = []string{"testString"}

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EnginePropertiesOaiGenConfiguration model
				enginePropertiesOaiGenConfigurationModel := new(watsonxdatav2.EnginePropertiesOaiGenConfiguration)
				enginePropertiesOaiGenConfigurationModel.Coordinator = prestissimoNodeDescriptionBodyModel
				enginePropertiesOaiGenConfigurationModel.Worker = prestissimoNodeDescriptionBodyModel

				// Construct an instance of the PrestissimoEnginePropertiesVelox model
				prestissimoEnginePropertiesVeloxModel := new(watsonxdatav2.PrestissimoEnginePropertiesVelox)
				prestissimoEnginePropertiesVeloxModel.VeloxProperty = []string{"testString"}

				// Construct an instance of the PrestissimoEnginePropertiesGlobal model
				prestissimoEnginePropertiesGlobalModel := new(watsonxdatav2.PrestissimoEnginePropertiesGlobal)
				prestissimoEnginePropertiesGlobalModel.GlobalProperty = core.StringPtr("enable-mixed-case-support:true")

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the PrestissimoEnginePropertiesOaiGen1Jvm model
				prestissimoEnginePropertiesOaiGen1JvmModel := new(watsonxdatav2.PrestissimoEnginePropertiesOaiGen1Jvm)
				prestissimoEnginePropertiesOaiGen1JvmModel.Coordinator = nodeDescriptionBodyModel

				// Construct an instance of the PrestissimoEngineEngineProperties model
				prestissimoEngineEnginePropertiesModel := new(watsonxdatav2.PrestissimoEngineEngineProperties)
				prestissimoEngineEnginePropertiesModel.Catalog = prestissimoEnginePropertiesCatalogModel
				prestissimoEngineEnginePropertiesModel.Configuration = enginePropertiesOaiGenConfigurationModel
				prestissimoEngineEnginePropertiesModel.Velox = prestissimoEnginePropertiesVeloxModel
				prestissimoEngineEnginePropertiesModel.Global = prestissimoEnginePropertiesGlobalModel
				prestissimoEngineEnginePropertiesModel.Jvm = prestissimoEnginePropertiesOaiGen1JvmModel

				// Construct an instance of the RemoveEnginePropertiesConfiguration model
				removeEnginePropertiesConfigurationModel := new(watsonxdatav2.RemoveEnginePropertiesConfiguration)
				removeEnginePropertiesConfigurationModel.Coordinator = []string{"testString"}
				removeEnginePropertiesConfigurationModel.Worker = []string{"testString"}

				// Construct an instance of the RemoveEnginePropertiesPrestissimoOaiGenJvm model
				removeEnginePropertiesPrestissimoOaiGenJvmModel := new(watsonxdatav2.RemoveEnginePropertiesPrestissimoOaiGenJvm)
				removeEnginePropertiesPrestissimoOaiGenJvmModel.Coordinator = []string{"testString"}

				// Construct an instance of the RemoveEngineProperties model
				removeEnginePropertiesModel := new(watsonxdatav2.RemoveEngineProperties)
				removeEnginePropertiesModel.Catalog = prestissimoEnginePropertiesCatalogModel
				removeEnginePropertiesModel.Configuration = removeEnginePropertiesConfigurationModel
				removeEnginePropertiesModel.Jvm = removeEnginePropertiesPrestissimoOaiGenJvmModel
				removeEnginePropertiesModel.Velox = []string{"testString"}

				// Construct an instance of the PrestissimoEnginePatch model
				prestissimoEnginePatchModel := new(watsonxdatav2.PrestissimoEnginePatch)
				prestissimoEnginePatchModel.Description = core.StringPtr("updated description for prestissimo engine")
				prestissimoEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				prestissimoEnginePatchModel.EngineProperties = prestissimoEngineEnginePropertiesModel
				prestissimoEnginePatchModel.EngineRestart = core.StringPtr("force")
				prestissimoEnginePatchModel.RemoveEngineProperties = removeEnginePropertiesModel
				prestissimoEnginePatchModel.Tags = []string{"tag1", "tag2"}
				prestissimoEnginePatchModelAsPatch, asPatchErr := prestissimoEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdatePrestissimoEngineOptions model
				updatePrestissimoEngineOptionsModel := new(watsonxdatav2.UpdatePrestissimoEngineOptions)
				updatePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				updatePrestissimoEngineOptionsModel.Body = prestissimoEnginePatchModelAsPatch
				updatePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updatePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdatePrestissimoEngine(updatePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdatePrestissimoEngine(updatePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdatePrestissimoEngine(updatePrestissimoEngineOptions *UpdatePrestissimoEngineOptions)`, func() {
		updatePrestissimoEnginePath := "/prestissimo_engines/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updatePrestissimoEnginePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "prestissimo engine for running sql queries", "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications"}, "instance_id": "instance_id", "managed_by": "fully/self", "metastore_host": "1.2.3.4", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "velox": {"velox_property": ["VeloxProperty"]}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "xyz-prestissimo-01-prestissimo-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"]}, "velox": ["Velox"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "prestissimo", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke UpdatePrestissimoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the PrestissimoEnginePropertiesCatalog model
				prestissimoEnginePropertiesCatalogModel := new(watsonxdatav2.PrestissimoEnginePropertiesCatalog)
				prestissimoEnginePropertiesCatalogModel.CatalogName = []string{"testString"}

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EnginePropertiesOaiGenConfiguration model
				enginePropertiesOaiGenConfigurationModel := new(watsonxdatav2.EnginePropertiesOaiGenConfiguration)
				enginePropertiesOaiGenConfigurationModel.Coordinator = prestissimoNodeDescriptionBodyModel
				enginePropertiesOaiGenConfigurationModel.Worker = prestissimoNodeDescriptionBodyModel

				// Construct an instance of the PrestissimoEnginePropertiesVelox model
				prestissimoEnginePropertiesVeloxModel := new(watsonxdatav2.PrestissimoEnginePropertiesVelox)
				prestissimoEnginePropertiesVeloxModel.VeloxProperty = []string{"testString"}

				// Construct an instance of the PrestissimoEnginePropertiesGlobal model
				prestissimoEnginePropertiesGlobalModel := new(watsonxdatav2.PrestissimoEnginePropertiesGlobal)
				prestissimoEnginePropertiesGlobalModel.GlobalProperty = core.StringPtr("enable-mixed-case-support:true")

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the PrestissimoEnginePropertiesOaiGen1Jvm model
				prestissimoEnginePropertiesOaiGen1JvmModel := new(watsonxdatav2.PrestissimoEnginePropertiesOaiGen1Jvm)
				prestissimoEnginePropertiesOaiGen1JvmModel.Coordinator = nodeDescriptionBodyModel

				// Construct an instance of the PrestissimoEngineEngineProperties model
				prestissimoEngineEnginePropertiesModel := new(watsonxdatav2.PrestissimoEngineEngineProperties)
				prestissimoEngineEnginePropertiesModel.Catalog = prestissimoEnginePropertiesCatalogModel
				prestissimoEngineEnginePropertiesModel.Configuration = enginePropertiesOaiGenConfigurationModel
				prestissimoEngineEnginePropertiesModel.Velox = prestissimoEnginePropertiesVeloxModel
				prestissimoEngineEnginePropertiesModel.Global = prestissimoEnginePropertiesGlobalModel
				prestissimoEngineEnginePropertiesModel.Jvm = prestissimoEnginePropertiesOaiGen1JvmModel

				// Construct an instance of the RemoveEnginePropertiesConfiguration model
				removeEnginePropertiesConfigurationModel := new(watsonxdatav2.RemoveEnginePropertiesConfiguration)
				removeEnginePropertiesConfigurationModel.Coordinator = []string{"testString"}
				removeEnginePropertiesConfigurationModel.Worker = []string{"testString"}

				// Construct an instance of the RemoveEnginePropertiesPrestissimoOaiGenJvm model
				removeEnginePropertiesPrestissimoOaiGenJvmModel := new(watsonxdatav2.RemoveEnginePropertiesPrestissimoOaiGenJvm)
				removeEnginePropertiesPrestissimoOaiGenJvmModel.Coordinator = []string{"testString"}

				// Construct an instance of the RemoveEngineProperties model
				removeEnginePropertiesModel := new(watsonxdatav2.RemoveEngineProperties)
				removeEnginePropertiesModel.Catalog = prestissimoEnginePropertiesCatalogModel
				removeEnginePropertiesModel.Configuration = removeEnginePropertiesConfigurationModel
				removeEnginePropertiesModel.Jvm = removeEnginePropertiesPrestissimoOaiGenJvmModel
				removeEnginePropertiesModel.Velox = []string{"testString"}

				// Construct an instance of the PrestissimoEnginePatch model
				prestissimoEnginePatchModel := new(watsonxdatav2.PrestissimoEnginePatch)
				prestissimoEnginePatchModel.Description = core.StringPtr("updated description for prestissimo engine")
				prestissimoEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				prestissimoEnginePatchModel.EngineProperties = prestissimoEngineEnginePropertiesModel
				prestissimoEnginePatchModel.EngineRestart = core.StringPtr("force")
				prestissimoEnginePatchModel.RemoveEngineProperties = removeEnginePropertiesModel
				prestissimoEnginePatchModel.Tags = []string{"tag1", "tag2"}
				prestissimoEnginePatchModelAsPatch, asPatchErr := prestissimoEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdatePrestissimoEngineOptions model
				updatePrestissimoEngineOptionsModel := new(watsonxdatav2.UpdatePrestissimoEngineOptions)
				updatePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				updatePrestissimoEngineOptionsModel.Body = prestissimoEnginePatchModelAsPatch
				updatePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updatePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdatePrestissimoEngineWithContext(ctx, updatePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdatePrestissimoEngine(updatePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdatePrestissimoEngineWithContext(ctx, updatePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updatePrestissimoEnginePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "prestissimo engine for running sql queries", "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications"}, "instance_id": "instance_id", "managed_by": "fully/self", "metastore_host": "1.2.3.4", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "velox": {"velox_property": ["VeloxProperty"]}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "xyz-prestissimo-01-prestissimo-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"]}, "velox": ["Velox"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "prestissimo", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke UpdatePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdatePrestissimoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the PrestissimoEnginePropertiesCatalog model
				prestissimoEnginePropertiesCatalogModel := new(watsonxdatav2.PrestissimoEnginePropertiesCatalog)
				prestissimoEnginePropertiesCatalogModel.CatalogName = []string{"testString"}

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EnginePropertiesOaiGenConfiguration model
				enginePropertiesOaiGenConfigurationModel := new(watsonxdatav2.EnginePropertiesOaiGenConfiguration)
				enginePropertiesOaiGenConfigurationModel.Coordinator = prestissimoNodeDescriptionBodyModel
				enginePropertiesOaiGenConfigurationModel.Worker = prestissimoNodeDescriptionBodyModel

				// Construct an instance of the PrestissimoEnginePropertiesVelox model
				prestissimoEnginePropertiesVeloxModel := new(watsonxdatav2.PrestissimoEnginePropertiesVelox)
				prestissimoEnginePropertiesVeloxModel.VeloxProperty = []string{"testString"}

				// Construct an instance of the PrestissimoEnginePropertiesGlobal model
				prestissimoEnginePropertiesGlobalModel := new(watsonxdatav2.PrestissimoEnginePropertiesGlobal)
				prestissimoEnginePropertiesGlobalModel.GlobalProperty = core.StringPtr("enable-mixed-case-support:true")

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the PrestissimoEnginePropertiesOaiGen1Jvm model
				prestissimoEnginePropertiesOaiGen1JvmModel := new(watsonxdatav2.PrestissimoEnginePropertiesOaiGen1Jvm)
				prestissimoEnginePropertiesOaiGen1JvmModel.Coordinator = nodeDescriptionBodyModel

				// Construct an instance of the PrestissimoEngineEngineProperties model
				prestissimoEngineEnginePropertiesModel := new(watsonxdatav2.PrestissimoEngineEngineProperties)
				prestissimoEngineEnginePropertiesModel.Catalog = prestissimoEnginePropertiesCatalogModel
				prestissimoEngineEnginePropertiesModel.Configuration = enginePropertiesOaiGenConfigurationModel
				prestissimoEngineEnginePropertiesModel.Velox = prestissimoEnginePropertiesVeloxModel
				prestissimoEngineEnginePropertiesModel.Global = prestissimoEnginePropertiesGlobalModel
				prestissimoEngineEnginePropertiesModel.Jvm = prestissimoEnginePropertiesOaiGen1JvmModel

				// Construct an instance of the RemoveEnginePropertiesConfiguration model
				removeEnginePropertiesConfigurationModel := new(watsonxdatav2.RemoveEnginePropertiesConfiguration)
				removeEnginePropertiesConfigurationModel.Coordinator = []string{"testString"}
				removeEnginePropertiesConfigurationModel.Worker = []string{"testString"}

				// Construct an instance of the RemoveEnginePropertiesPrestissimoOaiGenJvm model
				removeEnginePropertiesPrestissimoOaiGenJvmModel := new(watsonxdatav2.RemoveEnginePropertiesPrestissimoOaiGenJvm)
				removeEnginePropertiesPrestissimoOaiGenJvmModel.Coordinator = []string{"testString"}

				// Construct an instance of the RemoveEngineProperties model
				removeEnginePropertiesModel := new(watsonxdatav2.RemoveEngineProperties)
				removeEnginePropertiesModel.Catalog = prestissimoEnginePropertiesCatalogModel
				removeEnginePropertiesModel.Configuration = removeEnginePropertiesConfigurationModel
				removeEnginePropertiesModel.Jvm = removeEnginePropertiesPrestissimoOaiGenJvmModel
				removeEnginePropertiesModel.Velox = []string{"testString"}

				// Construct an instance of the PrestissimoEnginePatch model
				prestissimoEnginePatchModel := new(watsonxdatav2.PrestissimoEnginePatch)
				prestissimoEnginePatchModel.Description = core.StringPtr("updated description for prestissimo engine")
				prestissimoEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				prestissimoEnginePatchModel.EngineProperties = prestissimoEngineEnginePropertiesModel
				prestissimoEnginePatchModel.EngineRestart = core.StringPtr("force")
				prestissimoEnginePatchModel.RemoveEngineProperties = removeEnginePropertiesModel
				prestissimoEnginePatchModel.Tags = []string{"tag1", "tag2"}
				prestissimoEnginePatchModelAsPatch, asPatchErr := prestissimoEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdatePrestissimoEngineOptions model
				updatePrestissimoEngineOptionsModel := new(watsonxdatav2.UpdatePrestissimoEngineOptions)
				updatePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				updatePrestissimoEngineOptionsModel.Body = prestissimoEnginePatchModelAsPatch
				updatePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updatePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdatePrestissimoEngine(updatePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdatePrestissimoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestissimoEnginePropertiesCatalog model
				prestissimoEnginePropertiesCatalogModel := new(watsonxdatav2.PrestissimoEnginePropertiesCatalog)
				prestissimoEnginePropertiesCatalogModel.CatalogName = []string{"testString"}

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EnginePropertiesOaiGenConfiguration model
				enginePropertiesOaiGenConfigurationModel := new(watsonxdatav2.EnginePropertiesOaiGenConfiguration)
				enginePropertiesOaiGenConfigurationModel.Coordinator = prestissimoNodeDescriptionBodyModel
				enginePropertiesOaiGenConfigurationModel.Worker = prestissimoNodeDescriptionBodyModel

				// Construct an instance of the PrestissimoEnginePropertiesVelox model
				prestissimoEnginePropertiesVeloxModel := new(watsonxdatav2.PrestissimoEnginePropertiesVelox)
				prestissimoEnginePropertiesVeloxModel.VeloxProperty = []string{"testString"}

				// Construct an instance of the PrestissimoEnginePropertiesGlobal model
				prestissimoEnginePropertiesGlobalModel := new(watsonxdatav2.PrestissimoEnginePropertiesGlobal)
				prestissimoEnginePropertiesGlobalModel.GlobalProperty = core.StringPtr("enable-mixed-case-support:true")

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the PrestissimoEnginePropertiesOaiGen1Jvm model
				prestissimoEnginePropertiesOaiGen1JvmModel := new(watsonxdatav2.PrestissimoEnginePropertiesOaiGen1Jvm)
				prestissimoEnginePropertiesOaiGen1JvmModel.Coordinator = nodeDescriptionBodyModel

				// Construct an instance of the PrestissimoEngineEngineProperties model
				prestissimoEngineEnginePropertiesModel := new(watsonxdatav2.PrestissimoEngineEngineProperties)
				prestissimoEngineEnginePropertiesModel.Catalog = prestissimoEnginePropertiesCatalogModel
				prestissimoEngineEnginePropertiesModel.Configuration = enginePropertiesOaiGenConfigurationModel
				prestissimoEngineEnginePropertiesModel.Velox = prestissimoEnginePropertiesVeloxModel
				prestissimoEngineEnginePropertiesModel.Global = prestissimoEnginePropertiesGlobalModel
				prestissimoEngineEnginePropertiesModel.Jvm = prestissimoEnginePropertiesOaiGen1JvmModel

				// Construct an instance of the RemoveEnginePropertiesConfiguration model
				removeEnginePropertiesConfigurationModel := new(watsonxdatav2.RemoveEnginePropertiesConfiguration)
				removeEnginePropertiesConfigurationModel.Coordinator = []string{"testString"}
				removeEnginePropertiesConfigurationModel.Worker = []string{"testString"}

				// Construct an instance of the RemoveEnginePropertiesPrestissimoOaiGenJvm model
				removeEnginePropertiesPrestissimoOaiGenJvmModel := new(watsonxdatav2.RemoveEnginePropertiesPrestissimoOaiGenJvm)
				removeEnginePropertiesPrestissimoOaiGenJvmModel.Coordinator = []string{"testString"}

				// Construct an instance of the RemoveEngineProperties model
				removeEnginePropertiesModel := new(watsonxdatav2.RemoveEngineProperties)
				removeEnginePropertiesModel.Catalog = prestissimoEnginePropertiesCatalogModel
				removeEnginePropertiesModel.Configuration = removeEnginePropertiesConfigurationModel
				removeEnginePropertiesModel.Jvm = removeEnginePropertiesPrestissimoOaiGenJvmModel
				removeEnginePropertiesModel.Velox = []string{"testString"}

				// Construct an instance of the PrestissimoEnginePatch model
				prestissimoEnginePatchModel := new(watsonxdatav2.PrestissimoEnginePatch)
				prestissimoEnginePatchModel.Description = core.StringPtr("updated description for prestissimo engine")
				prestissimoEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				prestissimoEnginePatchModel.EngineProperties = prestissimoEngineEnginePropertiesModel
				prestissimoEnginePatchModel.EngineRestart = core.StringPtr("force")
				prestissimoEnginePatchModel.RemoveEngineProperties = removeEnginePropertiesModel
				prestissimoEnginePatchModel.Tags = []string{"tag1", "tag2"}
				prestissimoEnginePatchModelAsPatch, asPatchErr := prestissimoEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdatePrestissimoEngineOptions model
				updatePrestissimoEngineOptionsModel := new(watsonxdatav2.UpdatePrestissimoEngineOptions)
				updatePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				updatePrestissimoEngineOptionsModel.Body = prestissimoEnginePatchModelAsPatch
				updatePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updatePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdatePrestissimoEngine(updatePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdatePrestissimoEngineOptions model with no property values
				updatePrestissimoEngineOptionsModelNew := new(watsonxdatav2.UpdatePrestissimoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdatePrestissimoEngine(updatePrestissimoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdatePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestissimoEnginePropertiesCatalog model
				prestissimoEnginePropertiesCatalogModel := new(watsonxdatav2.PrestissimoEnginePropertiesCatalog)
				prestissimoEnginePropertiesCatalogModel.CatalogName = []string{"testString"}

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EnginePropertiesOaiGenConfiguration model
				enginePropertiesOaiGenConfigurationModel := new(watsonxdatav2.EnginePropertiesOaiGenConfiguration)
				enginePropertiesOaiGenConfigurationModel.Coordinator = prestissimoNodeDescriptionBodyModel
				enginePropertiesOaiGenConfigurationModel.Worker = prestissimoNodeDescriptionBodyModel

				// Construct an instance of the PrestissimoEnginePropertiesVelox model
				prestissimoEnginePropertiesVeloxModel := new(watsonxdatav2.PrestissimoEnginePropertiesVelox)
				prestissimoEnginePropertiesVeloxModel.VeloxProperty = []string{"testString"}

				// Construct an instance of the PrestissimoEnginePropertiesGlobal model
				prestissimoEnginePropertiesGlobalModel := new(watsonxdatav2.PrestissimoEnginePropertiesGlobal)
				prestissimoEnginePropertiesGlobalModel.GlobalProperty = core.StringPtr("enable-mixed-case-support:true")

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the PrestissimoEnginePropertiesOaiGen1Jvm model
				prestissimoEnginePropertiesOaiGen1JvmModel := new(watsonxdatav2.PrestissimoEnginePropertiesOaiGen1Jvm)
				prestissimoEnginePropertiesOaiGen1JvmModel.Coordinator = nodeDescriptionBodyModel

				// Construct an instance of the PrestissimoEngineEngineProperties model
				prestissimoEngineEnginePropertiesModel := new(watsonxdatav2.PrestissimoEngineEngineProperties)
				prestissimoEngineEnginePropertiesModel.Catalog = prestissimoEnginePropertiesCatalogModel
				prestissimoEngineEnginePropertiesModel.Configuration = enginePropertiesOaiGenConfigurationModel
				prestissimoEngineEnginePropertiesModel.Velox = prestissimoEnginePropertiesVeloxModel
				prestissimoEngineEnginePropertiesModel.Global = prestissimoEnginePropertiesGlobalModel
				prestissimoEngineEnginePropertiesModel.Jvm = prestissimoEnginePropertiesOaiGen1JvmModel

				// Construct an instance of the RemoveEnginePropertiesConfiguration model
				removeEnginePropertiesConfigurationModel := new(watsonxdatav2.RemoveEnginePropertiesConfiguration)
				removeEnginePropertiesConfigurationModel.Coordinator = []string{"testString"}
				removeEnginePropertiesConfigurationModel.Worker = []string{"testString"}

				// Construct an instance of the RemoveEnginePropertiesPrestissimoOaiGenJvm model
				removeEnginePropertiesPrestissimoOaiGenJvmModel := new(watsonxdatav2.RemoveEnginePropertiesPrestissimoOaiGenJvm)
				removeEnginePropertiesPrestissimoOaiGenJvmModel.Coordinator = []string{"testString"}

				// Construct an instance of the RemoveEngineProperties model
				removeEnginePropertiesModel := new(watsonxdatav2.RemoveEngineProperties)
				removeEnginePropertiesModel.Catalog = prestissimoEnginePropertiesCatalogModel
				removeEnginePropertiesModel.Configuration = removeEnginePropertiesConfigurationModel
				removeEnginePropertiesModel.Jvm = removeEnginePropertiesPrestissimoOaiGenJvmModel
				removeEnginePropertiesModel.Velox = []string{"testString"}

				// Construct an instance of the PrestissimoEnginePatch model
				prestissimoEnginePatchModel := new(watsonxdatav2.PrestissimoEnginePatch)
				prestissimoEnginePatchModel.Description = core.StringPtr("updated description for prestissimo engine")
				prestissimoEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				prestissimoEnginePatchModel.EngineProperties = prestissimoEngineEnginePropertiesModel
				prestissimoEnginePatchModel.EngineRestart = core.StringPtr("force")
				prestissimoEnginePatchModel.RemoveEngineProperties = removeEnginePropertiesModel
				prestissimoEnginePatchModel.Tags = []string{"tag1", "tag2"}
				prestissimoEnginePatchModelAsPatch, asPatchErr := prestissimoEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdatePrestissimoEngineOptions model
				updatePrestissimoEngineOptionsModel := new(watsonxdatav2.UpdatePrestissimoEngineOptions)
				updatePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				updatePrestissimoEngineOptionsModel.Body = prestissimoEnginePatchModelAsPatch
				updatePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updatePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdatePrestissimoEngine(updatePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListPrestissimoEngineCatalogs(listPrestissimoEngineCatalogsOptions *ListPrestissimoEngineCatalogsOptions) - Operation response error`, func() {
		listPrestissimoEngineCatalogsPath := "/prestissimo_engines/testString/catalogs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestissimoEngineCatalogsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListPrestissimoEngineCatalogs with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestissimoEngineCatalogsOptions model
				listPrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.ListPrestissimoEngineCatalogsOptions)
				listPrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listPrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListPrestissimoEngineCatalogs(listPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListPrestissimoEngineCatalogs(listPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListPrestissimoEngineCatalogs(listPrestissimoEngineCatalogsOptions *ListPrestissimoEngineCatalogsOptions)`, func() {
		listPrestissimoEngineCatalogsPath := "/prestissimo_engines/testString/catalogs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestissimoEngineCatalogsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke ListPrestissimoEngineCatalogs successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListPrestissimoEngineCatalogsOptions model
				listPrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.ListPrestissimoEngineCatalogsOptions)
				listPrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listPrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListPrestissimoEngineCatalogsWithContext(ctx, listPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListPrestissimoEngineCatalogs(listPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListPrestissimoEngineCatalogsWithContext(ctx, listPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestissimoEngineCatalogsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke ListPrestissimoEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListPrestissimoEngineCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListPrestissimoEngineCatalogsOptions model
				listPrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.ListPrestissimoEngineCatalogsOptions)
				listPrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listPrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListPrestissimoEngineCatalogs(listPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListPrestissimoEngineCatalogs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestissimoEngineCatalogsOptions model
				listPrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.ListPrestissimoEngineCatalogsOptions)
				listPrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listPrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListPrestissimoEngineCatalogs(listPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListPrestissimoEngineCatalogsOptions model with no property values
				listPrestissimoEngineCatalogsOptionsModelNew := new(watsonxdatav2.ListPrestissimoEngineCatalogsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListPrestissimoEngineCatalogs(listPrestissimoEngineCatalogsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListPrestissimoEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestissimoEngineCatalogsOptions model
				listPrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.ListPrestissimoEngineCatalogsOptions)
				listPrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listPrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListPrestissimoEngineCatalogs(listPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreatePrestissimoEngineCatalogs(createPrestissimoEngineCatalogsOptions *CreatePrestissimoEngineCatalogsOptions) - Operation response error`, func() {
		createPrestissimoEngineCatalogsPath := "/prestissimo_engines/testString/catalogs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPrestissimoEngineCatalogsPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreatePrestissimoEngineCatalogs with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreatePrestissimoEngineCatalogsOptions model
				createPrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.CreatePrestissimoEngineCatalogsOptions)
				createPrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				createPrestissimoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				createPrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreatePrestissimoEngineCatalogs(createPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreatePrestissimoEngineCatalogs(createPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreatePrestissimoEngineCatalogs(createPrestissimoEngineCatalogsOptions *CreatePrestissimoEngineCatalogsOptions)`, func() {
		createPrestissimoEngineCatalogsPath := "/prestissimo_engines/testString/catalogs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPrestissimoEngineCatalogsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke CreatePrestissimoEngineCatalogs successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreatePrestissimoEngineCatalogsOptions model
				createPrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.CreatePrestissimoEngineCatalogsOptions)
				createPrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				createPrestissimoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				createPrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreatePrestissimoEngineCatalogsWithContext(ctx, createPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreatePrestissimoEngineCatalogs(createPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreatePrestissimoEngineCatalogsWithContext(ctx, createPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPrestissimoEngineCatalogsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke CreatePrestissimoEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreatePrestissimoEngineCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreatePrestissimoEngineCatalogsOptions model
				createPrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.CreatePrestissimoEngineCatalogsOptions)
				createPrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				createPrestissimoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				createPrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreatePrestissimoEngineCatalogs(createPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreatePrestissimoEngineCatalogs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreatePrestissimoEngineCatalogsOptions model
				createPrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.CreatePrestissimoEngineCatalogsOptions)
				createPrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				createPrestissimoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				createPrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreatePrestissimoEngineCatalogs(createPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreatePrestissimoEngineCatalogsOptions model with no property values
				createPrestissimoEngineCatalogsOptionsModelNew := new(watsonxdatav2.CreatePrestissimoEngineCatalogsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreatePrestissimoEngineCatalogs(createPrestissimoEngineCatalogsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreatePrestissimoEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreatePrestissimoEngineCatalogsOptions model
				createPrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.CreatePrestissimoEngineCatalogsOptions)
				createPrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				createPrestissimoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				createPrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreatePrestissimoEngineCatalogs(createPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeletePrestissimoEngineCatalogs(deletePrestissimoEngineCatalogsOptions *DeletePrestissimoEngineCatalogsOptions)`, func() {
		deletePrestissimoEngineCatalogsPath := "/prestissimo_engines/testString/catalogs"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deletePrestissimoEngineCatalogsPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["catalog_names"]).To(Equal([]string{"testString"}))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeletePrestissimoEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeletePrestissimoEngineCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeletePrestissimoEngineCatalogsOptions model
				deletePrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.DeletePrestissimoEngineCatalogsOptions)
				deletePrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				deletePrestissimoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				deletePrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deletePrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeletePrestissimoEngineCatalogs(deletePrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeletePrestissimoEngineCatalogs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeletePrestissimoEngineCatalogsOptions model
				deletePrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.DeletePrestissimoEngineCatalogsOptions)
				deletePrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				deletePrestissimoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				deletePrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deletePrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeletePrestissimoEngineCatalogs(deletePrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeletePrestissimoEngineCatalogsOptions model with no property values
				deletePrestissimoEngineCatalogsOptionsModelNew := new(watsonxdatav2.DeletePrestissimoEngineCatalogsOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeletePrestissimoEngineCatalogs(deletePrestissimoEngineCatalogsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPrestissimoEngineCatalog(getPrestissimoEngineCatalogOptions *GetPrestissimoEngineCatalogOptions) - Operation response error`, func() {
		getPrestissimoEngineCatalogPath := "/prestissimo_engines/testString/catalogs/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestissimoEngineCatalogPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetPrestissimoEngineCatalog with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestissimoEngineCatalogOptions model
				getPrestissimoEngineCatalogOptionsModel := new(watsonxdatav2.GetPrestissimoEngineCatalogOptions)
				getPrestissimoEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetPrestissimoEngineCatalog(getPrestissimoEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetPrestissimoEngineCatalog(getPrestissimoEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPrestissimoEngineCatalog(getPrestissimoEngineCatalogOptions *GetPrestissimoEngineCatalogOptions)`, func() {
		getPrestissimoEngineCatalogPath := "/prestissimo_engines/testString/catalogs/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestissimoEngineCatalogPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke GetPrestissimoEngineCatalog successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetPrestissimoEngineCatalogOptions model
				getPrestissimoEngineCatalogOptionsModel := new(watsonxdatav2.GetPrestissimoEngineCatalogOptions)
				getPrestissimoEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetPrestissimoEngineCatalogWithContext(ctx, getPrestissimoEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetPrestissimoEngineCatalog(getPrestissimoEngineCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetPrestissimoEngineCatalogWithContext(ctx, getPrestissimoEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestissimoEngineCatalogPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke GetPrestissimoEngineCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetPrestissimoEngineCatalog(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetPrestissimoEngineCatalogOptions model
				getPrestissimoEngineCatalogOptionsModel := new(watsonxdatav2.GetPrestissimoEngineCatalogOptions)
				getPrestissimoEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetPrestissimoEngineCatalog(getPrestissimoEngineCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetPrestissimoEngineCatalog with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestissimoEngineCatalogOptions model
				getPrestissimoEngineCatalogOptionsModel := new(watsonxdatav2.GetPrestissimoEngineCatalogOptions)
				getPrestissimoEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetPrestissimoEngineCatalog(getPrestissimoEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetPrestissimoEngineCatalogOptions model with no property values
				getPrestissimoEngineCatalogOptionsModelNew := new(watsonxdatav2.GetPrestissimoEngineCatalogOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetPrestissimoEngineCatalog(getPrestissimoEngineCatalogOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetPrestissimoEngineCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestissimoEngineCatalogOptions model
				getPrestissimoEngineCatalogOptionsModel := new(watsonxdatav2.GetPrestissimoEngineCatalogOptions)
				getPrestissimoEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetPrestissimoEngineCatalog(getPrestissimoEngineCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PausePrestissimoEngine(pausePrestissimoEngineOptions *PausePrestissimoEngineOptions) - Operation response error`, func() {
		pausePrestissimoEnginePath := "/prestissimo_engines/testString/pause"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(pausePrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke PausePrestissimoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PausePrestissimoEngineOptions model
				pausePrestissimoEngineOptionsModel := new(watsonxdatav2.PausePrestissimoEngineOptions)
				pausePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				pausePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pausePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.PausePrestissimoEngine(pausePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.PausePrestissimoEngine(pausePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PausePrestissimoEngine(pausePrestissimoEngineOptions *PausePrestissimoEngineOptions)`, func() {
		pausePrestissimoEnginePath := "/prestissimo_engines/testString/pause"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(pausePrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke PausePrestissimoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the PausePrestissimoEngineOptions model
				pausePrestissimoEngineOptionsModel := new(watsonxdatav2.PausePrestissimoEngineOptions)
				pausePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				pausePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pausePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.PausePrestissimoEngineWithContext(ctx, pausePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.PausePrestissimoEngine(pausePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.PausePrestissimoEngineWithContext(ctx, pausePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(pausePrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke PausePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.PausePrestissimoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the PausePrestissimoEngineOptions model
				pausePrestissimoEngineOptionsModel := new(watsonxdatav2.PausePrestissimoEngineOptions)
				pausePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				pausePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pausePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.PausePrestissimoEngine(pausePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke PausePrestissimoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PausePrestissimoEngineOptions model
				pausePrestissimoEngineOptionsModel := new(watsonxdatav2.PausePrestissimoEngineOptions)
				pausePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				pausePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pausePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.PausePrestissimoEngine(pausePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the PausePrestissimoEngineOptions model with no property values
				pausePrestissimoEngineOptionsModelNew := new(watsonxdatav2.PausePrestissimoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.PausePrestissimoEngine(pausePrestissimoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke PausePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PausePrestissimoEngineOptions model
				pausePrestissimoEngineOptionsModel := new(watsonxdatav2.PausePrestissimoEngineOptions)
				pausePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				pausePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pausePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.PausePrestissimoEngine(pausePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RunPrestissimoExplainStatement(runPrestissimoExplainStatementOptions *RunPrestissimoExplainStatementOptions) - Operation response error`, func() {
		runPrestissimoExplainStatementPath := "/prestissimo_engines/testString/query_explain"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runPrestissimoExplainStatementPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke RunPrestissimoExplainStatement with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunPrestissimoExplainStatementOptions model
				runPrestissimoExplainStatementOptionsModel := new(watsonxdatav2.RunPrestissimoExplainStatementOptions)
				runPrestissimoExplainStatementOptionsModel.EngineID = core.StringPtr("testString")
				runPrestissimoExplainStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runPrestissimoExplainStatementOptionsModel.Format = core.StringPtr("json")
				runPrestissimoExplainStatementOptionsModel.Type = core.StringPtr("io")
				runPrestissimoExplainStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runPrestissimoExplainStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.RunPrestissimoExplainStatement(runPrestissimoExplainStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.RunPrestissimoExplainStatement(runPrestissimoExplainStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RunPrestissimoExplainStatement(runPrestissimoExplainStatementOptions *RunPrestissimoExplainStatementOptions)`, func() {
		runPrestissimoExplainStatementPath := "/prestissimo_engines/testString/query_explain"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runPrestissimoExplainStatementPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"result": "Result"}`)
				}))
			})
			It(`Invoke RunPrestissimoExplainStatement successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the RunPrestissimoExplainStatementOptions model
				runPrestissimoExplainStatementOptionsModel := new(watsonxdatav2.RunPrestissimoExplainStatementOptions)
				runPrestissimoExplainStatementOptionsModel.EngineID = core.StringPtr("testString")
				runPrestissimoExplainStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runPrestissimoExplainStatementOptionsModel.Format = core.StringPtr("json")
				runPrestissimoExplainStatementOptionsModel.Type = core.StringPtr("io")
				runPrestissimoExplainStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runPrestissimoExplainStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.RunPrestissimoExplainStatementWithContext(ctx, runPrestissimoExplainStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.RunPrestissimoExplainStatement(runPrestissimoExplainStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.RunPrestissimoExplainStatementWithContext(ctx, runPrestissimoExplainStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runPrestissimoExplainStatementPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"result": "Result"}`)
				}))
			})
			It(`Invoke RunPrestissimoExplainStatement successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.RunPrestissimoExplainStatement(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the RunPrestissimoExplainStatementOptions model
				runPrestissimoExplainStatementOptionsModel := new(watsonxdatav2.RunPrestissimoExplainStatementOptions)
				runPrestissimoExplainStatementOptionsModel.EngineID = core.StringPtr("testString")
				runPrestissimoExplainStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runPrestissimoExplainStatementOptionsModel.Format = core.StringPtr("json")
				runPrestissimoExplainStatementOptionsModel.Type = core.StringPtr("io")
				runPrestissimoExplainStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runPrestissimoExplainStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.RunPrestissimoExplainStatement(runPrestissimoExplainStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke RunPrestissimoExplainStatement with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunPrestissimoExplainStatementOptions model
				runPrestissimoExplainStatementOptionsModel := new(watsonxdatav2.RunPrestissimoExplainStatementOptions)
				runPrestissimoExplainStatementOptionsModel.EngineID = core.StringPtr("testString")
				runPrestissimoExplainStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runPrestissimoExplainStatementOptionsModel.Format = core.StringPtr("json")
				runPrestissimoExplainStatementOptionsModel.Type = core.StringPtr("io")
				runPrestissimoExplainStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runPrestissimoExplainStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.RunPrestissimoExplainStatement(runPrestissimoExplainStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the RunPrestissimoExplainStatementOptions model with no property values
				runPrestissimoExplainStatementOptionsModelNew := new(watsonxdatav2.RunPrestissimoExplainStatementOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.RunPrestissimoExplainStatement(runPrestissimoExplainStatementOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke RunPrestissimoExplainStatement successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunPrestissimoExplainStatementOptions model
				runPrestissimoExplainStatementOptionsModel := new(watsonxdatav2.RunPrestissimoExplainStatementOptions)
				runPrestissimoExplainStatementOptionsModel.EngineID = core.StringPtr("testString")
				runPrestissimoExplainStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runPrestissimoExplainStatementOptionsModel.Format = core.StringPtr("json")
				runPrestissimoExplainStatementOptionsModel.Type = core.StringPtr("io")
				runPrestissimoExplainStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runPrestissimoExplainStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.RunPrestissimoExplainStatement(runPrestissimoExplainStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RunPrestissimoExplainAnalyzeStatement(runPrestissimoExplainAnalyzeStatementOptions *RunPrestissimoExplainAnalyzeStatementOptions) - Operation response error`, func() {
		runPrestissimoExplainAnalyzeStatementPath := "/prestissimo_engines/testString/query_explain_analyze"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runPrestissimoExplainAnalyzeStatementPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke RunPrestissimoExplainAnalyzeStatement with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunPrestissimoExplainAnalyzeStatementOptions model
				runPrestissimoExplainAnalyzeStatementOptionsModel := new(watsonxdatav2.RunPrestissimoExplainAnalyzeStatementOptions)
				runPrestissimoExplainAnalyzeStatementOptionsModel.EngineID = core.StringPtr("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Verbose = core.BoolPtr(true)
				runPrestissimoExplainAnalyzeStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.RunPrestissimoExplainAnalyzeStatement(runPrestissimoExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.RunPrestissimoExplainAnalyzeStatement(runPrestissimoExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RunPrestissimoExplainAnalyzeStatement(runPrestissimoExplainAnalyzeStatementOptions *RunPrestissimoExplainAnalyzeStatementOptions)`, func() {
		runPrestissimoExplainAnalyzeStatementPath := "/prestissimo_engines/testString/query_explain_analyze"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runPrestissimoExplainAnalyzeStatementPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"result": "Result"}`)
				}))
			})
			It(`Invoke RunPrestissimoExplainAnalyzeStatement successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the RunPrestissimoExplainAnalyzeStatementOptions model
				runPrestissimoExplainAnalyzeStatementOptionsModel := new(watsonxdatav2.RunPrestissimoExplainAnalyzeStatementOptions)
				runPrestissimoExplainAnalyzeStatementOptionsModel.EngineID = core.StringPtr("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Verbose = core.BoolPtr(true)
				runPrestissimoExplainAnalyzeStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.RunPrestissimoExplainAnalyzeStatementWithContext(ctx, runPrestissimoExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.RunPrestissimoExplainAnalyzeStatement(runPrestissimoExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.RunPrestissimoExplainAnalyzeStatementWithContext(ctx, runPrestissimoExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runPrestissimoExplainAnalyzeStatementPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"result": "Result"}`)
				}))
			})
			It(`Invoke RunPrestissimoExplainAnalyzeStatement successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.RunPrestissimoExplainAnalyzeStatement(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the RunPrestissimoExplainAnalyzeStatementOptions model
				runPrestissimoExplainAnalyzeStatementOptionsModel := new(watsonxdatav2.RunPrestissimoExplainAnalyzeStatementOptions)
				runPrestissimoExplainAnalyzeStatementOptionsModel.EngineID = core.StringPtr("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Verbose = core.BoolPtr(true)
				runPrestissimoExplainAnalyzeStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.RunPrestissimoExplainAnalyzeStatement(runPrestissimoExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke RunPrestissimoExplainAnalyzeStatement with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunPrestissimoExplainAnalyzeStatementOptions model
				runPrestissimoExplainAnalyzeStatementOptionsModel := new(watsonxdatav2.RunPrestissimoExplainAnalyzeStatementOptions)
				runPrestissimoExplainAnalyzeStatementOptionsModel.EngineID = core.StringPtr("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Verbose = core.BoolPtr(true)
				runPrestissimoExplainAnalyzeStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.RunPrestissimoExplainAnalyzeStatement(runPrestissimoExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the RunPrestissimoExplainAnalyzeStatementOptions model with no property values
				runPrestissimoExplainAnalyzeStatementOptionsModelNew := new(watsonxdatav2.RunPrestissimoExplainAnalyzeStatementOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.RunPrestissimoExplainAnalyzeStatement(runPrestissimoExplainAnalyzeStatementOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke RunPrestissimoExplainAnalyzeStatement successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunPrestissimoExplainAnalyzeStatementOptions model
				runPrestissimoExplainAnalyzeStatementOptionsModel := new(watsonxdatav2.RunPrestissimoExplainAnalyzeStatementOptions)
				runPrestissimoExplainAnalyzeStatementOptionsModel.EngineID = core.StringPtr("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Verbose = core.BoolPtr(true)
				runPrestissimoExplainAnalyzeStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.RunPrestissimoExplainAnalyzeStatement(runPrestissimoExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RestartPrestissimoEngine(restartPrestissimoEngineOptions *RestartPrestissimoEngineOptions) - Operation response error`, func() {
		restartPrestissimoEnginePath := "/prestissimo_engines/testString/restart"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(restartPrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke RestartPrestissimoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RestartPrestissimoEngineOptions model
				restartPrestissimoEngineOptionsModel := new(watsonxdatav2.RestartPrestissimoEngineOptions)
				restartPrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				restartPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				restartPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.RestartPrestissimoEngine(restartPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.RestartPrestissimoEngine(restartPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RestartPrestissimoEngine(restartPrestissimoEngineOptions *RestartPrestissimoEngineOptions)`, func() {
		restartPrestissimoEnginePath := "/prestissimo_engines/testString/restart"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(restartPrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke RestartPrestissimoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the RestartPrestissimoEngineOptions model
				restartPrestissimoEngineOptionsModel := new(watsonxdatav2.RestartPrestissimoEngineOptions)
				restartPrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				restartPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				restartPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.RestartPrestissimoEngineWithContext(ctx, restartPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.RestartPrestissimoEngine(restartPrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.RestartPrestissimoEngineWithContext(ctx, restartPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(restartPrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke RestartPrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.RestartPrestissimoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the RestartPrestissimoEngineOptions model
				restartPrestissimoEngineOptionsModel := new(watsonxdatav2.RestartPrestissimoEngineOptions)
				restartPrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				restartPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				restartPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.RestartPrestissimoEngine(restartPrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke RestartPrestissimoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RestartPrestissimoEngineOptions model
				restartPrestissimoEngineOptionsModel := new(watsonxdatav2.RestartPrestissimoEngineOptions)
				restartPrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				restartPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				restartPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.RestartPrestissimoEngine(restartPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the RestartPrestissimoEngineOptions model with no property values
				restartPrestissimoEngineOptionsModelNew := new(watsonxdatav2.RestartPrestissimoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.RestartPrestissimoEngine(restartPrestissimoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke RestartPrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RestartPrestissimoEngineOptions model
				restartPrestissimoEngineOptionsModel := new(watsonxdatav2.RestartPrestissimoEngineOptions)
				restartPrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				restartPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				restartPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.RestartPrestissimoEngine(restartPrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ResumePrestissimoEngine(resumePrestissimoEngineOptions *ResumePrestissimoEngineOptions) - Operation response error`, func() {
		resumePrestissimoEnginePath := "/prestissimo_engines/testString/resume"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(resumePrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ResumePrestissimoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ResumePrestissimoEngineOptions model
				resumePrestissimoEngineOptionsModel := new(watsonxdatav2.ResumePrestissimoEngineOptions)
				resumePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ResumePrestissimoEngine(resumePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ResumePrestissimoEngine(resumePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ResumePrestissimoEngine(resumePrestissimoEngineOptions *ResumePrestissimoEngineOptions)`, func() {
		resumePrestissimoEnginePath := "/prestissimo_engines/testString/resume"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(resumePrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke ResumePrestissimoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ResumePrestissimoEngineOptions model
				resumePrestissimoEngineOptionsModel := new(watsonxdatav2.ResumePrestissimoEngineOptions)
				resumePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ResumePrestissimoEngineWithContext(ctx, resumePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ResumePrestissimoEngine(resumePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ResumePrestissimoEngineWithContext(ctx, resumePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(resumePrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke ResumePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ResumePrestissimoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ResumePrestissimoEngineOptions model
				resumePrestissimoEngineOptionsModel := new(watsonxdatav2.ResumePrestissimoEngineOptions)
				resumePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ResumePrestissimoEngine(resumePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ResumePrestissimoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ResumePrestissimoEngineOptions model
				resumePrestissimoEngineOptionsModel := new(watsonxdatav2.ResumePrestissimoEngineOptions)
				resumePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ResumePrestissimoEngine(resumePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ResumePrestissimoEngineOptions model with no property values
				resumePrestissimoEngineOptionsModelNew := new(watsonxdatav2.ResumePrestissimoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ResumePrestissimoEngine(resumePrestissimoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ResumePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ResumePrestissimoEngineOptions model
				resumePrestissimoEngineOptionsModel := new(watsonxdatav2.ResumePrestissimoEngineOptions)
				resumePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ResumePrestissimoEngine(resumePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ScalePrestissimoEngine(scalePrestissimoEngineOptions *ScalePrestissimoEngineOptions) - Operation response error`, func() {
		scalePrestissimoEnginePath := "/prestissimo_engines/testString/scale"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(scalePrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ScalePrestissimoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the ScalePrestissimoEngineOptions model
				scalePrestissimoEngineOptionsModel := new(watsonxdatav2.ScalePrestissimoEngineOptions)
				scalePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				scalePrestissimoEngineOptionsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				scalePrestissimoEngineOptionsModel.Worker = prestissimoNodeDescriptionBodyModel
				scalePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scalePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ScalePrestissimoEngine(scalePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ScalePrestissimoEngine(scalePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ScalePrestissimoEngine(scalePrestissimoEngineOptions *ScalePrestissimoEngineOptions)`, func() {
		scalePrestissimoEnginePath := "/prestissimo_engines/testString/scale"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(scalePrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke ScalePrestissimoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the ScalePrestissimoEngineOptions model
				scalePrestissimoEngineOptionsModel := new(watsonxdatav2.ScalePrestissimoEngineOptions)
				scalePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				scalePrestissimoEngineOptionsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				scalePrestissimoEngineOptionsModel.Worker = prestissimoNodeDescriptionBodyModel
				scalePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scalePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ScalePrestissimoEngineWithContext(ctx, scalePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ScalePrestissimoEngine(scalePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ScalePrestissimoEngineWithContext(ctx, scalePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(scalePrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke ScalePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ScalePrestissimoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the ScalePrestissimoEngineOptions model
				scalePrestissimoEngineOptionsModel := new(watsonxdatav2.ScalePrestissimoEngineOptions)
				scalePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				scalePrestissimoEngineOptionsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				scalePrestissimoEngineOptionsModel.Worker = prestissimoNodeDescriptionBodyModel
				scalePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scalePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ScalePrestissimoEngine(scalePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ScalePrestissimoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the ScalePrestissimoEngineOptions model
				scalePrestissimoEngineOptionsModel := new(watsonxdatav2.ScalePrestissimoEngineOptions)
				scalePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				scalePrestissimoEngineOptionsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				scalePrestissimoEngineOptionsModel.Worker = prestissimoNodeDescriptionBodyModel
				scalePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scalePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ScalePrestissimoEngine(scalePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ScalePrestissimoEngineOptions model with no property values
				scalePrestissimoEngineOptionsModelNew := new(watsonxdatav2.ScalePrestissimoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ScalePrestissimoEngine(scalePrestissimoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(202)
				}))
			})
			It(`Invoke ScalePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the ScalePrestissimoEngineOptions model
				scalePrestissimoEngineOptionsModel := new(watsonxdatav2.ScalePrestissimoEngineOptions)
				scalePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				scalePrestissimoEngineOptionsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				scalePrestissimoEngineOptionsModel.Worker = prestissimoNodeDescriptionBodyModel
				scalePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scalePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ScalePrestissimoEngine(scalePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListPrestoEngines(listPrestoEnginesOptions *ListPrestoEnginesOptions) - Operation response error`, func() {
		listPrestoEnginesPath := "/presto_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestoEnginesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListPrestoEngines with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestoEnginesOptions model
				listPrestoEnginesOptionsModel := new(watsonxdatav2.ListPrestoEnginesOptions)
				listPrestoEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestoEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListPrestoEngines(listPrestoEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListPrestoEngines(listPrestoEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListPrestoEngines(listPrestoEnginesOptions *ListPrestoEnginesOptions)`, func() {
		listPrestoEnginesPath := "/presto_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestoEnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"presto_engines": [{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "presto engine for running sql queries", "drivers": [{"connection_type": "saphana", "driver_id": "saphanadriver123", "driver_name": "saphanadriver-1.2.3", "driver_version": "1.2.3"}], "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "instance_id": "instance_id", "managed_by": "fully/self", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "event_listener": {"event_listener_property": "EventListenerProperty"}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "log_config": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "ibm-lh-lakehouse-presto-01-presto-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "event_listener": ["EventListener"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "presto", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}]}`)
				}))
			})
			It(`Invoke ListPrestoEngines successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListPrestoEnginesOptions model
				listPrestoEnginesOptionsModel := new(watsonxdatav2.ListPrestoEnginesOptions)
				listPrestoEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestoEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListPrestoEnginesWithContext(ctx, listPrestoEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListPrestoEngines(listPrestoEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListPrestoEnginesWithContext(ctx, listPrestoEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestoEnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"presto_engines": [{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "presto engine for running sql queries", "drivers": [{"connection_type": "saphana", "driver_id": "saphanadriver123", "driver_name": "saphanadriver-1.2.3", "driver_version": "1.2.3"}], "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "instance_id": "instance_id", "managed_by": "fully/self", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "event_listener": {"event_listener_property": "EventListenerProperty"}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "log_config": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "ibm-lh-lakehouse-presto-01-presto-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "event_listener": ["EventListener"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "presto", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}]}`)
				}))
			})
			It(`Invoke ListPrestoEngines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListPrestoEngines(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListPrestoEnginesOptions model
				listPrestoEnginesOptionsModel := new(watsonxdatav2.ListPrestoEnginesOptions)
				listPrestoEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestoEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListPrestoEngines(listPrestoEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListPrestoEngines with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestoEnginesOptions model
				listPrestoEnginesOptionsModel := new(watsonxdatav2.ListPrestoEnginesOptions)
				listPrestoEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestoEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListPrestoEngines(listPrestoEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListPrestoEngines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestoEnginesOptions model
				listPrestoEnginesOptionsModel := new(watsonxdatav2.ListPrestoEnginesOptions)
				listPrestoEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestoEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListPrestoEngines(listPrestoEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreatePrestoEngine(createPrestoEngineOptions *CreatePrestoEngineOptions) - Operation response error`, func() {
		createPrestoEnginePath := "/presto_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreatePrestoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EngineDetailsBody model
				engineDetailsBodyModel := new(watsonxdatav2.EngineDetailsBody)
				engineDetailsBodyModel.ApiKey = core.StringPtr("<api_key>")
				engineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				engineDetailsBodyModel.Coordinator = nodeDescriptionBodyModel
				engineDetailsBodyModel.InstanceID = core.StringPtr("instance_id")
				engineDetailsBodyModel.ManagedBy = core.StringPtr("fully/self")
				engineDetailsBodyModel.SizeConfig = core.StringPtr("starter")
				engineDetailsBodyModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the CreatePrestoEngineOptions model
				createPrestoEngineOptionsModel := new(watsonxdatav2.CreatePrestoEngineOptions)
				createPrestoEngineOptionsModel.Origin = core.StringPtr("native")
				createPrestoEngineOptionsModel.AssociatedCatalogs = []string{"iceberg_data", "hive_data"}
				createPrestoEngineOptionsModel.Description = core.StringPtr("presto engine for running sql queries")
				createPrestoEngineOptionsModel.EngineDetails = engineDetailsBodyModel
				createPrestoEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createPrestoEngineOptionsModel.Region = core.StringPtr("us-south")
				createPrestoEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createPrestoEngineOptionsModel.Version = core.StringPtr("1.2.3")
				createPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreatePrestoEngine(createPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreatePrestoEngine(createPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreatePrestoEngine(createPrestoEngineOptions *CreatePrestoEngineOptions)`, func() {
		createPrestoEnginePath := "/presto_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "presto engine for running sql queries", "drivers": [{"connection_type": "saphana", "driver_id": "saphanadriver123", "driver_name": "saphanadriver-1.2.3", "driver_version": "1.2.3"}], "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "instance_id": "instance_id", "managed_by": "fully/self", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "event_listener": {"event_listener_property": "EventListenerProperty"}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "log_config": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "ibm-lh-lakehouse-presto-01-presto-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "event_listener": ["EventListener"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "presto", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke CreatePrestoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EngineDetailsBody model
				engineDetailsBodyModel := new(watsonxdatav2.EngineDetailsBody)
				engineDetailsBodyModel.ApiKey = core.StringPtr("<api_key>")
				engineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				engineDetailsBodyModel.Coordinator = nodeDescriptionBodyModel
				engineDetailsBodyModel.InstanceID = core.StringPtr("instance_id")
				engineDetailsBodyModel.ManagedBy = core.StringPtr("fully/self")
				engineDetailsBodyModel.SizeConfig = core.StringPtr("starter")
				engineDetailsBodyModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the CreatePrestoEngineOptions model
				createPrestoEngineOptionsModel := new(watsonxdatav2.CreatePrestoEngineOptions)
				createPrestoEngineOptionsModel.Origin = core.StringPtr("native")
				createPrestoEngineOptionsModel.AssociatedCatalogs = []string{"iceberg_data", "hive_data"}
				createPrestoEngineOptionsModel.Description = core.StringPtr("presto engine for running sql queries")
				createPrestoEngineOptionsModel.EngineDetails = engineDetailsBodyModel
				createPrestoEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createPrestoEngineOptionsModel.Region = core.StringPtr("us-south")
				createPrestoEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createPrestoEngineOptionsModel.Version = core.StringPtr("1.2.3")
				createPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreatePrestoEngineWithContext(ctx, createPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreatePrestoEngine(createPrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreatePrestoEngineWithContext(ctx, createPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "presto engine for running sql queries", "drivers": [{"connection_type": "saphana", "driver_id": "saphanadriver123", "driver_name": "saphanadriver-1.2.3", "driver_version": "1.2.3"}], "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "instance_id": "instance_id", "managed_by": "fully/self", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "event_listener": {"event_listener_property": "EventListenerProperty"}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "log_config": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "ibm-lh-lakehouse-presto-01-presto-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "event_listener": ["EventListener"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "presto", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke CreatePrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreatePrestoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EngineDetailsBody model
				engineDetailsBodyModel := new(watsonxdatav2.EngineDetailsBody)
				engineDetailsBodyModel.ApiKey = core.StringPtr("<api_key>")
				engineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				engineDetailsBodyModel.Coordinator = nodeDescriptionBodyModel
				engineDetailsBodyModel.InstanceID = core.StringPtr("instance_id")
				engineDetailsBodyModel.ManagedBy = core.StringPtr("fully/self")
				engineDetailsBodyModel.SizeConfig = core.StringPtr("starter")
				engineDetailsBodyModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the CreatePrestoEngineOptions model
				createPrestoEngineOptionsModel := new(watsonxdatav2.CreatePrestoEngineOptions)
				createPrestoEngineOptionsModel.Origin = core.StringPtr("native")
				createPrestoEngineOptionsModel.AssociatedCatalogs = []string{"iceberg_data", "hive_data"}
				createPrestoEngineOptionsModel.Description = core.StringPtr("presto engine for running sql queries")
				createPrestoEngineOptionsModel.EngineDetails = engineDetailsBodyModel
				createPrestoEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createPrestoEngineOptionsModel.Region = core.StringPtr("us-south")
				createPrestoEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createPrestoEngineOptionsModel.Version = core.StringPtr("1.2.3")
				createPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreatePrestoEngine(createPrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreatePrestoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EngineDetailsBody model
				engineDetailsBodyModel := new(watsonxdatav2.EngineDetailsBody)
				engineDetailsBodyModel.ApiKey = core.StringPtr("<api_key>")
				engineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				engineDetailsBodyModel.Coordinator = nodeDescriptionBodyModel
				engineDetailsBodyModel.InstanceID = core.StringPtr("instance_id")
				engineDetailsBodyModel.ManagedBy = core.StringPtr("fully/self")
				engineDetailsBodyModel.SizeConfig = core.StringPtr("starter")
				engineDetailsBodyModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the CreatePrestoEngineOptions model
				createPrestoEngineOptionsModel := new(watsonxdatav2.CreatePrestoEngineOptions)
				createPrestoEngineOptionsModel.Origin = core.StringPtr("native")
				createPrestoEngineOptionsModel.AssociatedCatalogs = []string{"iceberg_data", "hive_data"}
				createPrestoEngineOptionsModel.Description = core.StringPtr("presto engine for running sql queries")
				createPrestoEngineOptionsModel.EngineDetails = engineDetailsBodyModel
				createPrestoEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createPrestoEngineOptionsModel.Region = core.StringPtr("us-south")
				createPrestoEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createPrestoEngineOptionsModel.Version = core.StringPtr("1.2.3")
				createPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreatePrestoEngine(createPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreatePrestoEngineOptions model with no property values
				createPrestoEngineOptionsModelNew := new(watsonxdatav2.CreatePrestoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreatePrestoEngine(createPrestoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreatePrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EngineDetailsBody model
				engineDetailsBodyModel := new(watsonxdatav2.EngineDetailsBody)
				engineDetailsBodyModel.ApiKey = core.StringPtr("<api_key>")
				engineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				engineDetailsBodyModel.Coordinator = nodeDescriptionBodyModel
				engineDetailsBodyModel.InstanceID = core.StringPtr("instance_id")
				engineDetailsBodyModel.ManagedBy = core.StringPtr("fully/self")
				engineDetailsBodyModel.SizeConfig = core.StringPtr("starter")
				engineDetailsBodyModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the CreatePrestoEngineOptions model
				createPrestoEngineOptionsModel := new(watsonxdatav2.CreatePrestoEngineOptions)
				createPrestoEngineOptionsModel.Origin = core.StringPtr("native")
				createPrestoEngineOptionsModel.AssociatedCatalogs = []string{"iceberg_data", "hive_data"}
				createPrestoEngineOptionsModel.Description = core.StringPtr("presto engine for running sql queries")
				createPrestoEngineOptionsModel.EngineDetails = engineDetailsBodyModel
				createPrestoEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createPrestoEngineOptionsModel.Region = core.StringPtr("us-south")
				createPrestoEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createPrestoEngineOptionsModel.Version = core.StringPtr("1.2.3")
				createPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreatePrestoEngine(createPrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPrestoEngine(getPrestoEngineOptions *GetPrestoEngineOptions) - Operation response error`, func() {
		getPrestoEnginePath := "/presto_engines/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestoEnginePath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetPrestoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestoEngineOptions model
				getPrestoEngineOptionsModel := new(watsonxdatav2.GetPrestoEngineOptions)
				getPrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				getPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetPrestoEngine(getPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetPrestoEngine(getPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPrestoEngine(getPrestoEngineOptions *GetPrestoEngineOptions)`, func() {
		getPrestoEnginePath := "/presto_engines/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestoEnginePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "presto engine for running sql queries", "drivers": [{"connection_type": "saphana", "driver_id": "saphanadriver123", "driver_name": "saphanadriver-1.2.3", "driver_version": "1.2.3"}], "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "instance_id": "instance_id", "managed_by": "fully/self", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "event_listener": {"event_listener_property": "EventListenerProperty"}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "log_config": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "ibm-lh-lakehouse-presto-01-presto-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "event_listener": ["EventListener"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "presto", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke GetPrestoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetPrestoEngineOptions model
				getPrestoEngineOptionsModel := new(watsonxdatav2.GetPrestoEngineOptions)
				getPrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				getPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetPrestoEngineWithContext(ctx, getPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetPrestoEngine(getPrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetPrestoEngineWithContext(ctx, getPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestoEnginePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "presto engine for running sql queries", "drivers": [{"connection_type": "saphana", "driver_id": "saphanadriver123", "driver_name": "saphanadriver-1.2.3", "driver_version": "1.2.3"}], "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "instance_id": "instance_id", "managed_by": "fully/self", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "event_listener": {"event_listener_property": "EventListenerProperty"}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "log_config": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "ibm-lh-lakehouse-presto-01-presto-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "event_listener": ["EventListener"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "presto", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke GetPrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetPrestoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetPrestoEngineOptions model
				getPrestoEngineOptionsModel := new(watsonxdatav2.GetPrestoEngineOptions)
				getPrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				getPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetPrestoEngine(getPrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetPrestoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestoEngineOptions model
				getPrestoEngineOptionsModel := new(watsonxdatav2.GetPrestoEngineOptions)
				getPrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				getPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetPrestoEngine(getPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetPrestoEngineOptions model with no property values
				getPrestoEngineOptionsModelNew := new(watsonxdatav2.GetPrestoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetPrestoEngine(getPrestoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetPrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestoEngineOptions model
				getPrestoEngineOptionsModel := new(watsonxdatav2.GetPrestoEngineOptions)
				getPrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				getPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetPrestoEngine(getPrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteEngine(deleteEngineOptions *DeleteEngineOptions)`, func() {
		deleteEnginePath := "/presto_engines/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteEnginePath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteEngineOptions model
				deleteEngineOptionsModel := new(watsonxdatav2.DeleteEngineOptions)
				deleteEngineOptionsModel.EngineID = core.StringPtr("testString")
				deleteEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteEngine(deleteEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteEngineOptions model
				deleteEngineOptionsModel := new(watsonxdatav2.DeleteEngineOptions)
				deleteEngineOptionsModel.EngineID = core.StringPtr("testString")
				deleteEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteEngine(deleteEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteEngineOptions model with no property values
				deleteEngineOptionsModelNew := new(watsonxdatav2.DeleteEngineOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteEngine(deleteEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdatePrestoEngine(updatePrestoEngineOptions *UpdatePrestoEngineOptions) - Operation response error`, func() {
		updatePrestoEnginePath := "/presto_engines/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updatePrestoEnginePath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdatePrestoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestoEnginePropertiesCatalog model
				prestoEnginePropertiesCatalogModel := new(watsonxdatav2.PrestoEnginePropertiesCatalog)
				prestoEnginePropertiesCatalogModel.CatalogName = core.StringPtr("testString")

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EnginePropertiesOaiGen1Configuration model
				enginePropertiesOaiGen1ConfigurationModel := new(watsonxdatav2.EnginePropertiesOaiGen1Configuration)
				enginePropertiesOaiGen1ConfigurationModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesOaiGen1ConfigurationModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the PrestoEnginePropertiesEventListener model
				prestoEnginePropertiesEventListenerModel := new(watsonxdatav2.PrestoEnginePropertiesEventListener)
				prestoEnginePropertiesEventListenerModel.EventListenerProperty = core.StringPtr("testString")

				// Construct an instance of the PrestoEnginePropertiesGlobal model
				prestoEnginePropertiesGlobalModel := new(watsonxdatav2.PrestoEnginePropertiesGlobal)
				prestoEnginePropertiesGlobalModel.GlobalProperty = core.StringPtr("enable-mixed-case-support:true")

				// Construct an instance of the EnginePropertiesOaiGen1Jvm model
				enginePropertiesOaiGen1JvmModel := new(watsonxdatav2.EnginePropertiesOaiGen1Jvm)
				enginePropertiesOaiGen1JvmModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesOaiGen1JvmModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the EnginePropertiesLogConfiguration model
				enginePropertiesLogConfigurationModel := new(watsonxdatav2.EnginePropertiesLogConfiguration)
				enginePropertiesLogConfigurationModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesLogConfigurationModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the PrestoEngineEngineProperties model
				prestoEngineEnginePropertiesModel := new(watsonxdatav2.PrestoEngineEngineProperties)
				prestoEngineEnginePropertiesModel.Catalog = prestoEnginePropertiesCatalogModel
				prestoEngineEnginePropertiesModel.Configuration = enginePropertiesOaiGen1ConfigurationModel
				prestoEngineEnginePropertiesModel.EventListener = prestoEnginePropertiesEventListenerModel
				prestoEngineEnginePropertiesModel.Global = prestoEnginePropertiesGlobalModel
				prestoEngineEnginePropertiesModel.Jvm = enginePropertiesOaiGen1JvmModel
				prestoEngineEnginePropertiesModel.LogConfig = enginePropertiesLogConfigurationModel

				// Construct an instance of the RemoveEnginePropertiesOaiGenConfiguration model
				removeEnginePropertiesOaiGenConfigurationModel := new(watsonxdatav2.RemoveEnginePropertiesOaiGenConfiguration)
				removeEnginePropertiesOaiGenConfigurationModel.Coordinator = []string{"testString"}
				removeEnginePropertiesOaiGenConfigurationModel.Worker = []string{"testString"}

				// Construct an instance of the RemoveEnginePropertiesOaiGenJvm model
				removeEnginePropertiesOaiGenJvmModel := new(watsonxdatav2.RemoveEnginePropertiesOaiGenJvm)
				removeEnginePropertiesOaiGenJvmModel.Coordinator = []string{"testString"}
				removeEnginePropertiesOaiGenJvmModel.Worker = []string{"testString"}

				// Construct an instance of the PrestoEnginePatchRemoveEngineProperties model
				prestoEnginePatchRemoveEnginePropertiesModel := new(watsonxdatav2.PrestoEnginePatchRemoveEngineProperties)
				prestoEnginePatchRemoveEnginePropertiesModel.Catalog = prestoEnginePropertiesCatalogModel
				prestoEnginePatchRemoveEnginePropertiesModel.Configuration = removeEnginePropertiesOaiGenConfigurationModel
				prestoEnginePatchRemoveEnginePropertiesModel.Jvm = removeEnginePropertiesOaiGenJvmModel
				prestoEnginePatchRemoveEnginePropertiesModel.EventListener = []string{}

				// Construct an instance of the PrestoEnginePatch model
				prestoEnginePatchModel := new(watsonxdatav2.PrestoEnginePatch)
				prestoEnginePatchModel.Description = core.StringPtr("updated description for presto engine")
				prestoEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				prestoEnginePatchModel.EngineProperties = prestoEngineEnginePropertiesModel
				prestoEnginePatchModel.EngineRestart = core.StringPtr("force")
				prestoEnginePatchModel.RemoveEngineProperties = prestoEnginePatchRemoveEnginePropertiesModel
				prestoEnginePatchModel.Tags = []string{"tag1", "tag2"}
				prestoEnginePatchModelAsPatch, asPatchErr := prestoEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdatePrestoEngineOptions model
				updatePrestoEngineOptionsModel := new(watsonxdatav2.UpdatePrestoEngineOptions)
				updatePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				updatePrestoEngineOptionsModel.Body = prestoEnginePatchModelAsPatch
				updatePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updatePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdatePrestoEngine(updatePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdatePrestoEngine(updatePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdatePrestoEngine(updatePrestoEngineOptions *UpdatePrestoEngineOptions)`, func() {
		updatePrestoEnginePath := "/presto_engines/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updatePrestoEnginePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "presto engine for running sql queries", "drivers": [{"connection_type": "saphana", "driver_id": "saphanadriver123", "driver_name": "saphanadriver-1.2.3", "driver_version": "1.2.3"}], "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "instance_id": "instance_id", "managed_by": "fully/self", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "event_listener": {"event_listener_property": "EventListenerProperty"}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "log_config": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "ibm-lh-lakehouse-presto-01-presto-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "event_listener": ["EventListener"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "presto", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke UpdatePrestoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the PrestoEnginePropertiesCatalog model
				prestoEnginePropertiesCatalogModel := new(watsonxdatav2.PrestoEnginePropertiesCatalog)
				prestoEnginePropertiesCatalogModel.CatalogName = core.StringPtr("testString")

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EnginePropertiesOaiGen1Configuration model
				enginePropertiesOaiGen1ConfigurationModel := new(watsonxdatav2.EnginePropertiesOaiGen1Configuration)
				enginePropertiesOaiGen1ConfigurationModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesOaiGen1ConfigurationModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the PrestoEnginePropertiesEventListener model
				prestoEnginePropertiesEventListenerModel := new(watsonxdatav2.PrestoEnginePropertiesEventListener)
				prestoEnginePropertiesEventListenerModel.EventListenerProperty = core.StringPtr("testString")

				// Construct an instance of the PrestoEnginePropertiesGlobal model
				prestoEnginePropertiesGlobalModel := new(watsonxdatav2.PrestoEnginePropertiesGlobal)
				prestoEnginePropertiesGlobalModel.GlobalProperty = core.StringPtr("enable-mixed-case-support:true")

				// Construct an instance of the EnginePropertiesOaiGen1Jvm model
				enginePropertiesOaiGen1JvmModel := new(watsonxdatav2.EnginePropertiesOaiGen1Jvm)
				enginePropertiesOaiGen1JvmModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesOaiGen1JvmModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the EnginePropertiesLogConfiguration model
				enginePropertiesLogConfigurationModel := new(watsonxdatav2.EnginePropertiesLogConfiguration)
				enginePropertiesLogConfigurationModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesLogConfigurationModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the PrestoEngineEngineProperties model
				prestoEngineEnginePropertiesModel := new(watsonxdatav2.PrestoEngineEngineProperties)
				prestoEngineEnginePropertiesModel.Catalog = prestoEnginePropertiesCatalogModel
				prestoEngineEnginePropertiesModel.Configuration = enginePropertiesOaiGen1ConfigurationModel
				prestoEngineEnginePropertiesModel.EventListener = prestoEnginePropertiesEventListenerModel
				prestoEngineEnginePropertiesModel.Global = prestoEnginePropertiesGlobalModel
				prestoEngineEnginePropertiesModel.Jvm = enginePropertiesOaiGen1JvmModel
				prestoEngineEnginePropertiesModel.LogConfig = enginePropertiesLogConfigurationModel

				// Construct an instance of the RemoveEnginePropertiesOaiGenConfiguration model
				removeEnginePropertiesOaiGenConfigurationModel := new(watsonxdatav2.RemoveEnginePropertiesOaiGenConfiguration)
				removeEnginePropertiesOaiGenConfigurationModel.Coordinator = []string{"testString"}
				removeEnginePropertiesOaiGenConfigurationModel.Worker = []string{"testString"}

				// Construct an instance of the RemoveEnginePropertiesOaiGenJvm model
				removeEnginePropertiesOaiGenJvmModel := new(watsonxdatav2.RemoveEnginePropertiesOaiGenJvm)
				removeEnginePropertiesOaiGenJvmModel.Coordinator = []string{"testString"}
				removeEnginePropertiesOaiGenJvmModel.Worker = []string{"testString"}

				// Construct an instance of the PrestoEnginePatchRemoveEngineProperties model
				prestoEnginePatchRemoveEnginePropertiesModel := new(watsonxdatav2.PrestoEnginePatchRemoveEngineProperties)
				prestoEnginePatchRemoveEnginePropertiesModel.Catalog = prestoEnginePropertiesCatalogModel
				prestoEnginePatchRemoveEnginePropertiesModel.Configuration = removeEnginePropertiesOaiGenConfigurationModel
				prestoEnginePatchRemoveEnginePropertiesModel.Jvm = removeEnginePropertiesOaiGenJvmModel
				prestoEnginePatchRemoveEnginePropertiesModel.EventListener = []string{}

				// Construct an instance of the PrestoEnginePatch model
				prestoEnginePatchModel := new(watsonxdatav2.PrestoEnginePatch)
				prestoEnginePatchModel.Description = core.StringPtr("updated description for presto engine")
				prestoEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				prestoEnginePatchModel.EngineProperties = prestoEngineEnginePropertiesModel
				prestoEnginePatchModel.EngineRestart = core.StringPtr("force")
				prestoEnginePatchModel.RemoveEngineProperties = prestoEnginePatchRemoveEnginePropertiesModel
				prestoEnginePatchModel.Tags = []string{"tag1", "tag2"}
				prestoEnginePatchModelAsPatch, asPatchErr := prestoEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdatePrestoEngineOptions model
				updatePrestoEngineOptionsModel := new(watsonxdatav2.UpdatePrestoEngineOptions)
				updatePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				updatePrestoEngineOptionsModel.Body = prestoEnginePatchModelAsPatch
				updatePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updatePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdatePrestoEngineWithContext(ctx, updatePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdatePrestoEngine(updatePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdatePrestoEngineWithContext(ctx, updatePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updatePrestoEnginePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "presto engine for running sql queries", "drivers": [{"connection_type": "saphana", "driver_id": "saphanadriver123", "driver_name": "saphanadriver-1.2.3", "driver_version": "1.2.3"}], "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "instance_id": "instance_id", "managed_by": "fully/self", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "event_listener": {"event_listener_property": "EventListenerProperty"}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "log_config": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "ibm-lh-lakehouse-presto-01-presto-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "event_listener": ["EventListener"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "presto", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke UpdatePrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdatePrestoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the PrestoEnginePropertiesCatalog model
				prestoEnginePropertiesCatalogModel := new(watsonxdatav2.PrestoEnginePropertiesCatalog)
				prestoEnginePropertiesCatalogModel.CatalogName = core.StringPtr("testString")

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EnginePropertiesOaiGen1Configuration model
				enginePropertiesOaiGen1ConfigurationModel := new(watsonxdatav2.EnginePropertiesOaiGen1Configuration)
				enginePropertiesOaiGen1ConfigurationModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesOaiGen1ConfigurationModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the PrestoEnginePropertiesEventListener model
				prestoEnginePropertiesEventListenerModel := new(watsonxdatav2.PrestoEnginePropertiesEventListener)
				prestoEnginePropertiesEventListenerModel.EventListenerProperty = core.StringPtr("testString")

				// Construct an instance of the PrestoEnginePropertiesGlobal model
				prestoEnginePropertiesGlobalModel := new(watsonxdatav2.PrestoEnginePropertiesGlobal)
				prestoEnginePropertiesGlobalModel.GlobalProperty = core.StringPtr("enable-mixed-case-support:true")

				// Construct an instance of the EnginePropertiesOaiGen1Jvm model
				enginePropertiesOaiGen1JvmModel := new(watsonxdatav2.EnginePropertiesOaiGen1Jvm)
				enginePropertiesOaiGen1JvmModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesOaiGen1JvmModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the EnginePropertiesLogConfiguration model
				enginePropertiesLogConfigurationModel := new(watsonxdatav2.EnginePropertiesLogConfiguration)
				enginePropertiesLogConfigurationModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesLogConfigurationModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the PrestoEngineEngineProperties model
				prestoEngineEnginePropertiesModel := new(watsonxdatav2.PrestoEngineEngineProperties)
				prestoEngineEnginePropertiesModel.Catalog = prestoEnginePropertiesCatalogModel
				prestoEngineEnginePropertiesModel.Configuration = enginePropertiesOaiGen1ConfigurationModel
				prestoEngineEnginePropertiesModel.EventListener = prestoEnginePropertiesEventListenerModel
				prestoEngineEnginePropertiesModel.Global = prestoEnginePropertiesGlobalModel
				prestoEngineEnginePropertiesModel.Jvm = enginePropertiesOaiGen1JvmModel
				prestoEngineEnginePropertiesModel.LogConfig = enginePropertiesLogConfigurationModel

				// Construct an instance of the RemoveEnginePropertiesOaiGenConfiguration model
				removeEnginePropertiesOaiGenConfigurationModel := new(watsonxdatav2.RemoveEnginePropertiesOaiGenConfiguration)
				removeEnginePropertiesOaiGenConfigurationModel.Coordinator = []string{"testString"}
				removeEnginePropertiesOaiGenConfigurationModel.Worker = []string{"testString"}

				// Construct an instance of the RemoveEnginePropertiesOaiGenJvm model
				removeEnginePropertiesOaiGenJvmModel := new(watsonxdatav2.RemoveEnginePropertiesOaiGenJvm)
				removeEnginePropertiesOaiGenJvmModel.Coordinator = []string{"testString"}
				removeEnginePropertiesOaiGenJvmModel.Worker = []string{"testString"}

				// Construct an instance of the PrestoEnginePatchRemoveEngineProperties model
				prestoEnginePatchRemoveEnginePropertiesModel := new(watsonxdatav2.PrestoEnginePatchRemoveEngineProperties)
				prestoEnginePatchRemoveEnginePropertiesModel.Catalog = prestoEnginePropertiesCatalogModel
				prestoEnginePatchRemoveEnginePropertiesModel.Configuration = removeEnginePropertiesOaiGenConfigurationModel
				prestoEnginePatchRemoveEnginePropertiesModel.Jvm = removeEnginePropertiesOaiGenJvmModel
				prestoEnginePatchRemoveEnginePropertiesModel.EventListener = []string{}

				// Construct an instance of the PrestoEnginePatch model
				prestoEnginePatchModel := new(watsonxdatav2.PrestoEnginePatch)
				prestoEnginePatchModel.Description = core.StringPtr("updated description for presto engine")
				prestoEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				prestoEnginePatchModel.EngineProperties = prestoEngineEnginePropertiesModel
				prestoEnginePatchModel.EngineRestart = core.StringPtr("force")
				prestoEnginePatchModel.RemoveEngineProperties = prestoEnginePatchRemoveEnginePropertiesModel
				prestoEnginePatchModel.Tags = []string{"tag1", "tag2"}
				prestoEnginePatchModelAsPatch, asPatchErr := prestoEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdatePrestoEngineOptions model
				updatePrestoEngineOptionsModel := new(watsonxdatav2.UpdatePrestoEngineOptions)
				updatePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				updatePrestoEngineOptionsModel.Body = prestoEnginePatchModelAsPatch
				updatePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updatePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdatePrestoEngine(updatePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdatePrestoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestoEnginePropertiesCatalog model
				prestoEnginePropertiesCatalogModel := new(watsonxdatav2.PrestoEnginePropertiesCatalog)
				prestoEnginePropertiesCatalogModel.CatalogName = core.StringPtr("testString")

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EnginePropertiesOaiGen1Configuration model
				enginePropertiesOaiGen1ConfigurationModel := new(watsonxdatav2.EnginePropertiesOaiGen1Configuration)
				enginePropertiesOaiGen1ConfigurationModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesOaiGen1ConfigurationModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the PrestoEnginePropertiesEventListener model
				prestoEnginePropertiesEventListenerModel := new(watsonxdatav2.PrestoEnginePropertiesEventListener)
				prestoEnginePropertiesEventListenerModel.EventListenerProperty = core.StringPtr("testString")

				// Construct an instance of the PrestoEnginePropertiesGlobal model
				prestoEnginePropertiesGlobalModel := new(watsonxdatav2.PrestoEnginePropertiesGlobal)
				prestoEnginePropertiesGlobalModel.GlobalProperty = core.StringPtr("enable-mixed-case-support:true")

				// Construct an instance of the EnginePropertiesOaiGen1Jvm model
				enginePropertiesOaiGen1JvmModel := new(watsonxdatav2.EnginePropertiesOaiGen1Jvm)
				enginePropertiesOaiGen1JvmModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesOaiGen1JvmModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the EnginePropertiesLogConfiguration model
				enginePropertiesLogConfigurationModel := new(watsonxdatav2.EnginePropertiesLogConfiguration)
				enginePropertiesLogConfigurationModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesLogConfigurationModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the PrestoEngineEngineProperties model
				prestoEngineEnginePropertiesModel := new(watsonxdatav2.PrestoEngineEngineProperties)
				prestoEngineEnginePropertiesModel.Catalog = prestoEnginePropertiesCatalogModel
				prestoEngineEnginePropertiesModel.Configuration = enginePropertiesOaiGen1ConfigurationModel
				prestoEngineEnginePropertiesModel.EventListener = prestoEnginePropertiesEventListenerModel
				prestoEngineEnginePropertiesModel.Global = prestoEnginePropertiesGlobalModel
				prestoEngineEnginePropertiesModel.Jvm = enginePropertiesOaiGen1JvmModel
				prestoEngineEnginePropertiesModel.LogConfig = enginePropertiesLogConfigurationModel

				// Construct an instance of the RemoveEnginePropertiesOaiGenConfiguration model
				removeEnginePropertiesOaiGenConfigurationModel := new(watsonxdatav2.RemoveEnginePropertiesOaiGenConfiguration)
				removeEnginePropertiesOaiGenConfigurationModel.Coordinator = []string{"testString"}
				removeEnginePropertiesOaiGenConfigurationModel.Worker = []string{"testString"}

				// Construct an instance of the RemoveEnginePropertiesOaiGenJvm model
				removeEnginePropertiesOaiGenJvmModel := new(watsonxdatav2.RemoveEnginePropertiesOaiGenJvm)
				removeEnginePropertiesOaiGenJvmModel.Coordinator = []string{"testString"}
				removeEnginePropertiesOaiGenJvmModel.Worker = []string{"testString"}

				// Construct an instance of the PrestoEnginePatchRemoveEngineProperties model
				prestoEnginePatchRemoveEnginePropertiesModel := new(watsonxdatav2.PrestoEnginePatchRemoveEngineProperties)
				prestoEnginePatchRemoveEnginePropertiesModel.Catalog = prestoEnginePropertiesCatalogModel
				prestoEnginePatchRemoveEnginePropertiesModel.Configuration = removeEnginePropertiesOaiGenConfigurationModel
				prestoEnginePatchRemoveEnginePropertiesModel.Jvm = removeEnginePropertiesOaiGenJvmModel
				prestoEnginePatchRemoveEnginePropertiesModel.EventListener = []string{}

				// Construct an instance of the PrestoEnginePatch model
				prestoEnginePatchModel := new(watsonxdatav2.PrestoEnginePatch)
				prestoEnginePatchModel.Description = core.StringPtr("updated description for presto engine")
				prestoEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				prestoEnginePatchModel.EngineProperties = prestoEngineEnginePropertiesModel
				prestoEnginePatchModel.EngineRestart = core.StringPtr("force")
				prestoEnginePatchModel.RemoveEngineProperties = prestoEnginePatchRemoveEnginePropertiesModel
				prestoEnginePatchModel.Tags = []string{"tag1", "tag2"}
				prestoEnginePatchModelAsPatch, asPatchErr := prestoEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdatePrestoEngineOptions model
				updatePrestoEngineOptionsModel := new(watsonxdatav2.UpdatePrestoEngineOptions)
				updatePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				updatePrestoEngineOptionsModel.Body = prestoEnginePatchModelAsPatch
				updatePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updatePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdatePrestoEngine(updatePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdatePrestoEngineOptions model with no property values
				updatePrestoEngineOptionsModelNew := new(watsonxdatav2.UpdatePrestoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdatePrestoEngine(updatePrestoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdatePrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestoEnginePropertiesCatalog model
				prestoEnginePropertiesCatalogModel := new(watsonxdatav2.PrestoEnginePropertiesCatalog)
				prestoEnginePropertiesCatalogModel.CatalogName = core.StringPtr("testString")

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EnginePropertiesOaiGen1Configuration model
				enginePropertiesOaiGen1ConfigurationModel := new(watsonxdatav2.EnginePropertiesOaiGen1Configuration)
				enginePropertiesOaiGen1ConfigurationModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesOaiGen1ConfigurationModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the PrestoEnginePropertiesEventListener model
				prestoEnginePropertiesEventListenerModel := new(watsonxdatav2.PrestoEnginePropertiesEventListener)
				prestoEnginePropertiesEventListenerModel.EventListenerProperty = core.StringPtr("testString")

				// Construct an instance of the PrestoEnginePropertiesGlobal model
				prestoEnginePropertiesGlobalModel := new(watsonxdatav2.PrestoEnginePropertiesGlobal)
				prestoEnginePropertiesGlobalModel.GlobalProperty = core.StringPtr("enable-mixed-case-support:true")

				// Construct an instance of the EnginePropertiesOaiGen1Jvm model
				enginePropertiesOaiGen1JvmModel := new(watsonxdatav2.EnginePropertiesOaiGen1Jvm)
				enginePropertiesOaiGen1JvmModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesOaiGen1JvmModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the EnginePropertiesLogConfiguration model
				enginePropertiesLogConfigurationModel := new(watsonxdatav2.EnginePropertiesLogConfiguration)
				enginePropertiesLogConfigurationModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesLogConfigurationModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the PrestoEngineEngineProperties model
				prestoEngineEnginePropertiesModel := new(watsonxdatav2.PrestoEngineEngineProperties)
				prestoEngineEnginePropertiesModel.Catalog = prestoEnginePropertiesCatalogModel
				prestoEngineEnginePropertiesModel.Configuration = enginePropertiesOaiGen1ConfigurationModel
				prestoEngineEnginePropertiesModel.EventListener = prestoEnginePropertiesEventListenerModel
				prestoEngineEnginePropertiesModel.Global = prestoEnginePropertiesGlobalModel
				prestoEngineEnginePropertiesModel.Jvm = enginePropertiesOaiGen1JvmModel
				prestoEngineEnginePropertiesModel.LogConfig = enginePropertiesLogConfigurationModel

				// Construct an instance of the RemoveEnginePropertiesOaiGenConfiguration model
				removeEnginePropertiesOaiGenConfigurationModel := new(watsonxdatav2.RemoveEnginePropertiesOaiGenConfiguration)
				removeEnginePropertiesOaiGenConfigurationModel.Coordinator = []string{"testString"}
				removeEnginePropertiesOaiGenConfigurationModel.Worker = []string{"testString"}

				// Construct an instance of the RemoveEnginePropertiesOaiGenJvm model
				removeEnginePropertiesOaiGenJvmModel := new(watsonxdatav2.RemoveEnginePropertiesOaiGenJvm)
				removeEnginePropertiesOaiGenJvmModel.Coordinator = []string{"testString"}
				removeEnginePropertiesOaiGenJvmModel.Worker = []string{"testString"}

				// Construct an instance of the PrestoEnginePatchRemoveEngineProperties model
				prestoEnginePatchRemoveEnginePropertiesModel := new(watsonxdatav2.PrestoEnginePatchRemoveEngineProperties)
				prestoEnginePatchRemoveEnginePropertiesModel.Catalog = prestoEnginePropertiesCatalogModel
				prestoEnginePatchRemoveEnginePropertiesModel.Configuration = removeEnginePropertiesOaiGenConfigurationModel
				prestoEnginePatchRemoveEnginePropertiesModel.Jvm = removeEnginePropertiesOaiGenJvmModel
				prestoEnginePatchRemoveEnginePropertiesModel.EventListener = []string{}

				// Construct an instance of the PrestoEnginePatch model
				prestoEnginePatchModel := new(watsonxdatav2.PrestoEnginePatch)
				prestoEnginePatchModel.Description = core.StringPtr("updated description for presto engine")
				prestoEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				prestoEnginePatchModel.EngineProperties = prestoEngineEnginePropertiesModel
				prestoEnginePatchModel.EngineRestart = core.StringPtr("force")
				prestoEnginePatchModel.RemoveEngineProperties = prestoEnginePatchRemoveEnginePropertiesModel
				prestoEnginePatchModel.Tags = []string{"tag1", "tag2"}
				prestoEnginePatchModelAsPatch, asPatchErr := prestoEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdatePrestoEngineOptions model
				updatePrestoEngineOptionsModel := new(watsonxdatav2.UpdatePrestoEngineOptions)
				updatePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				updatePrestoEngineOptionsModel.Body = prestoEnginePatchModelAsPatch
				updatePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updatePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdatePrestoEngine(updatePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListPrestoEngineCatalogs(listPrestoEngineCatalogsOptions *ListPrestoEngineCatalogsOptions) - Operation response error`, func() {
		listPrestoEngineCatalogsPath := "/presto_engines/testString/catalogs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestoEngineCatalogsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListPrestoEngineCatalogs with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestoEngineCatalogsOptions model
				listPrestoEngineCatalogsOptionsModel := new(watsonxdatav2.ListPrestoEngineCatalogsOptions)
				listPrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listPrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListPrestoEngineCatalogs(listPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListPrestoEngineCatalogs(listPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListPrestoEngineCatalogs(listPrestoEngineCatalogsOptions *ListPrestoEngineCatalogsOptions)`, func() {
		listPrestoEngineCatalogsPath := "/presto_engines/testString/catalogs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestoEngineCatalogsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke ListPrestoEngineCatalogs successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListPrestoEngineCatalogsOptions model
				listPrestoEngineCatalogsOptionsModel := new(watsonxdatav2.ListPrestoEngineCatalogsOptions)
				listPrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listPrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListPrestoEngineCatalogsWithContext(ctx, listPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListPrestoEngineCatalogs(listPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListPrestoEngineCatalogsWithContext(ctx, listPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestoEngineCatalogsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke ListPrestoEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListPrestoEngineCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListPrestoEngineCatalogsOptions model
				listPrestoEngineCatalogsOptionsModel := new(watsonxdatav2.ListPrestoEngineCatalogsOptions)
				listPrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listPrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListPrestoEngineCatalogs(listPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListPrestoEngineCatalogs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestoEngineCatalogsOptions model
				listPrestoEngineCatalogsOptionsModel := new(watsonxdatav2.ListPrestoEngineCatalogsOptions)
				listPrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listPrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListPrestoEngineCatalogs(listPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListPrestoEngineCatalogsOptions model with no property values
				listPrestoEngineCatalogsOptionsModelNew := new(watsonxdatav2.ListPrestoEngineCatalogsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListPrestoEngineCatalogs(listPrestoEngineCatalogsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListPrestoEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestoEngineCatalogsOptions model
				listPrestoEngineCatalogsOptionsModel := new(watsonxdatav2.ListPrestoEngineCatalogsOptions)
				listPrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listPrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListPrestoEngineCatalogs(listPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreatePrestoEngineCatalogs(createPrestoEngineCatalogsOptions *CreatePrestoEngineCatalogsOptions) - Operation response error`, func() {
		createPrestoEngineCatalogsPath := "/presto_engines/testString/catalogs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPrestoEngineCatalogsPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreatePrestoEngineCatalogs with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreatePrestoEngineCatalogsOptions model
				createPrestoEngineCatalogsOptionsModel := new(watsonxdatav2.CreatePrestoEngineCatalogsOptions)
				createPrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				createPrestoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				createPrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreatePrestoEngineCatalogs(createPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreatePrestoEngineCatalogs(createPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreatePrestoEngineCatalogs(createPrestoEngineCatalogsOptions *CreatePrestoEngineCatalogsOptions)`, func() {
		createPrestoEngineCatalogsPath := "/presto_engines/testString/catalogs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPrestoEngineCatalogsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke CreatePrestoEngineCatalogs successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreatePrestoEngineCatalogsOptions model
				createPrestoEngineCatalogsOptionsModel := new(watsonxdatav2.CreatePrestoEngineCatalogsOptions)
				createPrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				createPrestoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				createPrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreatePrestoEngineCatalogsWithContext(ctx, createPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreatePrestoEngineCatalogs(createPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreatePrestoEngineCatalogsWithContext(ctx, createPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPrestoEngineCatalogsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke CreatePrestoEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreatePrestoEngineCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreatePrestoEngineCatalogsOptions model
				createPrestoEngineCatalogsOptionsModel := new(watsonxdatav2.CreatePrestoEngineCatalogsOptions)
				createPrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				createPrestoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				createPrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreatePrestoEngineCatalogs(createPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreatePrestoEngineCatalogs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreatePrestoEngineCatalogsOptions model
				createPrestoEngineCatalogsOptionsModel := new(watsonxdatav2.CreatePrestoEngineCatalogsOptions)
				createPrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				createPrestoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				createPrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreatePrestoEngineCatalogs(createPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreatePrestoEngineCatalogsOptions model with no property values
				createPrestoEngineCatalogsOptionsModelNew := new(watsonxdatav2.CreatePrestoEngineCatalogsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreatePrestoEngineCatalogs(createPrestoEngineCatalogsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreatePrestoEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreatePrestoEngineCatalogsOptions model
				createPrestoEngineCatalogsOptionsModel := new(watsonxdatav2.CreatePrestoEngineCatalogsOptions)
				createPrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				createPrestoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				createPrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreatePrestoEngineCatalogs(createPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeletePrestoEngineCatalogs(deletePrestoEngineCatalogsOptions *DeletePrestoEngineCatalogsOptions)`, func() {
		deletePrestoEngineCatalogsPath := "/presto_engines/testString/catalogs"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deletePrestoEngineCatalogsPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["catalog_names"]).To(Equal([]string{"testString"}))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeletePrestoEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeletePrestoEngineCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeletePrestoEngineCatalogsOptions model
				deletePrestoEngineCatalogsOptionsModel := new(watsonxdatav2.DeletePrestoEngineCatalogsOptions)
				deletePrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				deletePrestoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				deletePrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deletePrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeletePrestoEngineCatalogs(deletePrestoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeletePrestoEngineCatalogs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeletePrestoEngineCatalogsOptions model
				deletePrestoEngineCatalogsOptionsModel := new(watsonxdatav2.DeletePrestoEngineCatalogsOptions)
				deletePrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				deletePrestoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				deletePrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deletePrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeletePrestoEngineCatalogs(deletePrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeletePrestoEngineCatalogsOptions model with no property values
				deletePrestoEngineCatalogsOptionsModelNew := new(watsonxdatav2.DeletePrestoEngineCatalogsOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeletePrestoEngineCatalogs(deletePrestoEngineCatalogsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPrestoEngineCatalog(getPrestoEngineCatalogOptions *GetPrestoEngineCatalogOptions) - Operation response error`, func() {
		getPrestoEngineCatalogPath := "/presto_engines/testString/catalogs/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestoEngineCatalogPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetPrestoEngineCatalog with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestoEngineCatalogOptions model
				getPrestoEngineCatalogOptionsModel := new(watsonxdatav2.GetPrestoEngineCatalogOptions)
				getPrestoEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetPrestoEngineCatalog(getPrestoEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetPrestoEngineCatalog(getPrestoEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPrestoEngineCatalog(getPrestoEngineCatalogOptions *GetPrestoEngineCatalogOptions)`, func() {
		getPrestoEngineCatalogPath := "/presto_engines/testString/catalogs/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestoEngineCatalogPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke GetPrestoEngineCatalog successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetPrestoEngineCatalogOptions model
				getPrestoEngineCatalogOptionsModel := new(watsonxdatav2.GetPrestoEngineCatalogOptions)
				getPrestoEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetPrestoEngineCatalogWithContext(ctx, getPrestoEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetPrestoEngineCatalog(getPrestoEngineCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetPrestoEngineCatalogWithContext(ctx, getPrestoEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestoEngineCatalogPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke GetPrestoEngineCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetPrestoEngineCatalog(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetPrestoEngineCatalogOptions model
				getPrestoEngineCatalogOptionsModel := new(watsonxdatav2.GetPrestoEngineCatalogOptions)
				getPrestoEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetPrestoEngineCatalog(getPrestoEngineCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetPrestoEngineCatalog with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestoEngineCatalogOptions model
				getPrestoEngineCatalogOptionsModel := new(watsonxdatav2.GetPrestoEngineCatalogOptions)
				getPrestoEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetPrestoEngineCatalog(getPrestoEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetPrestoEngineCatalogOptions model with no property values
				getPrestoEngineCatalogOptionsModelNew := new(watsonxdatav2.GetPrestoEngineCatalogOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetPrestoEngineCatalog(getPrestoEngineCatalogOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetPrestoEngineCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestoEngineCatalogOptions model
				getPrestoEngineCatalogOptionsModel := new(watsonxdatav2.GetPrestoEngineCatalogOptions)
				getPrestoEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetPrestoEngineCatalog(getPrestoEngineCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PausePrestoEngine(pausePrestoEngineOptions *PausePrestoEngineOptions) - Operation response error`, func() {
		pausePrestoEnginePath := "/presto_engines/testString/pause"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(pausePrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke PausePrestoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PausePrestoEngineOptions model
				pausePrestoEngineOptionsModel := new(watsonxdatav2.PausePrestoEngineOptions)
				pausePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				pausePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pausePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.PausePrestoEngine(pausePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.PausePrestoEngine(pausePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PausePrestoEngine(pausePrestoEngineOptions *PausePrestoEngineOptions)`, func() {
		pausePrestoEnginePath := "/presto_engines/testString/pause"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(pausePrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke PausePrestoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the PausePrestoEngineOptions model
				pausePrestoEngineOptionsModel := new(watsonxdatav2.PausePrestoEngineOptions)
				pausePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				pausePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pausePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.PausePrestoEngineWithContext(ctx, pausePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.PausePrestoEngine(pausePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.PausePrestoEngineWithContext(ctx, pausePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(pausePrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke PausePrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.PausePrestoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the PausePrestoEngineOptions model
				pausePrestoEngineOptionsModel := new(watsonxdatav2.PausePrestoEngineOptions)
				pausePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				pausePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pausePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.PausePrestoEngine(pausePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke PausePrestoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PausePrestoEngineOptions model
				pausePrestoEngineOptionsModel := new(watsonxdatav2.PausePrestoEngineOptions)
				pausePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				pausePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pausePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.PausePrestoEngine(pausePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the PausePrestoEngineOptions model with no property values
				pausePrestoEngineOptionsModelNew := new(watsonxdatav2.PausePrestoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.PausePrestoEngine(pausePrestoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke PausePrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PausePrestoEngineOptions model
				pausePrestoEngineOptionsModel := new(watsonxdatav2.PausePrestoEngineOptions)
				pausePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				pausePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pausePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.PausePrestoEngine(pausePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RunExplainStatement(runExplainStatementOptions *RunExplainStatementOptions) - Operation response error`, func() {
		runExplainStatementPath := "/presto_engines/testString/query_explain"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runExplainStatementPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke RunExplainStatement with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunExplainStatementOptions model
				runExplainStatementOptionsModel := new(watsonxdatav2.RunExplainStatementOptions)
				runExplainStatementOptionsModel.EngineID = core.StringPtr("testString")
				runExplainStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runExplainStatementOptionsModel.Format = core.StringPtr("json")
				runExplainStatementOptionsModel.Type = core.StringPtr("io")
				runExplainStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runExplainStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.RunExplainStatement(runExplainStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.RunExplainStatement(runExplainStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RunExplainStatement(runExplainStatementOptions *RunExplainStatementOptions)`, func() {
		runExplainStatementPath := "/presto_engines/testString/query_explain"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runExplainStatementPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}, "result": "Result"}`)
				}))
			})
			It(`Invoke RunExplainStatement successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the RunExplainStatementOptions model
				runExplainStatementOptionsModel := new(watsonxdatav2.RunExplainStatementOptions)
				runExplainStatementOptionsModel.EngineID = core.StringPtr("testString")
				runExplainStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runExplainStatementOptionsModel.Format = core.StringPtr("json")
				runExplainStatementOptionsModel.Type = core.StringPtr("io")
				runExplainStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runExplainStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.RunExplainStatementWithContext(ctx, runExplainStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.RunExplainStatement(runExplainStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.RunExplainStatementWithContext(ctx, runExplainStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runExplainStatementPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}, "result": "Result"}`)
				}))
			})
			It(`Invoke RunExplainStatement successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.RunExplainStatement(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the RunExplainStatementOptions model
				runExplainStatementOptionsModel := new(watsonxdatav2.RunExplainStatementOptions)
				runExplainStatementOptionsModel.EngineID = core.StringPtr("testString")
				runExplainStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runExplainStatementOptionsModel.Format = core.StringPtr("json")
				runExplainStatementOptionsModel.Type = core.StringPtr("io")
				runExplainStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runExplainStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.RunExplainStatement(runExplainStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke RunExplainStatement with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunExplainStatementOptions model
				runExplainStatementOptionsModel := new(watsonxdatav2.RunExplainStatementOptions)
				runExplainStatementOptionsModel.EngineID = core.StringPtr("testString")
				runExplainStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runExplainStatementOptionsModel.Format = core.StringPtr("json")
				runExplainStatementOptionsModel.Type = core.StringPtr("io")
				runExplainStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runExplainStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.RunExplainStatement(runExplainStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the RunExplainStatementOptions model with no property values
				runExplainStatementOptionsModelNew := new(watsonxdatav2.RunExplainStatementOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.RunExplainStatement(runExplainStatementOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke RunExplainStatement successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunExplainStatementOptions model
				runExplainStatementOptionsModel := new(watsonxdatav2.RunExplainStatementOptions)
				runExplainStatementOptionsModel.EngineID = core.StringPtr("testString")
				runExplainStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runExplainStatementOptionsModel.Format = core.StringPtr("json")
				runExplainStatementOptionsModel.Type = core.StringPtr("io")
				runExplainStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runExplainStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.RunExplainStatement(runExplainStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RunExplainAnalyzeStatement(runExplainAnalyzeStatementOptions *RunExplainAnalyzeStatementOptions) - Operation response error`, func() {
		runExplainAnalyzeStatementPath := "/presto_engines/testString/query_explain_analyze"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runExplainAnalyzeStatementPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke RunExplainAnalyzeStatement with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunExplainAnalyzeStatementOptions model
				runExplainAnalyzeStatementOptionsModel := new(watsonxdatav2.RunExplainAnalyzeStatementOptions)
				runExplainAnalyzeStatementOptionsModel.EngineID = core.StringPtr("testString")
				runExplainAnalyzeStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runExplainAnalyzeStatementOptionsModel.Verbose = core.BoolPtr(true)
				runExplainAnalyzeStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runExplainAnalyzeStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.RunExplainAnalyzeStatement(runExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.RunExplainAnalyzeStatement(runExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RunExplainAnalyzeStatement(runExplainAnalyzeStatementOptions *RunExplainAnalyzeStatementOptions)`, func() {
		runExplainAnalyzeStatementPath := "/presto_engines/testString/query_explain_analyze"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runExplainAnalyzeStatementPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}, "result": "Result"}`)
				}))
			})
			It(`Invoke RunExplainAnalyzeStatement successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the RunExplainAnalyzeStatementOptions model
				runExplainAnalyzeStatementOptionsModel := new(watsonxdatav2.RunExplainAnalyzeStatementOptions)
				runExplainAnalyzeStatementOptionsModel.EngineID = core.StringPtr("testString")
				runExplainAnalyzeStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runExplainAnalyzeStatementOptionsModel.Verbose = core.BoolPtr(true)
				runExplainAnalyzeStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runExplainAnalyzeStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.RunExplainAnalyzeStatementWithContext(ctx, runExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.RunExplainAnalyzeStatement(runExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.RunExplainAnalyzeStatementWithContext(ctx, runExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runExplainAnalyzeStatementPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}, "result": "Result"}`)
				}))
			})
			It(`Invoke RunExplainAnalyzeStatement successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.RunExplainAnalyzeStatement(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the RunExplainAnalyzeStatementOptions model
				runExplainAnalyzeStatementOptionsModel := new(watsonxdatav2.RunExplainAnalyzeStatementOptions)
				runExplainAnalyzeStatementOptionsModel.EngineID = core.StringPtr("testString")
				runExplainAnalyzeStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runExplainAnalyzeStatementOptionsModel.Verbose = core.BoolPtr(true)
				runExplainAnalyzeStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runExplainAnalyzeStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.RunExplainAnalyzeStatement(runExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke RunExplainAnalyzeStatement with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunExplainAnalyzeStatementOptions model
				runExplainAnalyzeStatementOptionsModel := new(watsonxdatav2.RunExplainAnalyzeStatementOptions)
				runExplainAnalyzeStatementOptionsModel.EngineID = core.StringPtr("testString")
				runExplainAnalyzeStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runExplainAnalyzeStatementOptionsModel.Verbose = core.BoolPtr(true)
				runExplainAnalyzeStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runExplainAnalyzeStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.RunExplainAnalyzeStatement(runExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the RunExplainAnalyzeStatementOptions model with no property values
				runExplainAnalyzeStatementOptionsModelNew := new(watsonxdatav2.RunExplainAnalyzeStatementOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.RunExplainAnalyzeStatement(runExplainAnalyzeStatementOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke RunExplainAnalyzeStatement successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunExplainAnalyzeStatementOptions model
				runExplainAnalyzeStatementOptionsModel := new(watsonxdatav2.RunExplainAnalyzeStatementOptions)
				runExplainAnalyzeStatementOptionsModel.EngineID = core.StringPtr("testString")
				runExplainAnalyzeStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runExplainAnalyzeStatementOptionsModel.Verbose = core.BoolPtr(true)
				runExplainAnalyzeStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runExplainAnalyzeStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.RunExplainAnalyzeStatement(runExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RestartPrestoEngine(restartPrestoEngineOptions *RestartPrestoEngineOptions) - Operation response error`, func() {
		restartPrestoEnginePath := "/presto_engines/testString/restart"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(restartPrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke RestartPrestoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RestartPrestoEngineOptions model
				restartPrestoEngineOptionsModel := new(watsonxdatav2.RestartPrestoEngineOptions)
				restartPrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				restartPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				restartPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.RestartPrestoEngine(restartPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.RestartPrestoEngine(restartPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RestartPrestoEngine(restartPrestoEngineOptions *RestartPrestoEngineOptions)`, func() {
		restartPrestoEnginePath := "/presto_engines/testString/restart"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(restartPrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke RestartPrestoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the RestartPrestoEngineOptions model
				restartPrestoEngineOptionsModel := new(watsonxdatav2.RestartPrestoEngineOptions)
				restartPrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				restartPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				restartPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.RestartPrestoEngineWithContext(ctx, restartPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.RestartPrestoEngine(restartPrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.RestartPrestoEngineWithContext(ctx, restartPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(restartPrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke RestartPrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.RestartPrestoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the RestartPrestoEngineOptions model
				restartPrestoEngineOptionsModel := new(watsonxdatav2.RestartPrestoEngineOptions)
				restartPrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				restartPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				restartPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.RestartPrestoEngine(restartPrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke RestartPrestoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RestartPrestoEngineOptions model
				restartPrestoEngineOptionsModel := new(watsonxdatav2.RestartPrestoEngineOptions)
				restartPrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				restartPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				restartPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.RestartPrestoEngine(restartPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the RestartPrestoEngineOptions model with no property values
				restartPrestoEngineOptionsModelNew := new(watsonxdatav2.RestartPrestoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.RestartPrestoEngine(restartPrestoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke RestartPrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RestartPrestoEngineOptions model
				restartPrestoEngineOptionsModel := new(watsonxdatav2.RestartPrestoEngineOptions)
				restartPrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				restartPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				restartPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.RestartPrestoEngine(restartPrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ResumePrestoEngine(resumePrestoEngineOptions *ResumePrestoEngineOptions) - Operation response error`, func() {
		resumePrestoEnginePath := "/presto_engines/testString/resume"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(resumePrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ResumePrestoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ResumePrestoEngineOptions model
				resumePrestoEngineOptionsModel := new(watsonxdatav2.ResumePrestoEngineOptions)
				resumePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ResumePrestoEngine(resumePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ResumePrestoEngine(resumePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ResumePrestoEngine(resumePrestoEngineOptions *ResumePrestoEngineOptions)`, func() {
		resumePrestoEnginePath := "/presto_engines/testString/resume"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(resumePrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke ResumePrestoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ResumePrestoEngineOptions model
				resumePrestoEngineOptionsModel := new(watsonxdatav2.ResumePrestoEngineOptions)
				resumePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ResumePrestoEngineWithContext(ctx, resumePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ResumePrestoEngine(resumePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ResumePrestoEngineWithContext(ctx, resumePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(resumePrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke ResumePrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ResumePrestoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ResumePrestoEngineOptions model
				resumePrestoEngineOptionsModel := new(watsonxdatav2.ResumePrestoEngineOptions)
				resumePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ResumePrestoEngine(resumePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ResumePrestoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ResumePrestoEngineOptions model
				resumePrestoEngineOptionsModel := new(watsonxdatav2.ResumePrestoEngineOptions)
				resumePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ResumePrestoEngine(resumePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ResumePrestoEngineOptions model with no property values
				resumePrestoEngineOptionsModelNew := new(watsonxdatav2.ResumePrestoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ResumePrestoEngine(resumePrestoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ResumePrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ResumePrestoEngineOptions model
				resumePrestoEngineOptionsModel := new(watsonxdatav2.ResumePrestoEngineOptions)
				resumePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ResumePrestoEngine(resumePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ScalePrestoEngine(scalePrestoEngineOptions *ScalePrestoEngineOptions) - Operation response error`, func() {
		scalePrestoEnginePath := "/presto_engines/testString/scale"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(scalePrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ScalePrestoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NodeDescription model
				nodeDescriptionModel := new(watsonxdatav2.NodeDescription)
				nodeDescriptionModel.NodeType = core.StringPtr("worker")
				nodeDescriptionModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the ScalePrestoEngineOptions model
				scalePrestoEngineOptionsModel := new(watsonxdatav2.ScalePrestoEngineOptions)
				scalePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				scalePrestoEngineOptionsModel.Coordinator = nodeDescriptionModel
				scalePrestoEngineOptionsModel.Worker = nodeDescriptionModel
				scalePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scalePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ScalePrestoEngine(scalePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ScalePrestoEngine(scalePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ScalePrestoEngine(scalePrestoEngineOptions *ScalePrestoEngineOptions)`, func() {
		scalePrestoEnginePath := "/presto_engines/testString/scale"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(scalePrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke ScalePrestoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the NodeDescription model
				nodeDescriptionModel := new(watsonxdatav2.NodeDescription)
				nodeDescriptionModel.NodeType = core.StringPtr("worker")
				nodeDescriptionModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the ScalePrestoEngineOptions model
				scalePrestoEngineOptionsModel := new(watsonxdatav2.ScalePrestoEngineOptions)
				scalePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				scalePrestoEngineOptionsModel.Coordinator = nodeDescriptionModel
				scalePrestoEngineOptionsModel.Worker = nodeDescriptionModel
				scalePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scalePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ScalePrestoEngineWithContext(ctx, scalePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ScalePrestoEngine(scalePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ScalePrestoEngineWithContext(ctx, scalePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(scalePrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke ScalePrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ScalePrestoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the NodeDescription model
				nodeDescriptionModel := new(watsonxdatav2.NodeDescription)
				nodeDescriptionModel.NodeType = core.StringPtr("worker")
				nodeDescriptionModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the ScalePrestoEngineOptions model
				scalePrestoEngineOptionsModel := new(watsonxdatav2.ScalePrestoEngineOptions)
				scalePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				scalePrestoEngineOptionsModel.Coordinator = nodeDescriptionModel
				scalePrestoEngineOptionsModel.Worker = nodeDescriptionModel
				scalePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scalePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ScalePrestoEngine(scalePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ScalePrestoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NodeDescription model
				nodeDescriptionModel := new(watsonxdatav2.NodeDescription)
				nodeDescriptionModel.NodeType = core.StringPtr("worker")
				nodeDescriptionModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the ScalePrestoEngineOptions model
				scalePrestoEngineOptionsModel := new(watsonxdatav2.ScalePrestoEngineOptions)
				scalePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				scalePrestoEngineOptionsModel.Coordinator = nodeDescriptionModel
				scalePrestoEngineOptionsModel.Worker = nodeDescriptionModel
				scalePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scalePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ScalePrestoEngine(scalePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ScalePrestoEngineOptions model with no property values
				scalePrestoEngineOptionsModelNew := new(watsonxdatav2.ScalePrestoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ScalePrestoEngine(scalePrestoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(202)
				}))
			})
			It(`Invoke ScalePrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NodeDescription model
				nodeDescriptionModel := new(watsonxdatav2.NodeDescription)
				nodeDescriptionModel.NodeType = core.StringPtr("worker")
				nodeDescriptionModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the ScalePrestoEngineOptions model
				scalePrestoEngineOptionsModel := new(watsonxdatav2.ScalePrestoEngineOptions)
				scalePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				scalePrestoEngineOptionsModel.Coordinator = nodeDescriptionModel
				scalePrestoEngineOptionsModel.Worker = nodeDescriptionModel
				scalePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scalePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ScalePrestoEngine(scalePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegration(getSalIntegrationOptions *GetSalIntegrationOptions) - Operation response error`, func() {
		getSalIntegrationPath := "/sal_integrations"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetSalIntegration with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationOptions model
				getSalIntegrationOptionsModel := new(watsonxdatav2.GetSalIntegrationOptions)
				getSalIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetSalIntegration(getSalIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetSalIntegration(getSalIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegration(getSalIntegrationOptions *GetSalIntegrationOptions)`, func() {
		getSalIntegrationPath := "/sal_integrations"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"category_id": "10e64285-bf37-4d5d-b759-bc6a46589234", "engine_id": "presto-01", "errors": [{"code": "unable_to_perform", "message": "Failed to process integration settings for watsonx.data instance"}], "governance_scope_id": "10e64285-bf37-4d5d-b759-bc6a46589234", "governance_scope_type": "category", "instance_id": "18b49d7a-9519-4539-8db5-ff080623c226", "status": "provisioning", "storage_resource_crn": "crn:v1:staging:public:cloud-object-storage:global:a/04e9bc47612523rr19ac22759cb69bebd:asd23df-6ada-45ff-bfe8-4343222", "storage_type": "bmcos_object_storage", "timestamp": "1715056266", "trial_plan": false, "username": "xyz@abc.com"}`)
				}))
			})
			It(`Invoke GetSalIntegration successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetSalIntegrationOptions model
				getSalIntegrationOptionsModel := new(watsonxdatav2.GetSalIntegrationOptions)
				getSalIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetSalIntegrationWithContext(ctx, getSalIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetSalIntegration(getSalIntegrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetSalIntegrationWithContext(ctx, getSalIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"category_id": "10e64285-bf37-4d5d-b759-bc6a46589234", "engine_id": "presto-01", "errors": [{"code": "unable_to_perform", "message": "Failed to process integration settings for watsonx.data instance"}], "governance_scope_id": "10e64285-bf37-4d5d-b759-bc6a46589234", "governance_scope_type": "category", "instance_id": "18b49d7a-9519-4539-8db5-ff080623c226", "status": "provisioning", "storage_resource_crn": "crn:v1:staging:public:cloud-object-storage:global:a/04e9bc47612523rr19ac22759cb69bebd:asd23df-6ada-45ff-bfe8-4343222", "storage_type": "bmcos_object_storage", "timestamp": "1715056266", "trial_plan": false, "username": "xyz@abc.com"}`)
				}))
			})
			It(`Invoke GetSalIntegration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetSalIntegration(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSalIntegrationOptions model
				getSalIntegrationOptionsModel := new(watsonxdatav2.GetSalIntegrationOptions)
				getSalIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetSalIntegration(getSalIntegrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetSalIntegration with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationOptions model
				getSalIntegrationOptionsModel := new(watsonxdatav2.GetSalIntegrationOptions)
				getSalIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetSalIntegration(getSalIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetSalIntegration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationOptions model
				getSalIntegrationOptionsModel := new(watsonxdatav2.GetSalIntegrationOptions)
				getSalIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetSalIntegration(getSalIntegrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSalIntegration(createSalIntegrationOptions *CreateSalIntegrationOptions) - Operation response error`, func() {
		createSalIntegrationPath := "/sal_integrations"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSalIntegrationPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateSalIntegration with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSalIntegrationOptions model
				createSalIntegrationOptionsModel := new(watsonxdatav2.CreateSalIntegrationOptions)
				createSalIntegrationOptionsModel.Apikey = core.StringPtr("12efd3raq")
				createSalIntegrationOptionsModel.EngineID = core.StringPtr("presto-01")
				createSalIntegrationOptionsModel.StorageResourceCrn = core.StringPtr("crn:v1:staging:public:cloud-object-storage:global:a/a7026b374f39f570d20984c1ac6ecf63:5778e94f-c8c7-46a8-9878-d5eeadb51161")
				createSalIntegrationOptionsModel.StorageType = core.StringPtr("bmcos_object_storage")
				createSalIntegrationOptionsModel.TrialPlan = core.BoolPtr(true)
				createSalIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSalIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateSalIntegration(createSalIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateSalIntegration(createSalIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSalIntegration(createSalIntegrationOptions *CreateSalIntegrationOptions)`, func() {
		createSalIntegrationPath := "/sal_integrations"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSalIntegrationPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"category_id": "10e64285-bf37-4d5d-b759-bc6a46589234", "engine_id": "presto-01", "errors": [{"code": "unable_to_perform", "message": "Failed to process integration settings for watsonx.data instance"}], "governance_scope_id": "10e64285-bf37-4d5d-b759-bc6a46589234", "governance_scope_type": "category", "instance_id": "18b49d7a-9519-4539-8db5-ff080623c226", "status": "provisioning", "storage_resource_crn": "crn:v1:staging:public:cloud-object-storage:global:a/04e9bc47612523rr19ac22759cb69bebd:asd23df-6ada-45ff-bfe8-4343222", "storage_type": "bmcos_object_storage", "timestamp": "1715056266", "trial_plan": false, "username": "xyz@abc.com"}`)
				}))
			})
			It(`Invoke CreateSalIntegration successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreateSalIntegrationOptions model
				createSalIntegrationOptionsModel := new(watsonxdatav2.CreateSalIntegrationOptions)
				createSalIntegrationOptionsModel.Apikey = core.StringPtr("12efd3raq")
				createSalIntegrationOptionsModel.EngineID = core.StringPtr("presto-01")
				createSalIntegrationOptionsModel.StorageResourceCrn = core.StringPtr("crn:v1:staging:public:cloud-object-storage:global:a/a7026b374f39f570d20984c1ac6ecf63:5778e94f-c8c7-46a8-9878-d5eeadb51161")
				createSalIntegrationOptionsModel.StorageType = core.StringPtr("bmcos_object_storage")
				createSalIntegrationOptionsModel.TrialPlan = core.BoolPtr(true)
				createSalIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSalIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateSalIntegrationWithContext(ctx, createSalIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateSalIntegration(createSalIntegrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateSalIntegrationWithContext(ctx, createSalIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSalIntegrationPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"category_id": "10e64285-bf37-4d5d-b759-bc6a46589234", "engine_id": "presto-01", "errors": [{"code": "unable_to_perform", "message": "Failed to process integration settings for watsonx.data instance"}], "governance_scope_id": "10e64285-bf37-4d5d-b759-bc6a46589234", "governance_scope_type": "category", "instance_id": "18b49d7a-9519-4539-8db5-ff080623c226", "status": "provisioning", "storage_resource_crn": "crn:v1:staging:public:cloud-object-storage:global:a/04e9bc47612523rr19ac22759cb69bebd:asd23df-6ada-45ff-bfe8-4343222", "storage_type": "bmcos_object_storage", "timestamp": "1715056266", "trial_plan": false, "username": "xyz@abc.com"}`)
				}))
			})
			It(`Invoke CreateSalIntegration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateSalIntegration(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreateSalIntegrationOptions model
				createSalIntegrationOptionsModel := new(watsonxdatav2.CreateSalIntegrationOptions)
				createSalIntegrationOptionsModel.Apikey = core.StringPtr("12efd3raq")
				createSalIntegrationOptionsModel.EngineID = core.StringPtr("presto-01")
				createSalIntegrationOptionsModel.StorageResourceCrn = core.StringPtr("crn:v1:staging:public:cloud-object-storage:global:a/a7026b374f39f570d20984c1ac6ecf63:5778e94f-c8c7-46a8-9878-d5eeadb51161")
				createSalIntegrationOptionsModel.StorageType = core.StringPtr("bmcos_object_storage")
				createSalIntegrationOptionsModel.TrialPlan = core.BoolPtr(true)
				createSalIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSalIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateSalIntegration(createSalIntegrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateSalIntegration with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSalIntegrationOptions model
				createSalIntegrationOptionsModel := new(watsonxdatav2.CreateSalIntegrationOptions)
				createSalIntegrationOptionsModel.Apikey = core.StringPtr("12efd3raq")
				createSalIntegrationOptionsModel.EngineID = core.StringPtr("presto-01")
				createSalIntegrationOptionsModel.StorageResourceCrn = core.StringPtr("crn:v1:staging:public:cloud-object-storage:global:a/a7026b374f39f570d20984c1ac6ecf63:5778e94f-c8c7-46a8-9878-d5eeadb51161")
				createSalIntegrationOptionsModel.StorageType = core.StringPtr("bmcos_object_storage")
				createSalIntegrationOptionsModel.TrialPlan = core.BoolPtr(true)
				createSalIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSalIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateSalIntegration(createSalIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateSalIntegrationOptions model with no property values
				createSalIntegrationOptionsModelNew := new(watsonxdatav2.CreateSalIntegrationOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateSalIntegration(createSalIntegrationOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateSalIntegration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSalIntegrationOptions model
				createSalIntegrationOptionsModel := new(watsonxdatav2.CreateSalIntegrationOptions)
				createSalIntegrationOptionsModel.Apikey = core.StringPtr("12efd3raq")
				createSalIntegrationOptionsModel.EngineID = core.StringPtr("presto-01")
				createSalIntegrationOptionsModel.StorageResourceCrn = core.StringPtr("crn:v1:staging:public:cloud-object-storage:global:a/a7026b374f39f570d20984c1ac6ecf63:5778e94f-c8c7-46a8-9878-d5eeadb51161")
				createSalIntegrationOptionsModel.StorageType = core.StringPtr("bmcos_object_storage")
				createSalIntegrationOptionsModel.TrialPlan = core.BoolPtr(true)
				createSalIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSalIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateSalIntegration(createSalIntegrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteSalIntegration(deleteSalIntegrationOptions *DeleteSalIntegrationOptions)`, func() {
		deleteSalIntegrationPath := "/sal_integrations"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteSalIntegrationPath))
					Expect(req.Method).To(Equal("DELETE"))

					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteSalIntegration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteSalIntegration(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteSalIntegrationOptions model
				deleteSalIntegrationOptionsModel := new(watsonxdatav2.DeleteSalIntegrationOptions)
				deleteSalIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteSalIntegration(deleteSalIntegrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteSalIntegration with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteSalIntegrationOptions model
				deleteSalIntegrationOptionsModel := new(watsonxdatav2.DeleteSalIntegrationOptions)
				deleteSalIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteSalIntegration(deleteSalIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateSalIntegration(updateSalIntegrationOptions *UpdateSalIntegrationOptions) - Operation response error`, func() {
		updateSalIntegrationPath := "/sal_integrations"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateSalIntegrationPath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateSalIntegration with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SalIntegrationPatch model
				salIntegrationPatchModel := new(watsonxdatav2.SalIntegrationPatch)
				salIntegrationPatchModel.Op = core.StringPtr("add")
				salIntegrationPatchModel.Path = core.StringPtr("storage")
				salIntegrationPatchModel.Value = core.StringPtr("new-apikey")
				salIntegrationPatchModelAsPatch, asPatchErr := salIntegrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSalIntegrationOptions model
				updateSalIntegrationOptionsModel := new(watsonxdatav2.UpdateSalIntegrationOptions)
				updateSalIntegrationOptionsModel.Body = salIntegrationPatchModelAsPatch
				updateSalIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSalIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdateSalIntegration(updateSalIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdateSalIntegration(updateSalIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateSalIntegration(updateSalIntegrationOptions *UpdateSalIntegrationOptions)`, func() {
		updateSalIntegrationPath := "/sal_integrations"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateSalIntegrationPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"category_id": "10e64285-bf37-4d5d-b759-bc6a46589234", "engine_id": "presto-01", "errors": [{"code": "unable_to_perform", "message": "Failed to process integration settings for watsonx.data instance"}], "governance_scope_id": "10e64285-bf37-4d5d-b759-bc6a46589234", "governance_scope_type": "category", "instance_id": "18b49d7a-9519-4539-8db5-ff080623c226", "status": "provisioning", "storage_resource_crn": "crn:v1:staging:public:cloud-object-storage:global:a/04e9bc47612523rr19ac22759cb69bebd:asd23df-6ada-45ff-bfe8-4343222", "storage_type": "bmcos_object_storage", "timestamp": "1715056266", "trial_plan": false, "username": "xyz@abc.com"}`)
				}))
			})
			It(`Invoke UpdateSalIntegration successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the SalIntegrationPatch model
				salIntegrationPatchModel := new(watsonxdatav2.SalIntegrationPatch)
				salIntegrationPatchModel.Op = core.StringPtr("add")
				salIntegrationPatchModel.Path = core.StringPtr("storage")
				salIntegrationPatchModel.Value = core.StringPtr("new-apikey")
				salIntegrationPatchModelAsPatch, asPatchErr := salIntegrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSalIntegrationOptions model
				updateSalIntegrationOptionsModel := new(watsonxdatav2.UpdateSalIntegrationOptions)
				updateSalIntegrationOptionsModel.Body = salIntegrationPatchModelAsPatch
				updateSalIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSalIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdateSalIntegrationWithContext(ctx, updateSalIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdateSalIntegration(updateSalIntegrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdateSalIntegrationWithContext(ctx, updateSalIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateSalIntegrationPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"category_id": "10e64285-bf37-4d5d-b759-bc6a46589234", "engine_id": "presto-01", "errors": [{"code": "unable_to_perform", "message": "Failed to process integration settings for watsonx.data instance"}], "governance_scope_id": "10e64285-bf37-4d5d-b759-bc6a46589234", "governance_scope_type": "category", "instance_id": "18b49d7a-9519-4539-8db5-ff080623c226", "status": "provisioning", "storage_resource_crn": "crn:v1:staging:public:cloud-object-storage:global:a/04e9bc47612523rr19ac22759cb69bebd:asd23df-6ada-45ff-bfe8-4343222", "storage_type": "bmcos_object_storage", "timestamp": "1715056266", "trial_plan": false, "username": "xyz@abc.com"}`)
				}))
			})
			It(`Invoke UpdateSalIntegration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdateSalIntegration(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the SalIntegrationPatch model
				salIntegrationPatchModel := new(watsonxdatav2.SalIntegrationPatch)
				salIntegrationPatchModel.Op = core.StringPtr("add")
				salIntegrationPatchModel.Path = core.StringPtr("storage")
				salIntegrationPatchModel.Value = core.StringPtr("new-apikey")
				salIntegrationPatchModelAsPatch, asPatchErr := salIntegrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSalIntegrationOptions model
				updateSalIntegrationOptionsModel := new(watsonxdatav2.UpdateSalIntegrationOptions)
				updateSalIntegrationOptionsModel.Body = salIntegrationPatchModelAsPatch
				updateSalIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSalIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdateSalIntegration(updateSalIntegrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateSalIntegration with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SalIntegrationPatch model
				salIntegrationPatchModel := new(watsonxdatav2.SalIntegrationPatch)
				salIntegrationPatchModel.Op = core.StringPtr("add")
				salIntegrationPatchModel.Path = core.StringPtr("storage")
				salIntegrationPatchModel.Value = core.StringPtr("new-apikey")
				salIntegrationPatchModelAsPatch, asPatchErr := salIntegrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSalIntegrationOptions model
				updateSalIntegrationOptionsModel := new(watsonxdatav2.UpdateSalIntegrationOptions)
				updateSalIntegrationOptionsModel.Body = salIntegrationPatchModelAsPatch
				updateSalIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSalIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdateSalIntegration(updateSalIntegrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateSalIntegrationOptions model with no property values
				updateSalIntegrationOptionsModelNew := new(watsonxdatav2.UpdateSalIntegrationOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdateSalIntegration(updateSalIntegrationOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateSalIntegration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SalIntegrationPatch model
				salIntegrationPatchModel := new(watsonxdatav2.SalIntegrationPatch)
				salIntegrationPatchModel.Op = core.StringPtr("add")
				salIntegrationPatchModel.Path = core.StringPtr("storage")
				salIntegrationPatchModel.Value = core.StringPtr("new-apikey")
				salIntegrationPatchModelAsPatch, asPatchErr := salIntegrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSalIntegrationOptions model
				updateSalIntegrationOptionsModel := new(watsonxdatav2.UpdateSalIntegrationOptions)
				updateSalIntegrationOptionsModel.Body = salIntegrationPatchModelAsPatch
				updateSalIntegrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSalIntegrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdateSalIntegration(updateSalIntegrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSalIntegrationEnrichment(createSalIntegrationEnrichmentOptions *CreateSalIntegrationEnrichmentOptions)`, func() {
		createSalIntegrationEnrichmentPath := "/sal_integrations/enrichment"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSalIntegrationEnrichmentPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke CreateSalIntegrationEnrichment successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.CreateSalIntegrationEnrichment(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the EnrichmentObj model
				enrichmentObjModel := new(watsonxdatav2.EnrichmentObj)
				enrichmentObjModel.Catalog = core.StringPtr("iceberg_data")
				enrichmentObjModel.Operation = core.StringPtr("create")
				enrichmentObjModel.Schema = core.StringPtr("testString")
				enrichmentObjModel.Tables = []string{"testString"}

				// Construct an instance of the CreateSalIntegrationEnrichmentOptions model
				createSalIntegrationEnrichmentOptionsModel := new(watsonxdatav2.CreateSalIntegrationEnrichmentOptions)
				createSalIntegrationEnrichmentOptionsModel.Changes = enrichmentObjModel
				createSalIntegrationEnrichmentOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSalIntegrationEnrichmentOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.CreateSalIntegrationEnrichment(createSalIntegrationEnrichmentOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke CreateSalIntegrationEnrichment with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the EnrichmentObj model
				enrichmentObjModel := new(watsonxdatav2.EnrichmentObj)
				enrichmentObjModel.Catalog = core.StringPtr("iceberg_data")
				enrichmentObjModel.Operation = core.StringPtr("create")
				enrichmentObjModel.Schema = core.StringPtr("testString")
				enrichmentObjModel.Tables = []string{"testString"}

				// Construct an instance of the CreateSalIntegrationEnrichmentOptions model
				createSalIntegrationEnrichmentOptionsModel := new(watsonxdatav2.CreateSalIntegrationEnrichmentOptions)
				createSalIntegrationEnrichmentOptionsModel.Changes = enrichmentObjModel
				createSalIntegrationEnrichmentOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSalIntegrationEnrichmentOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.CreateSalIntegrationEnrichment(createSalIntegrationEnrichmentOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegrationEnrichmentAssets(getSalIntegrationEnrichmentAssetsOptions *GetSalIntegrationEnrichmentAssetsOptions) - Operation response error`, func() {
		getSalIntegrationEnrichmentAssetsPath := "/sal_integrations/enrichment_assets"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationEnrichmentAssetsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["project_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentAssets with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentAssetsOptions model
				getSalIntegrationEnrichmentAssetsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentAssetsOptions)
				getSalIntegrationEnrichmentAssetsOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentAssetsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentAssetsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentAssets(getSalIntegrationEnrichmentAssetsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetSalIntegrationEnrichmentAssets(getSalIntegrationEnrichmentAssetsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegrationEnrichmentAssets(getSalIntegrationEnrichmentAssetsOptions *GetSalIntegrationEnrichmentAssetsOptions)`, func() {
		getSalIntegrationEnrichmentAssetsPath := "/sal_integrations/enrichment_assets"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationEnrichmentAssetsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["project_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"enrichment_asset": {"asset_attributes": ["AssetAttributes"], "asset_id": "ee0383b9-dcab-4c1a-b03d-bf521837b6ed", "asset_name": "newtable", "resource_key": "0000:0000:0000:0000:0000:FFFF:9EB0:04E2|31134|:/iceberg_data/new_schema/sampletable", "schema_name": "sampleschema"}}`)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentAssets successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetSalIntegrationEnrichmentAssetsOptions model
				getSalIntegrationEnrichmentAssetsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentAssetsOptions)
				getSalIntegrationEnrichmentAssetsOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentAssetsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentAssetsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetSalIntegrationEnrichmentAssetsWithContext(ctx, getSalIntegrationEnrichmentAssetsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentAssets(getSalIntegrationEnrichmentAssetsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetSalIntegrationEnrichmentAssetsWithContext(ctx, getSalIntegrationEnrichmentAssetsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationEnrichmentAssetsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["project_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"enrichment_asset": {"asset_attributes": ["AssetAttributes"], "asset_id": "ee0383b9-dcab-4c1a-b03d-bf521837b6ed", "asset_name": "newtable", "resource_key": "0000:0000:0000:0000:0000:FFFF:9EB0:04E2|31134|:/iceberg_data/new_schema/sampletable", "schema_name": "sampleschema"}}`)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentAssets successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentAssets(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentAssetsOptions model
				getSalIntegrationEnrichmentAssetsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentAssetsOptions)
				getSalIntegrationEnrichmentAssetsOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentAssetsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentAssetsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetSalIntegrationEnrichmentAssets(getSalIntegrationEnrichmentAssetsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetSalIntegrationEnrichmentAssets with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentAssetsOptions model
				getSalIntegrationEnrichmentAssetsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentAssetsOptions)
				getSalIntegrationEnrichmentAssetsOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentAssetsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentAssetsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentAssets(getSalIntegrationEnrichmentAssetsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentAssets successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentAssetsOptions model
				getSalIntegrationEnrichmentAssetsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentAssetsOptions)
				getSalIntegrationEnrichmentAssetsOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentAssetsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentAssetsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentAssets(getSalIntegrationEnrichmentAssetsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegrationEnrichmentDataAsset(getSalIntegrationEnrichmentDataAssetOptions *GetSalIntegrationEnrichmentDataAssetOptions) - Operation response error`, func() {
		getSalIntegrationEnrichmentDataAssetPath := "/sal_integrations/enrichment_data_asset"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationEnrichmentDataAssetPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["project_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["asset_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentDataAsset with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentDataAssetOptions model
				getSalIntegrationEnrichmentDataAssetOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentDataAssetOptions)
				getSalIntegrationEnrichmentDataAssetOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentDataAssetOptionsModel.AssetID = core.StringPtr("testString")
				getSalIntegrationEnrichmentDataAssetOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentDataAssetOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentDataAsset(getSalIntegrationEnrichmentDataAssetOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetSalIntegrationEnrichmentDataAsset(getSalIntegrationEnrichmentDataAssetOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegrationEnrichmentDataAsset(getSalIntegrationEnrichmentDataAssetOptions *GetSalIntegrationEnrichmentDataAssetOptions)`, func() {
		getSalIntegrationEnrichmentDataAssetPath := "/sal_integrations/enrichment_data_asset"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationEnrichmentDataAssetPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["project_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["asset_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"asset": "{}"}`)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentDataAsset successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetSalIntegrationEnrichmentDataAssetOptions model
				getSalIntegrationEnrichmentDataAssetOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentDataAssetOptions)
				getSalIntegrationEnrichmentDataAssetOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentDataAssetOptionsModel.AssetID = core.StringPtr("testString")
				getSalIntegrationEnrichmentDataAssetOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentDataAssetOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetSalIntegrationEnrichmentDataAssetWithContext(ctx, getSalIntegrationEnrichmentDataAssetOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentDataAsset(getSalIntegrationEnrichmentDataAssetOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetSalIntegrationEnrichmentDataAssetWithContext(ctx, getSalIntegrationEnrichmentDataAssetOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationEnrichmentDataAssetPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["project_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["asset_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"asset": "{}"}`)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentDataAsset successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentDataAsset(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentDataAssetOptions model
				getSalIntegrationEnrichmentDataAssetOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentDataAssetOptions)
				getSalIntegrationEnrichmentDataAssetOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentDataAssetOptionsModel.AssetID = core.StringPtr("testString")
				getSalIntegrationEnrichmentDataAssetOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentDataAssetOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetSalIntegrationEnrichmentDataAsset(getSalIntegrationEnrichmentDataAssetOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetSalIntegrationEnrichmentDataAsset with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentDataAssetOptions model
				getSalIntegrationEnrichmentDataAssetOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentDataAssetOptions)
				getSalIntegrationEnrichmentDataAssetOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentDataAssetOptionsModel.AssetID = core.StringPtr("testString")
				getSalIntegrationEnrichmentDataAssetOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentDataAssetOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentDataAsset(getSalIntegrationEnrichmentDataAssetOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentDataAsset successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentDataAssetOptions model
				getSalIntegrationEnrichmentDataAssetOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentDataAssetOptions)
				getSalIntegrationEnrichmentDataAssetOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentDataAssetOptionsModel.AssetID = core.StringPtr("testString")
				getSalIntegrationEnrichmentDataAssetOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentDataAssetOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentDataAsset(getSalIntegrationEnrichmentDataAssetOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegrationEnrichmentJobRunLogs(getSalIntegrationEnrichmentJobRunLogsOptions *GetSalIntegrationEnrichmentJobRunLogsOptions) - Operation response error`, func() {
		getSalIntegrationEnrichmentJobRunLogsPath := "/sal_integrations/enrichment_job_run_logs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationEnrichmentJobRunLogsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["job_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["job_run_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["project_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentJobRunLogs with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentJobRunLogsOptions model
				getSalIntegrationEnrichmentJobRunLogsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentJobRunLogsOptions)
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.JobID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.JobRunID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentJobRunLogs(getSalIntegrationEnrichmentJobRunLogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetSalIntegrationEnrichmentJobRunLogs(getSalIntegrationEnrichmentJobRunLogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegrationEnrichmentJobRunLogs(getSalIntegrationEnrichmentJobRunLogsOptions *GetSalIntegrationEnrichmentJobRunLogsOptions)`, func() {
		getSalIntegrationEnrichmentJobRunLogsPath := "/sal_integrations/enrichment_job_run_logs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationEnrichmentJobRunLogsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["job_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["job_run_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["project_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"results": ["Results"], "total_count": 12}`)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentJobRunLogs successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetSalIntegrationEnrichmentJobRunLogsOptions model
				getSalIntegrationEnrichmentJobRunLogsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentJobRunLogsOptions)
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.JobID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.JobRunID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetSalIntegrationEnrichmentJobRunLogsWithContext(ctx, getSalIntegrationEnrichmentJobRunLogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentJobRunLogs(getSalIntegrationEnrichmentJobRunLogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetSalIntegrationEnrichmentJobRunLogsWithContext(ctx, getSalIntegrationEnrichmentJobRunLogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationEnrichmentJobRunLogsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["job_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["job_run_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["project_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"results": ["Results"], "total_count": 12}`)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentJobRunLogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentJobRunLogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentJobRunLogsOptions model
				getSalIntegrationEnrichmentJobRunLogsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentJobRunLogsOptions)
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.JobID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.JobRunID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetSalIntegrationEnrichmentJobRunLogs(getSalIntegrationEnrichmentJobRunLogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetSalIntegrationEnrichmentJobRunLogs with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentJobRunLogsOptions model
				getSalIntegrationEnrichmentJobRunLogsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentJobRunLogsOptions)
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.JobID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.JobRunID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentJobRunLogs(getSalIntegrationEnrichmentJobRunLogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentJobRunLogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentJobRunLogsOptions model
				getSalIntegrationEnrichmentJobRunLogsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentJobRunLogsOptions)
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.JobID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.JobRunID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentJobRunLogs(getSalIntegrationEnrichmentJobRunLogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegrationEnrichmentJobRuns(getSalIntegrationEnrichmentJobRunsOptions *GetSalIntegrationEnrichmentJobRunsOptions) - Operation response error`, func() {
		getSalIntegrationEnrichmentJobRunsPath := "/sal_integrations/enrichment_job_runs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationEnrichmentJobRunsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["job_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["project_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentJobRuns with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentJobRunsOptions model
				getSalIntegrationEnrichmentJobRunsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentJobRunsOptions)
				getSalIntegrationEnrichmentJobRunsOptionsModel.JobID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunsOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentJobRuns(getSalIntegrationEnrichmentJobRunsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetSalIntegrationEnrichmentJobRuns(getSalIntegrationEnrichmentJobRunsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegrationEnrichmentJobRuns(getSalIntegrationEnrichmentJobRunsOptions *GetSalIntegrationEnrichmentJobRunsOptions)`, func() {
		getSalIntegrationEnrichmentJobRunsPath := "/sal_integrations/enrichment_job_runs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationEnrichmentJobRunsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["job_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["project_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": "{}"}`)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentJobRuns successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetSalIntegrationEnrichmentJobRunsOptions model
				getSalIntegrationEnrichmentJobRunsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentJobRunsOptions)
				getSalIntegrationEnrichmentJobRunsOptionsModel.JobID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunsOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetSalIntegrationEnrichmentJobRunsWithContext(ctx, getSalIntegrationEnrichmentJobRunsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentJobRuns(getSalIntegrationEnrichmentJobRunsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetSalIntegrationEnrichmentJobRunsWithContext(ctx, getSalIntegrationEnrichmentJobRunsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationEnrichmentJobRunsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["job_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["project_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": "{}"}`)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentJobRuns successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentJobRuns(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentJobRunsOptions model
				getSalIntegrationEnrichmentJobRunsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentJobRunsOptions)
				getSalIntegrationEnrichmentJobRunsOptionsModel.JobID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunsOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetSalIntegrationEnrichmentJobRuns(getSalIntegrationEnrichmentJobRunsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetSalIntegrationEnrichmentJobRuns with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentJobRunsOptions model
				getSalIntegrationEnrichmentJobRunsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentJobRunsOptions)
				getSalIntegrationEnrichmentJobRunsOptionsModel.JobID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunsOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentJobRuns(getSalIntegrationEnrichmentJobRunsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentJobRuns successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentJobRunsOptions model
				getSalIntegrationEnrichmentJobRunsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentJobRunsOptions)
				getSalIntegrationEnrichmentJobRunsOptionsModel.JobID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunsOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobRunsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentJobRuns(getSalIntegrationEnrichmentJobRunsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegrationEnrichmentJobs(getSalIntegrationEnrichmentJobsOptions *GetSalIntegrationEnrichmentJobsOptions) - Operation response error`, func() {
		getSalIntegrationEnrichmentJobsPath := "/sal_integrations/enrichment_jobs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationEnrichmentJobsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["wkc_project_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentJobs with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentJobsOptions model
				getSalIntegrationEnrichmentJobsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentJobsOptions)
				getSalIntegrationEnrichmentJobsOptionsModel.WkcProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentJobs(getSalIntegrationEnrichmentJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetSalIntegrationEnrichmentJobs(getSalIntegrationEnrichmentJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegrationEnrichmentJobs(getSalIntegrationEnrichmentJobsOptions *GetSalIntegrationEnrichmentJobsOptions)`, func() {
		getSalIntegrationEnrichmentJobsPath := "/sal_integrations/enrichment_jobs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationEnrichmentJobsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["wkc_project_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"jobs": {"results": [{"entity": {"job": {"asset_ref": "8688a3b6-a946-499e-a93c-b7d099db80dd", "asset_ref_type": "metadata_enrichment_area", "configuration": {"env_type": "EnvType", "env_variables": ["EnvVariables"]}, "enable_notifications": false, "future_scheduled_runs": ["FutureScheduledRuns"], "last_run_initiator": "deprecated field", "last_run_status": "deprecated field", "last_run_status_timestamp": 0, "last_run_time": "deprecated field", "project_name": "SAL Mapping /iceberg_data/new_schema 9aae5be3-87cf-4c31-b17d-9256ab42c14e", "schedule_creator_id": "ScheduleCreatorID", "schedule_id": "ScheduleID", "schedule_info": {"frequency": "Frequency"}, "task_credentials_support": {"account_id": "04e9bc4761254b719ac22759cb69bebd", "task_credentials_enabled": true, "user_id": "IBMid-55000832RK"}}}, "metadata": {"asset_id": "ea73ce44-8aa0-4c75-bd69-6ca7074a1030", "name": "SAL_MDE job", "owner_id": "IBMid-55000832RK", "version": 0}}], "total_rows": 1}}`)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentJobs successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetSalIntegrationEnrichmentJobsOptions model
				getSalIntegrationEnrichmentJobsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentJobsOptions)
				getSalIntegrationEnrichmentJobsOptionsModel.WkcProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetSalIntegrationEnrichmentJobsWithContext(ctx, getSalIntegrationEnrichmentJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentJobs(getSalIntegrationEnrichmentJobsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetSalIntegrationEnrichmentJobsWithContext(ctx, getSalIntegrationEnrichmentJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationEnrichmentJobsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["wkc_project_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"jobs": {"results": [{"entity": {"job": {"asset_ref": "8688a3b6-a946-499e-a93c-b7d099db80dd", "asset_ref_type": "metadata_enrichment_area", "configuration": {"env_type": "EnvType", "env_variables": ["EnvVariables"]}, "enable_notifications": false, "future_scheduled_runs": ["FutureScheduledRuns"], "last_run_initiator": "deprecated field", "last_run_status": "deprecated field", "last_run_status_timestamp": 0, "last_run_time": "deprecated field", "project_name": "SAL Mapping /iceberg_data/new_schema 9aae5be3-87cf-4c31-b17d-9256ab42c14e", "schedule_creator_id": "ScheduleCreatorID", "schedule_id": "ScheduleID", "schedule_info": {"frequency": "Frequency"}, "task_credentials_support": {"account_id": "04e9bc4761254b719ac22759cb69bebd", "task_credentials_enabled": true, "user_id": "IBMid-55000832RK"}}}, "metadata": {"asset_id": "ea73ce44-8aa0-4c75-bd69-6ca7074a1030", "name": "SAL_MDE job", "owner_id": "IBMid-55000832RK", "version": 0}}], "total_rows": 1}}`)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentJobs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentJobs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentJobsOptions model
				getSalIntegrationEnrichmentJobsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentJobsOptions)
				getSalIntegrationEnrichmentJobsOptionsModel.WkcProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetSalIntegrationEnrichmentJobs(getSalIntegrationEnrichmentJobsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetSalIntegrationEnrichmentJobs with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentJobsOptions model
				getSalIntegrationEnrichmentJobsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentJobsOptions)
				getSalIntegrationEnrichmentJobsOptionsModel.WkcProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentJobs(getSalIntegrationEnrichmentJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentJobs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentJobsOptions model
				getSalIntegrationEnrichmentJobsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentJobsOptions)
				getSalIntegrationEnrichmentJobsOptionsModel.WkcProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentJobs(getSalIntegrationEnrichmentJobsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegrationGlossaryTerms(getSalIntegrationGlossaryTermsOptions *GetSalIntegrationGlossaryTermsOptions) - Operation response error`, func() {
		getSalIntegrationGlossaryTermsPath := "/sal_integrations/glossary_terms"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationGlossaryTermsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetSalIntegrationGlossaryTerms with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationGlossaryTermsOptions model
				getSalIntegrationGlossaryTermsOptionsModel := new(watsonxdatav2.GetSalIntegrationGlossaryTermsOptions)
				getSalIntegrationGlossaryTermsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationGlossaryTermsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetSalIntegrationGlossaryTerms(getSalIntegrationGlossaryTermsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetSalIntegrationGlossaryTerms(getSalIntegrationGlossaryTermsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegrationGlossaryTerms(getSalIntegrationGlossaryTermsOptions *GetSalIntegrationGlossaryTermsOptions)`, func() {
		getSalIntegrationGlossaryTermsPath := "/sal_integrations/glossary_terms"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationGlossaryTermsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"glossary_term": {"description": "First Name", "name": "Name"}}`)
				}))
			})
			It(`Invoke GetSalIntegrationGlossaryTerms successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetSalIntegrationGlossaryTermsOptions model
				getSalIntegrationGlossaryTermsOptionsModel := new(watsonxdatav2.GetSalIntegrationGlossaryTermsOptions)
				getSalIntegrationGlossaryTermsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationGlossaryTermsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetSalIntegrationGlossaryTermsWithContext(ctx, getSalIntegrationGlossaryTermsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetSalIntegrationGlossaryTerms(getSalIntegrationGlossaryTermsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetSalIntegrationGlossaryTermsWithContext(ctx, getSalIntegrationGlossaryTermsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationGlossaryTermsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"glossary_term": {"description": "First Name", "name": "Name"}}`)
				}))
			})
			It(`Invoke GetSalIntegrationGlossaryTerms successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetSalIntegrationGlossaryTerms(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSalIntegrationGlossaryTermsOptions model
				getSalIntegrationGlossaryTermsOptionsModel := new(watsonxdatav2.GetSalIntegrationGlossaryTermsOptions)
				getSalIntegrationGlossaryTermsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationGlossaryTermsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetSalIntegrationGlossaryTerms(getSalIntegrationGlossaryTermsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetSalIntegrationGlossaryTerms with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationGlossaryTermsOptions model
				getSalIntegrationGlossaryTermsOptionsModel := new(watsonxdatav2.GetSalIntegrationGlossaryTermsOptions)
				getSalIntegrationGlossaryTermsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationGlossaryTermsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetSalIntegrationGlossaryTerms(getSalIntegrationGlossaryTermsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetSalIntegrationGlossaryTerms successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationGlossaryTermsOptions model
				getSalIntegrationGlossaryTermsOptionsModel := new(watsonxdatav2.GetSalIntegrationGlossaryTermsOptions)
				getSalIntegrationGlossaryTermsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationGlossaryTermsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetSalIntegrationGlossaryTerms(getSalIntegrationGlossaryTermsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegrationMappings(getSalIntegrationMappingsOptions *GetSalIntegrationMappingsOptions) - Operation response error`, func() {
		getSalIntegrationMappingsPath := "/sal_integrations/mappings"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationMappingsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["catalog_name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["schema_name"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetSalIntegrationMappings with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationMappingsOptions model
				getSalIntegrationMappingsOptionsModel := new(watsonxdatav2.GetSalIntegrationMappingsOptions)
				getSalIntegrationMappingsOptionsModel.CatalogName = core.StringPtr("testString")
				getSalIntegrationMappingsOptionsModel.SchemaName = core.StringPtr("testString")
				getSalIntegrationMappingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationMappingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetSalIntegrationMappings(getSalIntegrationMappingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetSalIntegrationMappings(getSalIntegrationMappingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegrationMappings(getSalIntegrationMappingsOptions *GetSalIntegrationMappingsOptions)`, func() {
		getSalIntegrationMappingsPath := "/sal_integrations/mappings"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationMappingsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["catalog_name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["schema_name"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"wkc_catalog_id": "iceberg_data", "wkc_project_id": "create"}`)
				}))
			})
			It(`Invoke GetSalIntegrationMappings successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetSalIntegrationMappingsOptions model
				getSalIntegrationMappingsOptionsModel := new(watsonxdatav2.GetSalIntegrationMappingsOptions)
				getSalIntegrationMappingsOptionsModel.CatalogName = core.StringPtr("testString")
				getSalIntegrationMappingsOptionsModel.SchemaName = core.StringPtr("testString")
				getSalIntegrationMappingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationMappingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetSalIntegrationMappingsWithContext(ctx, getSalIntegrationMappingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetSalIntegrationMappings(getSalIntegrationMappingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetSalIntegrationMappingsWithContext(ctx, getSalIntegrationMappingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationMappingsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["catalog_name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["schema_name"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"wkc_catalog_id": "iceberg_data", "wkc_project_id": "create"}`)
				}))
			})
			It(`Invoke GetSalIntegrationMappings successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetSalIntegrationMappings(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSalIntegrationMappingsOptions model
				getSalIntegrationMappingsOptionsModel := new(watsonxdatav2.GetSalIntegrationMappingsOptions)
				getSalIntegrationMappingsOptionsModel.CatalogName = core.StringPtr("testString")
				getSalIntegrationMappingsOptionsModel.SchemaName = core.StringPtr("testString")
				getSalIntegrationMappingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationMappingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetSalIntegrationMappings(getSalIntegrationMappingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetSalIntegrationMappings with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationMappingsOptions model
				getSalIntegrationMappingsOptionsModel := new(watsonxdatav2.GetSalIntegrationMappingsOptions)
				getSalIntegrationMappingsOptionsModel.CatalogName = core.StringPtr("testString")
				getSalIntegrationMappingsOptionsModel.SchemaName = core.StringPtr("testString")
				getSalIntegrationMappingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationMappingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetSalIntegrationMappings(getSalIntegrationMappingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetSalIntegrationMappingsOptions model with no property values
				getSalIntegrationMappingsOptionsModelNew := new(watsonxdatav2.GetSalIntegrationMappingsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetSalIntegrationMappings(getSalIntegrationMappingsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetSalIntegrationMappings successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationMappingsOptions model
				getSalIntegrationMappingsOptionsModel := new(watsonxdatav2.GetSalIntegrationMappingsOptions)
				getSalIntegrationMappingsOptionsModel.CatalogName = core.StringPtr("testString")
				getSalIntegrationMappingsOptionsModel.SchemaName = core.StringPtr("testString")
				getSalIntegrationMappingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationMappingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetSalIntegrationMappings(getSalIntegrationMappingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegrationEnrichmentGlobalSettings(getSalIntegrationEnrichmentGlobalSettingsOptions *GetSalIntegrationEnrichmentGlobalSettingsOptions) - Operation response error`, func() {
		getSalIntegrationEnrichmentGlobalSettingsPath := "/sal_integrations/metadata_enrichment_global_settings"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationEnrichmentGlobalSettingsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentGlobalSettings with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentGlobalSettingsOptions model
				getSalIntegrationEnrichmentGlobalSettingsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentGlobalSettingsOptions)
				getSalIntegrationEnrichmentGlobalSettingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentGlobalSettingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentGlobalSettings(getSalIntegrationEnrichmentGlobalSettingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetSalIntegrationEnrichmentGlobalSettings(getSalIntegrationEnrichmentGlobalSettingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegrationEnrichmentGlobalSettings(getSalIntegrationEnrichmentGlobalSettingsOptions *GetSalIntegrationEnrichmentGlobalSettingsOptions)`, func() {
		getSalIntegrationEnrichmentGlobalSettingsPath := "/sal_integrations/metadata_enrichment_global_settings"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationEnrichmentGlobalSettingsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"semantic_expansion": {"description_generation": true, "description_generation_configuration": {"assignment_threshold": 0.14, "suggestion_threshold": 0.9}, "name_expansion": true, "name_expansion_configuration": {"assignment_threshold": 0.1, "suggestion_threshold": 0.1}}, "term_assignment": {"class_based_assignments": false, "evaluate_negative_assignments": false, "llm_based_assignments": false, "ml_based_assignments_custom": false, "ml_based_assignments_default": false, "name_matching": false, "term_assignment_threshold": 0.3, "term_suggestion_threshold": 0.4}}`)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentGlobalSettings successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetSalIntegrationEnrichmentGlobalSettingsOptions model
				getSalIntegrationEnrichmentGlobalSettingsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentGlobalSettingsOptions)
				getSalIntegrationEnrichmentGlobalSettingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentGlobalSettingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetSalIntegrationEnrichmentGlobalSettingsWithContext(ctx, getSalIntegrationEnrichmentGlobalSettingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentGlobalSettings(getSalIntegrationEnrichmentGlobalSettingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetSalIntegrationEnrichmentGlobalSettingsWithContext(ctx, getSalIntegrationEnrichmentGlobalSettingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationEnrichmentGlobalSettingsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"semantic_expansion": {"description_generation": true, "description_generation_configuration": {"assignment_threshold": 0.14, "suggestion_threshold": 0.9}, "name_expansion": true, "name_expansion_configuration": {"assignment_threshold": 0.1, "suggestion_threshold": 0.1}}, "term_assignment": {"class_based_assignments": false, "evaluate_negative_assignments": false, "llm_based_assignments": false, "ml_based_assignments_custom": false, "ml_based_assignments_default": false, "name_matching": false, "term_assignment_threshold": 0.3, "term_suggestion_threshold": 0.4}}`)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentGlobalSettings successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentGlobalSettings(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentGlobalSettingsOptions model
				getSalIntegrationEnrichmentGlobalSettingsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentGlobalSettingsOptions)
				getSalIntegrationEnrichmentGlobalSettingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentGlobalSettingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetSalIntegrationEnrichmentGlobalSettings(getSalIntegrationEnrichmentGlobalSettingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetSalIntegrationEnrichmentGlobalSettings with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentGlobalSettingsOptions model
				getSalIntegrationEnrichmentGlobalSettingsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentGlobalSettingsOptions)
				getSalIntegrationEnrichmentGlobalSettingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentGlobalSettingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentGlobalSettings(getSalIntegrationEnrichmentGlobalSettingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentGlobalSettings successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentGlobalSettingsOptions model
				getSalIntegrationEnrichmentGlobalSettingsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentGlobalSettingsOptions)
				getSalIntegrationEnrichmentGlobalSettingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentGlobalSettingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentGlobalSettings(getSalIntegrationEnrichmentGlobalSettingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSalIntegrationEnrichmentGlobalSettings(createSalIntegrationEnrichmentGlobalSettingsOptions *CreateSalIntegrationEnrichmentGlobalSettingsOptions) - Operation response error`, func() {
		createSalIntegrationEnrichmentGlobalSettingsPath := "/sal_integrations/metadata_enrichment_global_settings"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSalIntegrationEnrichmentGlobalSettingsPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateSalIntegrationEnrichmentGlobalSettings with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration model
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration)
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.AssignmentThreshold = core.Float64Ptr(float64(0.14))
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.SuggestionThreshold = core.Float64Ptr(float64(0.9))

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration model
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration)
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.AssignmentThreshold = core.Float64Ptr(float64(0.1))
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.SuggestionThreshold = core.Float64Ptr(float64(0.1))

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansion model
				salIntegrationEnrichmentSettingsSemanticExpansionModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansion)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGeneration = core.BoolPtr(true)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGenerationConfiguration = salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel
				salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansion = core.BoolPtr(true)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansionConfiguration = salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel

				// Construct an instance of the SalIntegrationEnrichmentSettingsTermAssignment model
				salIntegrationEnrichmentSettingsTermAssignmentModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsTermAssignment)
				salIntegrationEnrichmentSettingsTermAssignmentModel.ClassBasedAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.EvaluateNegativeAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.LlmBasedAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsCustom = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsDefault = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.NameMatching = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.TermAssignmentThreshold = core.Float64Ptr(float64(0.3))
				salIntegrationEnrichmentSettingsTermAssignmentModel.TermSuggestionThreshold = core.Float64Ptr(float64(0.4))

				// Construct an instance of the CreateSalIntegrationEnrichmentGlobalSettingsOptions model
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel := new(watsonxdatav2.CreateSalIntegrationEnrichmentGlobalSettingsOptions)
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.SemanticExpansion = salIntegrationEnrichmentSettingsSemanticExpansionModel
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.TermAssignment = salIntegrationEnrichmentSettingsTermAssignmentModel
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateSalIntegrationEnrichmentGlobalSettings(createSalIntegrationEnrichmentGlobalSettingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateSalIntegrationEnrichmentGlobalSettings(createSalIntegrationEnrichmentGlobalSettingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSalIntegrationEnrichmentGlobalSettings(createSalIntegrationEnrichmentGlobalSettingsOptions *CreateSalIntegrationEnrichmentGlobalSettingsOptions)`, func() {
		createSalIntegrationEnrichmentGlobalSettingsPath := "/sal_integrations/metadata_enrichment_global_settings"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSalIntegrationEnrichmentGlobalSettingsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"semantic_expansion": {"description_generation": true, "description_generation_configuration": {"assignment_threshold": 0.14, "suggestion_threshold": 0.9}, "name_expansion": true, "name_expansion_configuration": {"assignment_threshold": 0.1, "suggestion_threshold": 0.1}}, "term_assignment": {"class_based_assignments": false, "evaluate_negative_assignments": false, "llm_based_assignments": false, "ml_based_assignments_custom": false, "ml_based_assignments_default": false, "name_matching": false, "term_assignment_threshold": 0.3, "term_suggestion_threshold": 0.4}}`)
				}))
			})
			It(`Invoke CreateSalIntegrationEnrichmentGlobalSettings successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration model
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration)
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.AssignmentThreshold = core.Float64Ptr(float64(0.14))
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.SuggestionThreshold = core.Float64Ptr(float64(0.9))

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration model
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration)
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.AssignmentThreshold = core.Float64Ptr(float64(0.1))
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.SuggestionThreshold = core.Float64Ptr(float64(0.1))

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansion model
				salIntegrationEnrichmentSettingsSemanticExpansionModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansion)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGeneration = core.BoolPtr(true)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGenerationConfiguration = salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel
				salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansion = core.BoolPtr(true)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansionConfiguration = salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel

				// Construct an instance of the SalIntegrationEnrichmentSettingsTermAssignment model
				salIntegrationEnrichmentSettingsTermAssignmentModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsTermAssignment)
				salIntegrationEnrichmentSettingsTermAssignmentModel.ClassBasedAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.EvaluateNegativeAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.LlmBasedAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsCustom = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsDefault = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.NameMatching = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.TermAssignmentThreshold = core.Float64Ptr(float64(0.3))
				salIntegrationEnrichmentSettingsTermAssignmentModel.TermSuggestionThreshold = core.Float64Ptr(float64(0.4))

				// Construct an instance of the CreateSalIntegrationEnrichmentGlobalSettingsOptions model
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel := new(watsonxdatav2.CreateSalIntegrationEnrichmentGlobalSettingsOptions)
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.SemanticExpansion = salIntegrationEnrichmentSettingsSemanticExpansionModel
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.TermAssignment = salIntegrationEnrichmentSettingsTermAssignmentModel
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateSalIntegrationEnrichmentGlobalSettingsWithContext(ctx, createSalIntegrationEnrichmentGlobalSettingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateSalIntegrationEnrichmentGlobalSettings(createSalIntegrationEnrichmentGlobalSettingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateSalIntegrationEnrichmentGlobalSettingsWithContext(ctx, createSalIntegrationEnrichmentGlobalSettingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSalIntegrationEnrichmentGlobalSettingsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"semantic_expansion": {"description_generation": true, "description_generation_configuration": {"assignment_threshold": 0.14, "suggestion_threshold": 0.9}, "name_expansion": true, "name_expansion_configuration": {"assignment_threshold": 0.1, "suggestion_threshold": 0.1}}, "term_assignment": {"class_based_assignments": false, "evaluate_negative_assignments": false, "llm_based_assignments": false, "ml_based_assignments_custom": false, "ml_based_assignments_default": false, "name_matching": false, "term_assignment_threshold": 0.3, "term_suggestion_threshold": 0.4}}`)
				}))
			})
			It(`Invoke CreateSalIntegrationEnrichmentGlobalSettings successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateSalIntegrationEnrichmentGlobalSettings(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration model
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration)
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.AssignmentThreshold = core.Float64Ptr(float64(0.14))
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.SuggestionThreshold = core.Float64Ptr(float64(0.9))

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration model
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration)
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.AssignmentThreshold = core.Float64Ptr(float64(0.1))
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.SuggestionThreshold = core.Float64Ptr(float64(0.1))

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansion model
				salIntegrationEnrichmentSettingsSemanticExpansionModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansion)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGeneration = core.BoolPtr(true)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGenerationConfiguration = salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel
				salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansion = core.BoolPtr(true)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansionConfiguration = salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel

				// Construct an instance of the SalIntegrationEnrichmentSettingsTermAssignment model
				salIntegrationEnrichmentSettingsTermAssignmentModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsTermAssignment)
				salIntegrationEnrichmentSettingsTermAssignmentModel.ClassBasedAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.EvaluateNegativeAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.LlmBasedAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsCustom = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsDefault = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.NameMatching = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.TermAssignmentThreshold = core.Float64Ptr(float64(0.3))
				salIntegrationEnrichmentSettingsTermAssignmentModel.TermSuggestionThreshold = core.Float64Ptr(float64(0.4))

				// Construct an instance of the CreateSalIntegrationEnrichmentGlobalSettingsOptions model
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel := new(watsonxdatav2.CreateSalIntegrationEnrichmentGlobalSettingsOptions)
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.SemanticExpansion = salIntegrationEnrichmentSettingsSemanticExpansionModel
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.TermAssignment = salIntegrationEnrichmentSettingsTermAssignmentModel
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateSalIntegrationEnrichmentGlobalSettings(createSalIntegrationEnrichmentGlobalSettingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateSalIntegrationEnrichmentGlobalSettings with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration model
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration)
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.AssignmentThreshold = core.Float64Ptr(float64(0.14))
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.SuggestionThreshold = core.Float64Ptr(float64(0.9))

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration model
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration)
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.AssignmentThreshold = core.Float64Ptr(float64(0.1))
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.SuggestionThreshold = core.Float64Ptr(float64(0.1))

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansion model
				salIntegrationEnrichmentSettingsSemanticExpansionModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansion)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGeneration = core.BoolPtr(true)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGenerationConfiguration = salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel
				salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansion = core.BoolPtr(true)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansionConfiguration = salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel

				// Construct an instance of the SalIntegrationEnrichmentSettingsTermAssignment model
				salIntegrationEnrichmentSettingsTermAssignmentModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsTermAssignment)
				salIntegrationEnrichmentSettingsTermAssignmentModel.ClassBasedAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.EvaluateNegativeAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.LlmBasedAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsCustom = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsDefault = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.NameMatching = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.TermAssignmentThreshold = core.Float64Ptr(float64(0.3))
				salIntegrationEnrichmentSettingsTermAssignmentModel.TermSuggestionThreshold = core.Float64Ptr(float64(0.4))

				// Construct an instance of the CreateSalIntegrationEnrichmentGlobalSettingsOptions model
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel := new(watsonxdatav2.CreateSalIntegrationEnrichmentGlobalSettingsOptions)
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.SemanticExpansion = salIntegrationEnrichmentSettingsSemanticExpansionModel
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.TermAssignment = salIntegrationEnrichmentSettingsTermAssignmentModel
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateSalIntegrationEnrichmentGlobalSettings(createSalIntegrationEnrichmentGlobalSettingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateSalIntegrationEnrichmentGlobalSettings successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration model
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration)
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.AssignmentThreshold = core.Float64Ptr(float64(0.14))
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.SuggestionThreshold = core.Float64Ptr(float64(0.9))

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration model
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration)
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.AssignmentThreshold = core.Float64Ptr(float64(0.1))
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.SuggestionThreshold = core.Float64Ptr(float64(0.1))

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansion model
				salIntegrationEnrichmentSettingsSemanticExpansionModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansion)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGeneration = core.BoolPtr(true)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGenerationConfiguration = salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel
				salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansion = core.BoolPtr(true)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansionConfiguration = salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel

				// Construct an instance of the SalIntegrationEnrichmentSettingsTermAssignment model
				salIntegrationEnrichmentSettingsTermAssignmentModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsTermAssignment)
				salIntegrationEnrichmentSettingsTermAssignmentModel.ClassBasedAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.EvaluateNegativeAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.LlmBasedAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsCustom = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsDefault = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.NameMatching = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.TermAssignmentThreshold = core.Float64Ptr(float64(0.3))
				salIntegrationEnrichmentSettingsTermAssignmentModel.TermSuggestionThreshold = core.Float64Ptr(float64(0.4))

				// Construct an instance of the CreateSalIntegrationEnrichmentGlobalSettingsOptions model
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel := new(watsonxdatav2.CreateSalIntegrationEnrichmentGlobalSettingsOptions)
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.SemanticExpansion = salIntegrationEnrichmentSettingsSemanticExpansionModel
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.TermAssignment = salIntegrationEnrichmentSettingsTermAssignmentModel
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateSalIntegrationEnrichmentGlobalSettings(createSalIntegrationEnrichmentGlobalSettingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegrationEnrichmentSettings(getSalIntegrationEnrichmentSettingsOptions *GetSalIntegrationEnrichmentSettingsOptions) - Operation response error`, func() {
		getSalIntegrationEnrichmentSettingsPath := "/sal_integrations/metadata_enrichment_settings"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationEnrichmentSettingsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["project_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentSettings with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentSettingsOptions model
				getSalIntegrationEnrichmentSettingsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentSettingsOptions)
				getSalIntegrationEnrichmentSettingsOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentSettingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentSettingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentSettings(getSalIntegrationEnrichmentSettingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetSalIntegrationEnrichmentSettings(getSalIntegrationEnrichmentSettingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegrationEnrichmentSettings(getSalIntegrationEnrichmentSettingsOptions *GetSalIntegrationEnrichmentSettingsOptions)`, func() {
		getSalIntegrationEnrichmentSettingsPath := "/sal_integrations/metadata_enrichment_settings"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationEnrichmentSettingsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["project_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"semantic_expansion": {"description_generation": true, "description_generation_configuration": {"assignment_threshold": 0.14, "suggestion_threshold": 0.9}, "name_expansion": true, "name_expansion_configuration": {"assignment_threshold": 0.1, "suggestion_threshold": 0.1}}, "term_assignment": {"class_based_assignments": false, "evaluate_negative_assignments": false, "llm_based_assignments": false, "ml_based_assignments_custom": false, "ml_based_assignments_default": false, "name_matching": false, "term_assignment_threshold": 0.3, "term_suggestion_threshold": 0.4}}`)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentSettings successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetSalIntegrationEnrichmentSettingsOptions model
				getSalIntegrationEnrichmentSettingsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentSettingsOptions)
				getSalIntegrationEnrichmentSettingsOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentSettingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentSettingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetSalIntegrationEnrichmentSettingsWithContext(ctx, getSalIntegrationEnrichmentSettingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentSettings(getSalIntegrationEnrichmentSettingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetSalIntegrationEnrichmentSettingsWithContext(ctx, getSalIntegrationEnrichmentSettingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationEnrichmentSettingsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["project_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"semantic_expansion": {"description_generation": true, "description_generation_configuration": {"assignment_threshold": 0.14, "suggestion_threshold": 0.9}, "name_expansion": true, "name_expansion_configuration": {"assignment_threshold": 0.1, "suggestion_threshold": 0.1}}, "term_assignment": {"class_based_assignments": false, "evaluate_negative_assignments": false, "llm_based_assignments": false, "ml_based_assignments_custom": false, "ml_based_assignments_default": false, "name_matching": false, "term_assignment_threshold": 0.3, "term_suggestion_threshold": 0.4}}`)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentSettings successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentSettings(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentSettingsOptions model
				getSalIntegrationEnrichmentSettingsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentSettingsOptions)
				getSalIntegrationEnrichmentSettingsOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentSettingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentSettingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetSalIntegrationEnrichmentSettings(getSalIntegrationEnrichmentSettingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetSalIntegrationEnrichmentSettings with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentSettingsOptions model
				getSalIntegrationEnrichmentSettingsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentSettingsOptions)
				getSalIntegrationEnrichmentSettingsOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentSettingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentSettingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentSettings(getSalIntegrationEnrichmentSettingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetSalIntegrationEnrichmentSettings successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationEnrichmentSettingsOptions model
				getSalIntegrationEnrichmentSettingsOptionsModel := new(watsonxdatav2.GetSalIntegrationEnrichmentSettingsOptions)
				getSalIntegrationEnrichmentSettingsOptionsModel.ProjectID = core.StringPtr("testString")
				getSalIntegrationEnrichmentSettingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationEnrichmentSettingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetSalIntegrationEnrichmentSettings(getSalIntegrationEnrichmentSettingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSalIntegrationEnrichmentSettings(createSalIntegrationEnrichmentSettingsOptions *CreateSalIntegrationEnrichmentSettingsOptions)`, func() {
		createSalIntegrationEnrichmentSettingsPath := "/sal_integrations/metadata_enrichment_settings"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSalIntegrationEnrichmentSettingsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["project_id"]).To(Equal([]string{"testString"}))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke CreateSalIntegrationEnrichmentSettings successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.CreateSalIntegrationEnrichmentSettings(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration model
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration)
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.AssignmentThreshold = core.Float64Ptr(float64(0.14))
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.SuggestionThreshold = core.Float64Ptr(float64(0.9))

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration model
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration)
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.AssignmentThreshold = core.Float64Ptr(float64(0.1))
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.SuggestionThreshold = core.Float64Ptr(float64(0.1))

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansion model
				salIntegrationEnrichmentSettingsSemanticExpansionModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansion)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGeneration = core.BoolPtr(true)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGenerationConfiguration = salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel
				salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansion = core.BoolPtr(true)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansionConfiguration = salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel

				// Construct an instance of the SalIntegrationEnrichmentSettingsTermAssignment model
				salIntegrationEnrichmentSettingsTermAssignmentModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsTermAssignment)
				salIntegrationEnrichmentSettingsTermAssignmentModel.ClassBasedAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.EvaluateNegativeAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.LlmBasedAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsCustom = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsDefault = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.NameMatching = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.TermAssignmentThreshold = core.Float64Ptr(float64(0.3))
				salIntegrationEnrichmentSettingsTermAssignmentModel.TermSuggestionThreshold = core.Float64Ptr(float64(0.4))

				// Construct an instance of the CreateSalIntegrationEnrichmentSettingsOptions model
				createSalIntegrationEnrichmentSettingsOptionsModel := new(watsonxdatav2.CreateSalIntegrationEnrichmentSettingsOptions)
				createSalIntegrationEnrichmentSettingsOptionsModel.SemanticExpansion = salIntegrationEnrichmentSettingsSemanticExpansionModel
				createSalIntegrationEnrichmentSettingsOptionsModel.TermAssignment = salIntegrationEnrichmentSettingsTermAssignmentModel
				createSalIntegrationEnrichmentSettingsOptionsModel.ProjectID = core.StringPtr("testString")
				createSalIntegrationEnrichmentSettingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSalIntegrationEnrichmentSettingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.CreateSalIntegrationEnrichmentSettings(createSalIntegrationEnrichmentSettingsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke CreateSalIntegrationEnrichmentSettings with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration model
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration)
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.AssignmentThreshold = core.Float64Ptr(float64(0.14))
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.SuggestionThreshold = core.Float64Ptr(float64(0.9))

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration model
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration)
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.AssignmentThreshold = core.Float64Ptr(float64(0.1))
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.SuggestionThreshold = core.Float64Ptr(float64(0.1))

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansion model
				salIntegrationEnrichmentSettingsSemanticExpansionModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansion)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGeneration = core.BoolPtr(true)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGenerationConfiguration = salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel
				salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansion = core.BoolPtr(true)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansionConfiguration = salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel

				// Construct an instance of the SalIntegrationEnrichmentSettingsTermAssignment model
				salIntegrationEnrichmentSettingsTermAssignmentModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsTermAssignment)
				salIntegrationEnrichmentSettingsTermAssignmentModel.ClassBasedAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.EvaluateNegativeAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.LlmBasedAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsCustom = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsDefault = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.NameMatching = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.TermAssignmentThreshold = core.Float64Ptr(float64(0.3))
				salIntegrationEnrichmentSettingsTermAssignmentModel.TermSuggestionThreshold = core.Float64Ptr(float64(0.4))

				// Construct an instance of the CreateSalIntegrationEnrichmentSettingsOptions model
				createSalIntegrationEnrichmentSettingsOptionsModel := new(watsonxdatav2.CreateSalIntegrationEnrichmentSettingsOptions)
				createSalIntegrationEnrichmentSettingsOptionsModel.SemanticExpansion = salIntegrationEnrichmentSettingsSemanticExpansionModel
				createSalIntegrationEnrichmentSettingsOptionsModel.TermAssignment = salIntegrationEnrichmentSettingsTermAssignmentModel
				createSalIntegrationEnrichmentSettingsOptionsModel.ProjectID = core.StringPtr("testString")
				createSalIntegrationEnrichmentSettingsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSalIntegrationEnrichmentSettingsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.CreateSalIntegrationEnrichmentSettings(createSalIntegrationEnrichmentSettingsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSalIntegrationUploadGlossary(createSalIntegrationUploadGlossaryOptions *CreateSalIntegrationUploadGlossaryOptions) - Operation response error`, func() {
		createSalIntegrationUploadGlossaryPath := "/sal_integrations/upload_glossary"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSalIntegrationUploadGlossaryPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateSalIntegrationUploadGlossary with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSalIntegrationUploadGlossaryOptions model
				createSalIntegrationUploadGlossaryOptionsModel := new(watsonxdatav2.CreateSalIntegrationUploadGlossaryOptions)
				createSalIntegrationUploadGlossaryOptionsModel.ReplaceOption = core.StringPtr("all")
				createSalIntegrationUploadGlossaryOptionsModel.GlossaryCsv = CreateMockReader("This is a mock file.")
				createSalIntegrationUploadGlossaryOptionsModel.GlossaryCsvContentType = core.StringPtr("testString")
				createSalIntegrationUploadGlossaryOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSalIntegrationUploadGlossaryOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateSalIntegrationUploadGlossary(createSalIntegrationUploadGlossaryOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateSalIntegrationUploadGlossary(createSalIntegrationUploadGlossaryOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSalIntegrationUploadGlossary(createSalIntegrationUploadGlossaryOptions *CreateSalIntegrationUploadGlossaryOptions)`, func() {
		createSalIntegrationUploadGlossaryPath := "/sal_integrations/upload_glossary"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSalIntegrationUploadGlossaryPath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"process_id": "18b49d7a-9519-4539-8db5-ff080623c226"}`)
				}))
			})
			It(`Invoke CreateSalIntegrationUploadGlossary successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreateSalIntegrationUploadGlossaryOptions model
				createSalIntegrationUploadGlossaryOptionsModel := new(watsonxdatav2.CreateSalIntegrationUploadGlossaryOptions)
				createSalIntegrationUploadGlossaryOptionsModel.ReplaceOption = core.StringPtr("all")
				createSalIntegrationUploadGlossaryOptionsModel.GlossaryCsv = CreateMockReader("This is a mock file.")
				createSalIntegrationUploadGlossaryOptionsModel.GlossaryCsvContentType = core.StringPtr("testString")
				createSalIntegrationUploadGlossaryOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSalIntegrationUploadGlossaryOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateSalIntegrationUploadGlossaryWithContext(ctx, createSalIntegrationUploadGlossaryOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateSalIntegrationUploadGlossary(createSalIntegrationUploadGlossaryOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateSalIntegrationUploadGlossaryWithContext(ctx, createSalIntegrationUploadGlossaryOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSalIntegrationUploadGlossaryPath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"process_id": "18b49d7a-9519-4539-8db5-ff080623c226"}`)
				}))
			})
			It(`Invoke CreateSalIntegrationUploadGlossary successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateSalIntegrationUploadGlossary(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreateSalIntegrationUploadGlossaryOptions model
				createSalIntegrationUploadGlossaryOptionsModel := new(watsonxdatav2.CreateSalIntegrationUploadGlossaryOptions)
				createSalIntegrationUploadGlossaryOptionsModel.ReplaceOption = core.StringPtr("all")
				createSalIntegrationUploadGlossaryOptionsModel.GlossaryCsv = CreateMockReader("This is a mock file.")
				createSalIntegrationUploadGlossaryOptionsModel.GlossaryCsvContentType = core.StringPtr("testString")
				createSalIntegrationUploadGlossaryOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSalIntegrationUploadGlossaryOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateSalIntegrationUploadGlossary(createSalIntegrationUploadGlossaryOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateSalIntegrationUploadGlossary with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSalIntegrationUploadGlossaryOptions model
				createSalIntegrationUploadGlossaryOptionsModel := new(watsonxdatav2.CreateSalIntegrationUploadGlossaryOptions)
				createSalIntegrationUploadGlossaryOptionsModel.ReplaceOption = core.StringPtr("all")
				createSalIntegrationUploadGlossaryOptionsModel.GlossaryCsv = CreateMockReader("This is a mock file.")
				createSalIntegrationUploadGlossaryOptionsModel.GlossaryCsvContentType = core.StringPtr("testString")
				createSalIntegrationUploadGlossaryOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSalIntegrationUploadGlossaryOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateSalIntegrationUploadGlossary(createSalIntegrationUploadGlossaryOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateSalIntegrationUploadGlossaryOptions model with no property values
				createSalIntegrationUploadGlossaryOptionsModelNew := new(watsonxdatav2.CreateSalIntegrationUploadGlossaryOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateSalIntegrationUploadGlossary(createSalIntegrationUploadGlossaryOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateSalIntegrationUploadGlossary successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSalIntegrationUploadGlossaryOptions model
				createSalIntegrationUploadGlossaryOptionsModel := new(watsonxdatav2.CreateSalIntegrationUploadGlossaryOptions)
				createSalIntegrationUploadGlossaryOptionsModel.ReplaceOption = core.StringPtr("all")
				createSalIntegrationUploadGlossaryOptionsModel.GlossaryCsv = CreateMockReader("This is a mock file.")
				createSalIntegrationUploadGlossaryOptionsModel.GlossaryCsvContentType = core.StringPtr("testString")
				createSalIntegrationUploadGlossaryOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSalIntegrationUploadGlossaryOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateSalIntegrationUploadGlossary(createSalIntegrationUploadGlossaryOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegrationUploadGlossaryStatus(getSalIntegrationUploadGlossaryStatusOptions *GetSalIntegrationUploadGlossaryStatusOptions) - Operation response error`, func() {
		getSalIntegrationUploadGlossaryStatusPath := "/sal_integrations/upload_glossary_status"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationUploadGlossaryStatusPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["process_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetSalIntegrationUploadGlossaryStatus with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationUploadGlossaryStatusOptions model
				getSalIntegrationUploadGlossaryStatusOptionsModel := new(watsonxdatav2.GetSalIntegrationUploadGlossaryStatusOptions)
				getSalIntegrationUploadGlossaryStatusOptionsModel.ProcessID = core.StringPtr("testString")
				getSalIntegrationUploadGlossaryStatusOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationUploadGlossaryStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetSalIntegrationUploadGlossaryStatus(getSalIntegrationUploadGlossaryStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetSalIntegrationUploadGlossaryStatus(getSalIntegrationUploadGlossaryStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSalIntegrationUploadGlossaryStatus(getSalIntegrationUploadGlossaryStatusOptions *GetSalIntegrationUploadGlossaryStatusOptions)`, func() {
		getSalIntegrationUploadGlossaryStatusPath := "/sal_integrations/upload_glossary_status"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationUploadGlossaryStatusPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["process_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": "Import status available"}`)
				}))
			})
			It(`Invoke GetSalIntegrationUploadGlossaryStatus successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetSalIntegrationUploadGlossaryStatusOptions model
				getSalIntegrationUploadGlossaryStatusOptionsModel := new(watsonxdatav2.GetSalIntegrationUploadGlossaryStatusOptions)
				getSalIntegrationUploadGlossaryStatusOptionsModel.ProcessID = core.StringPtr("testString")
				getSalIntegrationUploadGlossaryStatusOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationUploadGlossaryStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetSalIntegrationUploadGlossaryStatusWithContext(ctx, getSalIntegrationUploadGlossaryStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetSalIntegrationUploadGlossaryStatus(getSalIntegrationUploadGlossaryStatusOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetSalIntegrationUploadGlossaryStatusWithContext(ctx, getSalIntegrationUploadGlossaryStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSalIntegrationUploadGlossaryStatusPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["process_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": "Import status available"}`)
				}))
			})
			It(`Invoke GetSalIntegrationUploadGlossaryStatus successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetSalIntegrationUploadGlossaryStatus(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSalIntegrationUploadGlossaryStatusOptions model
				getSalIntegrationUploadGlossaryStatusOptionsModel := new(watsonxdatav2.GetSalIntegrationUploadGlossaryStatusOptions)
				getSalIntegrationUploadGlossaryStatusOptionsModel.ProcessID = core.StringPtr("testString")
				getSalIntegrationUploadGlossaryStatusOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationUploadGlossaryStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetSalIntegrationUploadGlossaryStatus(getSalIntegrationUploadGlossaryStatusOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetSalIntegrationUploadGlossaryStatus with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationUploadGlossaryStatusOptions model
				getSalIntegrationUploadGlossaryStatusOptionsModel := new(watsonxdatav2.GetSalIntegrationUploadGlossaryStatusOptions)
				getSalIntegrationUploadGlossaryStatusOptionsModel.ProcessID = core.StringPtr("testString")
				getSalIntegrationUploadGlossaryStatusOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationUploadGlossaryStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetSalIntegrationUploadGlossaryStatus(getSalIntegrationUploadGlossaryStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetSalIntegrationUploadGlossaryStatus successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSalIntegrationUploadGlossaryStatusOptions model
				getSalIntegrationUploadGlossaryStatusOptionsModel := new(watsonxdatav2.GetSalIntegrationUploadGlossaryStatusOptions)
				getSalIntegrationUploadGlossaryStatusOptionsModel.ProcessID = core.StringPtr("testString")
				getSalIntegrationUploadGlossaryStatusOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSalIntegrationUploadGlossaryStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetSalIntegrationUploadGlossaryStatus(getSalIntegrationUploadGlossaryStatusOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListSparkEngines(listSparkEnginesOptions *ListSparkEnginesOptions) - Operation response error`, func() {
		listSparkEnginesPath := "/spark_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkEnginesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListSparkEngines with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkEnginesOptions model
				listSparkEnginesOptionsModel := new(watsonxdatav2.ListSparkEnginesOptions)
				listSparkEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListSparkEngines(listSparkEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListSparkEngines(listSparkEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListSparkEngines(listSparkEnginesOptions *ListSparkEnginesOptions)`, func() {
		listSparkEnginesPath := "/spark_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkEnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"spark_engines": [{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "spark engine for running sql queries", "engine_details": {"api_key": "apikey", "connection_string": "https://xyz.<region>.ae.cloud.123.com/v3/analytics_engines/<spark_iae_id>", "default_config": {"config1": "Config1", "config2": "Config2"}, "default_version": "4.8.3", "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications", "wxd_engine_endpoint": "$HOST/v1/1698311655308796/engines/spark817", "wxd_history_server_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server", "wxd_history_server_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server/ui"}, "engine_home_bucket_display_name": "test-spark-bucket", "engine_home_bucket_name": "test-spark-bucket", "engine_home_path": "spark/spark1234", "engine_home_volume": "test-spark-volume", "engine_home_volume_id": "1704979825978585", "engine_home_volume_name": "my-volume", "engine_home_volume_storage_class": "nfs-client", "engine_home_volume_storage_size": "5Gi", "engine_sub_type": "java/cpp", "instance_id": "spark-id", "managed_by": "fully/self", "scale_config": {"auto_scale_enabled": true, "current_number_of_nodes": 2, "maximum_number_of_nodes": 5, "minimum_number_of_nodes": 1, "node_type": "medium", "number_of_nodes": 2}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "origin": "external", "status": "Registered", "tags": ["Tags"], "type": "spark"}]}`)
				}))
			})
			It(`Invoke ListSparkEngines successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListSparkEnginesOptions model
				listSparkEnginesOptionsModel := new(watsonxdatav2.ListSparkEnginesOptions)
				listSparkEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListSparkEnginesWithContext(ctx, listSparkEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListSparkEngines(listSparkEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListSparkEnginesWithContext(ctx, listSparkEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkEnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"spark_engines": [{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "spark engine for running sql queries", "engine_details": {"api_key": "apikey", "connection_string": "https://xyz.<region>.ae.cloud.123.com/v3/analytics_engines/<spark_iae_id>", "default_config": {"config1": "Config1", "config2": "Config2"}, "default_version": "4.8.3", "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications", "wxd_engine_endpoint": "$HOST/v1/1698311655308796/engines/spark817", "wxd_history_server_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server", "wxd_history_server_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server/ui"}, "engine_home_bucket_display_name": "test-spark-bucket", "engine_home_bucket_name": "test-spark-bucket", "engine_home_path": "spark/spark1234", "engine_home_volume": "test-spark-volume", "engine_home_volume_id": "1704979825978585", "engine_home_volume_name": "my-volume", "engine_home_volume_storage_class": "nfs-client", "engine_home_volume_storage_size": "5Gi", "engine_sub_type": "java/cpp", "instance_id": "spark-id", "managed_by": "fully/self", "scale_config": {"auto_scale_enabled": true, "current_number_of_nodes": 2, "maximum_number_of_nodes": 5, "minimum_number_of_nodes": 1, "node_type": "medium", "number_of_nodes": 2}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "origin": "external", "status": "Registered", "tags": ["Tags"], "type": "spark"}]}`)
				}))
			})
			It(`Invoke ListSparkEngines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListSparkEngines(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListSparkEnginesOptions model
				listSparkEnginesOptionsModel := new(watsonxdatav2.ListSparkEnginesOptions)
				listSparkEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListSparkEngines(listSparkEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListSparkEngines with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkEnginesOptions model
				listSparkEnginesOptionsModel := new(watsonxdatav2.ListSparkEnginesOptions)
				listSparkEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListSparkEngines(listSparkEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListSparkEngines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkEnginesOptions model
				listSparkEnginesOptionsModel := new(watsonxdatav2.ListSparkEnginesOptions)
				listSparkEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListSparkEngines(listSparkEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSparkEngine(createSparkEngineOptions *CreateSparkEngineOptions) - Operation response error`, func() {
		createSparkEnginePath := "/spark_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateSparkEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SparkDefaultConfig model
				sparkDefaultConfigModel := new(watsonxdatav2.SparkDefaultConfig)
				sparkDefaultConfigModel.Config1 = core.StringPtr("testString")
				sparkDefaultConfigModel.Config2 = core.StringPtr("testString")

				// Construct an instance of the SparkScaleConfig model
				sparkScaleConfigModel := new(watsonxdatav2.SparkScaleConfig)
				sparkScaleConfigModel.AutoScaleEnabled = core.BoolPtr(true)
				sparkScaleConfigModel.CurrentNumberOfNodes = core.Int64Ptr(int64(2))
				sparkScaleConfigModel.MaximumNumberOfNodes = core.Int64Ptr(int64(5))
				sparkScaleConfigModel.MinimumNumberOfNodes = core.Int64Ptr(int64(1))
				sparkScaleConfigModel.NodeType = core.StringPtr("small")
				sparkScaleConfigModel.NumberOfNodes = core.Int64Ptr(int64(5))

				// Construct an instance of the SparkEngineDetailsPrototype model
				sparkEngineDetailsPrototypeModel := new(watsonxdatav2.SparkEngineDetailsPrototype)
				sparkEngineDetailsPrototypeModel.ApiKey = core.StringPtr("apikey")
				sparkEngineDetailsPrototypeModel.ConnectionString = core.StringPtr("1.2.3.4")
				sparkEngineDetailsPrototypeModel.DefaultConfig = sparkDefaultConfigModel
				sparkEngineDetailsPrototypeModel.DefaultVersion = core.StringPtr("3.3")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketDisplayName = core.StringPtr("test-spark-bucket")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketName = core.StringPtr("4fec0f8b-888a-4c16-8f38-250c8499e6ce-customer")
				sparkEngineDetailsPrototypeModel.EngineHomePath = core.StringPtr("spark/spark1234")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeID = core.StringPtr("1704979825978585")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeName = core.StringPtr("my-volume")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageClass = core.StringPtr("nfs-client")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageSize = core.StringPtr("5Gi")
				sparkEngineDetailsPrototypeModel.InstanceID = core.StringPtr("spark-id")
				sparkEngineDetailsPrototypeModel.EngineSubType = core.StringPtr("java/cpp")
				sparkEngineDetailsPrototypeModel.ManagedBy = core.StringPtr("fully/self")
				sparkEngineDetailsPrototypeModel.ScaleConfig = sparkScaleConfigModel

				// Construct an instance of the CreateSparkEngineOptions model
				createSparkEngineOptionsModel := new(watsonxdatav2.CreateSparkEngineOptions)
				createSparkEngineOptionsModel.Origin = core.StringPtr("native")
				createSparkEngineOptionsModel.AssociatedCatalogs = []string{"iceberg_data"}
				createSparkEngineOptionsModel.Description = core.StringPtr("testString")
				createSparkEngineOptionsModel.EngineDetails = sparkEngineDetailsPrototypeModel
				createSparkEngineOptionsModel.EngineDisplayName = core.StringPtr("test-native")
				createSparkEngineOptionsModel.Status = core.StringPtr("testString")
				createSparkEngineOptionsModel.Tags = []string{"testString"}
				createSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateSparkEngine(createSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateSparkEngine(createSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSparkEngine(createSparkEngineOptions *CreateSparkEngineOptions)`, func() {
		createSparkEnginePath := "/spark_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "spark engine for running sql queries", "engine_details": {"api_key": "apikey", "connection_string": "https://xyz.<region>.ae.cloud.123.com/v3/analytics_engines/<spark_iae_id>", "default_config": {"config1": "Config1", "config2": "Config2"}, "default_version": "4.8.3", "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications", "wxd_engine_endpoint": "$HOST/v1/1698311655308796/engines/spark817", "wxd_history_server_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server", "wxd_history_server_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server/ui"}, "engine_home_bucket_display_name": "test-spark-bucket", "engine_home_bucket_name": "test-spark-bucket", "engine_home_path": "spark/spark1234", "engine_home_volume": "test-spark-volume", "engine_home_volume_id": "1704979825978585", "engine_home_volume_name": "my-volume", "engine_home_volume_storage_class": "nfs-client", "engine_home_volume_storage_size": "5Gi", "engine_sub_type": "java/cpp", "instance_id": "spark-id", "managed_by": "fully/self", "scale_config": {"auto_scale_enabled": true, "current_number_of_nodes": 2, "maximum_number_of_nodes": 5, "minimum_number_of_nodes": 1, "node_type": "medium", "number_of_nodes": 2}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "origin": "external", "status": "Registered", "tags": ["Tags"], "type": "spark"}`)
				}))
			})
			It(`Invoke CreateSparkEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the SparkDefaultConfig model
				sparkDefaultConfigModel := new(watsonxdatav2.SparkDefaultConfig)
				sparkDefaultConfigModel.Config1 = core.StringPtr("testString")
				sparkDefaultConfigModel.Config2 = core.StringPtr("testString")

				// Construct an instance of the SparkScaleConfig model
				sparkScaleConfigModel := new(watsonxdatav2.SparkScaleConfig)
				sparkScaleConfigModel.AutoScaleEnabled = core.BoolPtr(true)
				sparkScaleConfigModel.CurrentNumberOfNodes = core.Int64Ptr(int64(2))
				sparkScaleConfigModel.MaximumNumberOfNodes = core.Int64Ptr(int64(5))
				sparkScaleConfigModel.MinimumNumberOfNodes = core.Int64Ptr(int64(1))
				sparkScaleConfigModel.NodeType = core.StringPtr("small")
				sparkScaleConfigModel.NumberOfNodes = core.Int64Ptr(int64(5))

				// Construct an instance of the SparkEngineDetailsPrototype model
				sparkEngineDetailsPrototypeModel := new(watsonxdatav2.SparkEngineDetailsPrototype)
				sparkEngineDetailsPrototypeModel.ApiKey = core.StringPtr("apikey")
				sparkEngineDetailsPrototypeModel.ConnectionString = core.StringPtr("1.2.3.4")
				sparkEngineDetailsPrototypeModel.DefaultConfig = sparkDefaultConfigModel
				sparkEngineDetailsPrototypeModel.DefaultVersion = core.StringPtr("3.3")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketDisplayName = core.StringPtr("test-spark-bucket")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketName = core.StringPtr("4fec0f8b-888a-4c16-8f38-250c8499e6ce-customer")
				sparkEngineDetailsPrototypeModel.EngineHomePath = core.StringPtr("spark/spark1234")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeID = core.StringPtr("1704979825978585")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeName = core.StringPtr("my-volume")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageClass = core.StringPtr("nfs-client")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageSize = core.StringPtr("5Gi")
				sparkEngineDetailsPrototypeModel.InstanceID = core.StringPtr("spark-id")
				sparkEngineDetailsPrototypeModel.EngineSubType = core.StringPtr("java/cpp")
				sparkEngineDetailsPrototypeModel.ManagedBy = core.StringPtr("fully/self")
				sparkEngineDetailsPrototypeModel.ScaleConfig = sparkScaleConfigModel

				// Construct an instance of the CreateSparkEngineOptions model
				createSparkEngineOptionsModel := new(watsonxdatav2.CreateSparkEngineOptions)
				createSparkEngineOptionsModel.Origin = core.StringPtr("native")
				createSparkEngineOptionsModel.AssociatedCatalogs = []string{"iceberg_data"}
				createSparkEngineOptionsModel.Description = core.StringPtr("testString")
				createSparkEngineOptionsModel.EngineDetails = sparkEngineDetailsPrototypeModel
				createSparkEngineOptionsModel.EngineDisplayName = core.StringPtr("test-native")
				createSparkEngineOptionsModel.Status = core.StringPtr("testString")
				createSparkEngineOptionsModel.Tags = []string{"testString"}
				createSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateSparkEngineWithContext(ctx, createSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateSparkEngine(createSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateSparkEngineWithContext(ctx, createSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "spark engine for running sql queries", "engine_details": {"api_key": "apikey", "connection_string": "https://xyz.<region>.ae.cloud.123.com/v3/analytics_engines/<spark_iae_id>", "default_config": {"config1": "Config1", "config2": "Config2"}, "default_version": "4.8.3", "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications", "wxd_engine_endpoint": "$HOST/v1/1698311655308796/engines/spark817", "wxd_history_server_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server", "wxd_history_server_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server/ui"}, "engine_home_bucket_display_name": "test-spark-bucket", "engine_home_bucket_name": "test-spark-bucket", "engine_home_path": "spark/spark1234", "engine_home_volume": "test-spark-volume", "engine_home_volume_id": "1704979825978585", "engine_home_volume_name": "my-volume", "engine_home_volume_storage_class": "nfs-client", "engine_home_volume_storage_size": "5Gi", "engine_sub_type": "java/cpp", "instance_id": "spark-id", "managed_by": "fully/self", "scale_config": {"auto_scale_enabled": true, "current_number_of_nodes": 2, "maximum_number_of_nodes": 5, "minimum_number_of_nodes": 1, "node_type": "medium", "number_of_nodes": 2}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "origin": "external", "status": "Registered", "tags": ["Tags"], "type": "spark"}`)
				}))
			})
			It(`Invoke CreateSparkEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateSparkEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the SparkDefaultConfig model
				sparkDefaultConfigModel := new(watsonxdatav2.SparkDefaultConfig)
				sparkDefaultConfigModel.Config1 = core.StringPtr("testString")
				sparkDefaultConfigModel.Config2 = core.StringPtr("testString")

				// Construct an instance of the SparkScaleConfig model
				sparkScaleConfigModel := new(watsonxdatav2.SparkScaleConfig)
				sparkScaleConfigModel.AutoScaleEnabled = core.BoolPtr(true)
				sparkScaleConfigModel.CurrentNumberOfNodes = core.Int64Ptr(int64(2))
				sparkScaleConfigModel.MaximumNumberOfNodes = core.Int64Ptr(int64(5))
				sparkScaleConfigModel.MinimumNumberOfNodes = core.Int64Ptr(int64(1))
				sparkScaleConfigModel.NodeType = core.StringPtr("small")
				sparkScaleConfigModel.NumberOfNodes = core.Int64Ptr(int64(5))

				// Construct an instance of the SparkEngineDetailsPrototype model
				sparkEngineDetailsPrototypeModel := new(watsonxdatav2.SparkEngineDetailsPrototype)
				sparkEngineDetailsPrototypeModel.ApiKey = core.StringPtr("apikey")
				sparkEngineDetailsPrototypeModel.ConnectionString = core.StringPtr("1.2.3.4")
				sparkEngineDetailsPrototypeModel.DefaultConfig = sparkDefaultConfigModel
				sparkEngineDetailsPrototypeModel.DefaultVersion = core.StringPtr("3.3")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketDisplayName = core.StringPtr("test-spark-bucket")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketName = core.StringPtr("4fec0f8b-888a-4c16-8f38-250c8499e6ce-customer")
				sparkEngineDetailsPrototypeModel.EngineHomePath = core.StringPtr("spark/spark1234")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeID = core.StringPtr("1704979825978585")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeName = core.StringPtr("my-volume")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageClass = core.StringPtr("nfs-client")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageSize = core.StringPtr("5Gi")
				sparkEngineDetailsPrototypeModel.InstanceID = core.StringPtr("spark-id")
				sparkEngineDetailsPrototypeModel.EngineSubType = core.StringPtr("java/cpp")
				sparkEngineDetailsPrototypeModel.ManagedBy = core.StringPtr("fully/self")
				sparkEngineDetailsPrototypeModel.ScaleConfig = sparkScaleConfigModel

				// Construct an instance of the CreateSparkEngineOptions model
				createSparkEngineOptionsModel := new(watsonxdatav2.CreateSparkEngineOptions)
				createSparkEngineOptionsModel.Origin = core.StringPtr("native")
				createSparkEngineOptionsModel.AssociatedCatalogs = []string{"iceberg_data"}
				createSparkEngineOptionsModel.Description = core.StringPtr("testString")
				createSparkEngineOptionsModel.EngineDetails = sparkEngineDetailsPrototypeModel
				createSparkEngineOptionsModel.EngineDisplayName = core.StringPtr("test-native")
				createSparkEngineOptionsModel.Status = core.StringPtr("testString")
				createSparkEngineOptionsModel.Tags = []string{"testString"}
				createSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateSparkEngine(createSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateSparkEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SparkDefaultConfig model
				sparkDefaultConfigModel := new(watsonxdatav2.SparkDefaultConfig)
				sparkDefaultConfigModel.Config1 = core.StringPtr("testString")
				sparkDefaultConfigModel.Config2 = core.StringPtr("testString")

				// Construct an instance of the SparkScaleConfig model
				sparkScaleConfigModel := new(watsonxdatav2.SparkScaleConfig)
				sparkScaleConfigModel.AutoScaleEnabled = core.BoolPtr(true)
				sparkScaleConfigModel.CurrentNumberOfNodes = core.Int64Ptr(int64(2))
				sparkScaleConfigModel.MaximumNumberOfNodes = core.Int64Ptr(int64(5))
				sparkScaleConfigModel.MinimumNumberOfNodes = core.Int64Ptr(int64(1))
				sparkScaleConfigModel.NodeType = core.StringPtr("small")
				sparkScaleConfigModel.NumberOfNodes = core.Int64Ptr(int64(5))

				// Construct an instance of the SparkEngineDetailsPrototype model
				sparkEngineDetailsPrototypeModel := new(watsonxdatav2.SparkEngineDetailsPrototype)
				sparkEngineDetailsPrototypeModel.ApiKey = core.StringPtr("apikey")
				sparkEngineDetailsPrototypeModel.ConnectionString = core.StringPtr("1.2.3.4")
				sparkEngineDetailsPrototypeModel.DefaultConfig = sparkDefaultConfigModel
				sparkEngineDetailsPrototypeModel.DefaultVersion = core.StringPtr("3.3")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketDisplayName = core.StringPtr("test-spark-bucket")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketName = core.StringPtr("4fec0f8b-888a-4c16-8f38-250c8499e6ce-customer")
				sparkEngineDetailsPrototypeModel.EngineHomePath = core.StringPtr("spark/spark1234")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeID = core.StringPtr("1704979825978585")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeName = core.StringPtr("my-volume")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageClass = core.StringPtr("nfs-client")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageSize = core.StringPtr("5Gi")
				sparkEngineDetailsPrototypeModel.InstanceID = core.StringPtr("spark-id")
				sparkEngineDetailsPrototypeModel.EngineSubType = core.StringPtr("java/cpp")
				sparkEngineDetailsPrototypeModel.ManagedBy = core.StringPtr("fully/self")
				sparkEngineDetailsPrototypeModel.ScaleConfig = sparkScaleConfigModel

				// Construct an instance of the CreateSparkEngineOptions model
				createSparkEngineOptionsModel := new(watsonxdatav2.CreateSparkEngineOptions)
				createSparkEngineOptionsModel.Origin = core.StringPtr("native")
				createSparkEngineOptionsModel.AssociatedCatalogs = []string{"iceberg_data"}
				createSparkEngineOptionsModel.Description = core.StringPtr("testString")
				createSparkEngineOptionsModel.EngineDetails = sparkEngineDetailsPrototypeModel
				createSparkEngineOptionsModel.EngineDisplayName = core.StringPtr("test-native")
				createSparkEngineOptionsModel.Status = core.StringPtr("testString")
				createSparkEngineOptionsModel.Tags = []string{"testString"}
				createSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateSparkEngine(createSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateSparkEngineOptions model with no property values
				createSparkEngineOptionsModelNew := new(watsonxdatav2.CreateSparkEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateSparkEngine(createSparkEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(202)
				}))
			})
			It(`Invoke CreateSparkEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SparkDefaultConfig model
				sparkDefaultConfigModel := new(watsonxdatav2.SparkDefaultConfig)
				sparkDefaultConfigModel.Config1 = core.StringPtr("testString")
				sparkDefaultConfigModel.Config2 = core.StringPtr("testString")

				// Construct an instance of the SparkScaleConfig model
				sparkScaleConfigModel := new(watsonxdatav2.SparkScaleConfig)
				sparkScaleConfigModel.AutoScaleEnabled = core.BoolPtr(true)
				sparkScaleConfigModel.CurrentNumberOfNodes = core.Int64Ptr(int64(2))
				sparkScaleConfigModel.MaximumNumberOfNodes = core.Int64Ptr(int64(5))
				sparkScaleConfigModel.MinimumNumberOfNodes = core.Int64Ptr(int64(1))
				sparkScaleConfigModel.NodeType = core.StringPtr("small")
				sparkScaleConfigModel.NumberOfNodes = core.Int64Ptr(int64(5))

				// Construct an instance of the SparkEngineDetailsPrototype model
				sparkEngineDetailsPrototypeModel := new(watsonxdatav2.SparkEngineDetailsPrototype)
				sparkEngineDetailsPrototypeModel.ApiKey = core.StringPtr("apikey")
				sparkEngineDetailsPrototypeModel.ConnectionString = core.StringPtr("1.2.3.4")
				sparkEngineDetailsPrototypeModel.DefaultConfig = sparkDefaultConfigModel
				sparkEngineDetailsPrototypeModel.DefaultVersion = core.StringPtr("3.3")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketDisplayName = core.StringPtr("test-spark-bucket")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketName = core.StringPtr("4fec0f8b-888a-4c16-8f38-250c8499e6ce-customer")
				sparkEngineDetailsPrototypeModel.EngineHomePath = core.StringPtr("spark/spark1234")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeID = core.StringPtr("1704979825978585")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeName = core.StringPtr("my-volume")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageClass = core.StringPtr("nfs-client")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageSize = core.StringPtr("5Gi")
				sparkEngineDetailsPrototypeModel.InstanceID = core.StringPtr("spark-id")
				sparkEngineDetailsPrototypeModel.EngineSubType = core.StringPtr("java/cpp")
				sparkEngineDetailsPrototypeModel.ManagedBy = core.StringPtr("fully/self")
				sparkEngineDetailsPrototypeModel.ScaleConfig = sparkScaleConfigModel

				// Construct an instance of the CreateSparkEngineOptions model
				createSparkEngineOptionsModel := new(watsonxdatav2.CreateSparkEngineOptions)
				createSparkEngineOptionsModel.Origin = core.StringPtr("native")
				createSparkEngineOptionsModel.AssociatedCatalogs = []string{"iceberg_data"}
				createSparkEngineOptionsModel.Description = core.StringPtr("testString")
				createSparkEngineOptionsModel.EngineDetails = sparkEngineDetailsPrototypeModel
				createSparkEngineOptionsModel.EngineDisplayName = core.StringPtr("test-native")
				createSparkEngineOptionsModel.Status = core.StringPtr("testString")
				createSparkEngineOptionsModel.Tags = []string{"testString"}
				createSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateSparkEngine(createSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSparkEngine(getSparkEngineOptions *GetSparkEngineOptions) - Operation response error`, func() {
		getSparkEnginePath := "/spark_engines/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEnginePath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetSparkEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineOptions model
				getSparkEngineOptionsModel := new(watsonxdatav2.GetSparkEngineOptions)
				getSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetSparkEngine(getSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetSparkEngine(getSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSparkEngine(getSparkEngineOptions *GetSparkEngineOptions)`, func() {
		getSparkEnginePath := "/spark_engines/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEnginePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "spark engine for running sql queries", "engine_details": {"api_key": "apikey", "connection_string": "https://xyz.<region>.ae.cloud.123.com/v3/analytics_engines/<spark_iae_id>", "default_config": {"config1": "Config1", "config2": "Config2"}, "default_version": "4.8.3", "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications", "wxd_engine_endpoint": "$HOST/v1/1698311655308796/engines/spark817", "wxd_history_server_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server", "wxd_history_server_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server/ui"}, "engine_home_bucket_display_name": "test-spark-bucket", "engine_home_bucket_name": "test-spark-bucket", "engine_home_path": "spark/spark1234", "engine_home_volume": "test-spark-volume", "engine_home_volume_id": "1704979825978585", "engine_home_volume_name": "my-volume", "engine_home_volume_storage_class": "nfs-client", "engine_home_volume_storage_size": "5Gi", "engine_sub_type": "java/cpp", "instance_id": "spark-id", "managed_by": "fully/self", "scale_config": {"auto_scale_enabled": true, "current_number_of_nodes": 2, "maximum_number_of_nodes": 5, "minimum_number_of_nodes": 1, "node_type": "medium", "number_of_nodes": 2}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "origin": "external", "status": "Registered", "tags": ["Tags"], "type": "spark"}`)
				}))
			})
			It(`Invoke GetSparkEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetSparkEngineOptions model
				getSparkEngineOptionsModel := new(watsonxdatav2.GetSparkEngineOptions)
				getSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetSparkEngineWithContext(ctx, getSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetSparkEngine(getSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetSparkEngineWithContext(ctx, getSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEnginePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "spark engine for running sql queries", "engine_details": {"api_key": "apikey", "connection_string": "https://xyz.<region>.ae.cloud.123.com/v3/analytics_engines/<spark_iae_id>", "default_config": {"config1": "Config1", "config2": "Config2"}, "default_version": "4.8.3", "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications", "wxd_engine_endpoint": "$HOST/v1/1698311655308796/engines/spark817", "wxd_history_server_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server", "wxd_history_server_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server/ui"}, "engine_home_bucket_display_name": "test-spark-bucket", "engine_home_bucket_name": "test-spark-bucket", "engine_home_path": "spark/spark1234", "engine_home_volume": "test-spark-volume", "engine_home_volume_id": "1704979825978585", "engine_home_volume_name": "my-volume", "engine_home_volume_storage_class": "nfs-client", "engine_home_volume_storage_size": "5Gi", "engine_sub_type": "java/cpp", "instance_id": "spark-id", "managed_by": "fully/self", "scale_config": {"auto_scale_enabled": true, "current_number_of_nodes": 2, "maximum_number_of_nodes": 5, "minimum_number_of_nodes": 1, "node_type": "medium", "number_of_nodes": 2}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "origin": "external", "status": "Registered", "tags": ["Tags"], "type": "spark"}`)
				}))
			})
			It(`Invoke GetSparkEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetSparkEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSparkEngineOptions model
				getSparkEngineOptionsModel := new(watsonxdatav2.GetSparkEngineOptions)
				getSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetSparkEngine(getSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetSparkEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineOptions model
				getSparkEngineOptionsModel := new(watsonxdatav2.GetSparkEngineOptions)
				getSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetSparkEngine(getSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetSparkEngineOptions model with no property values
				getSparkEngineOptionsModelNew := new(watsonxdatav2.GetSparkEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetSparkEngine(getSparkEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetSparkEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineOptions model
				getSparkEngineOptionsModel := new(watsonxdatav2.GetSparkEngineOptions)
				getSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetSparkEngine(getSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteSparkEngine(deleteSparkEngineOptions *DeleteSparkEngineOptions)`, func() {
		deleteSparkEnginePath := "/spark_engines/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteSparkEnginePath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteSparkEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteSparkEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteSparkEngineOptions model
				deleteSparkEngineOptionsModel := new(watsonxdatav2.DeleteSparkEngineOptions)
				deleteSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				deleteSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteSparkEngine(deleteSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteSparkEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteSparkEngineOptions model
				deleteSparkEngineOptionsModel := new(watsonxdatav2.DeleteSparkEngineOptions)
				deleteSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				deleteSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteSparkEngine(deleteSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteSparkEngineOptions model with no property values
				deleteSparkEngineOptionsModelNew := new(watsonxdatav2.DeleteSparkEngineOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteSparkEngine(deleteSparkEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateSparkEngine(updateSparkEngineOptions *UpdateSparkEngineOptions) - Operation response error`, func() {
		updateSparkEnginePath := "/spark_engines/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateSparkEnginePath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateSparkEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SparkEngineResourceLimit model
				sparkEngineResourceLimitModel := new(watsonxdatav2.SparkEngineResourceLimit)
				sparkEngineResourceLimitModel.Cores = core.StringPtr("1")
				sparkEngineResourceLimitModel.Memory = core.StringPtr("4G")

				// Construct an instance of the UpdateSparkEngineBodyEngineDetails model
				updateSparkEngineBodyEngineDetailsModel := new(watsonxdatav2.UpdateSparkEngineBodyEngineDetails)
				updateSparkEngineBodyEngineDetailsModel.DefaultConfig = map[string]string{"key1": "testString"}
				updateSparkEngineBodyEngineDetailsModel.DefaultVersion = core.StringPtr("3.4")
				updateSparkEngineBodyEngineDetailsModel.EngineHomeBucketName = core.StringPtr("test-spark-bucket")
				updateSparkEngineBodyEngineDetailsModel.ResourceLimitEnabled = core.BoolPtr(true)
				updateSparkEngineBodyEngineDetailsModel.ResourceLimits = sparkEngineResourceLimitModel

				// Construct an instance of the UpdateSparkEngineBody model
				updateSparkEngineBodyModel := new(watsonxdatav2.UpdateSparkEngineBody)
				updateSparkEngineBodyModel.Description = core.StringPtr("Updated Description")
				updateSparkEngineBodyModel.EngineDetails = updateSparkEngineBodyEngineDetailsModel
				updateSparkEngineBodyModel.EngineDisplayName = core.StringPtr("Updated Display Name")
				updateSparkEngineBodyModel.Tags = []string{"tag1", "tag2"}
				updateSparkEngineBodyModelAsPatch, asPatchErr := updateSparkEngineBodyModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSparkEngineOptions model
				updateSparkEngineOptionsModel := new(watsonxdatav2.UpdateSparkEngineOptions)
				updateSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				updateSparkEngineOptionsModel.Body = updateSparkEngineBodyModelAsPatch
				updateSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdateSparkEngine(updateSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdateSparkEngine(updateSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateSparkEngine(updateSparkEngineOptions *UpdateSparkEngineOptions)`, func() {
		updateSparkEnginePath := "/spark_engines/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateSparkEnginePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "spark engine for running sql queries", "engine_details": {"api_key": "apikey", "connection_string": "https://xyz.<region>.ae.cloud.123.com/v3/analytics_engines/<spark_iae_id>", "default_config": {"config1": "Config1", "config2": "Config2"}, "default_version": "4.8.3", "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications", "wxd_engine_endpoint": "$HOST/v1/1698311655308796/engines/spark817", "wxd_history_server_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server", "wxd_history_server_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server/ui"}, "engine_home_bucket_display_name": "test-spark-bucket", "engine_home_bucket_name": "test-spark-bucket", "engine_home_path": "spark/spark1234", "engine_home_volume": "test-spark-volume", "engine_home_volume_id": "1704979825978585", "engine_home_volume_name": "my-volume", "engine_home_volume_storage_class": "nfs-client", "engine_home_volume_storage_size": "5Gi", "engine_sub_type": "java/cpp", "instance_id": "spark-id", "managed_by": "fully/self", "scale_config": {"auto_scale_enabled": true, "current_number_of_nodes": 2, "maximum_number_of_nodes": 5, "minimum_number_of_nodes": 1, "node_type": "medium", "number_of_nodes": 2}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "origin": "external", "status": "Registered", "tags": ["Tags"], "type": "spark"}`)
				}))
			})
			It(`Invoke UpdateSparkEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the SparkEngineResourceLimit model
				sparkEngineResourceLimitModel := new(watsonxdatav2.SparkEngineResourceLimit)
				sparkEngineResourceLimitModel.Cores = core.StringPtr("1")
				sparkEngineResourceLimitModel.Memory = core.StringPtr("4G")

				// Construct an instance of the UpdateSparkEngineBodyEngineDetails model
				updateSparkEngineBodyEngineDetailsModel := new(watsonxdatav2.UpdateSparkEngineBodyEngineDetails)
				updateSparkEngineBodyEngineDetailsModel.DefaultConfig = map[string]string{"key1": "testString"}
				updateSparkEngineBodyEngineDetailsModel.DefaultVersion = core.StringPtr("3.4")
				updateSparkEngineBodyEngineDetailsModel.EngineHomeBucketName = core.StringPtr("test-spark-bucket")
				updateSparkEngineBodyEngineDetailsModel.ResourceLimitEnabled = core.BoolPtr(true)
				updateSparkEngineBodyEngineDetailsModel.ResourceLimits = sparkEngineResourceLimitModel

				// Construct an instance of the UpdateSparkEngineBody model
				updateSparkEngineBodyModel := new(watsonxdatav2.UpdateSparkEngineBody)
				updateSparkEngineBodyModel.Description = core.StringPtr("Updated Description")
				updateSparkEngineBodyModel.EngineDetails = updateSparkEngineBodyEngineDetailsModel
				updateSparkEngineBodyModel.EngineDisplayName = core.StringPtr("Updated Display Name")
				updateSparkEngineBodyModel.Tags = []string{"tag1", "tag2"}
				updateSparkEngineBodyModelAsPatch, asPatchErr := updateSparkEngineBodyModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSparkEngineOptions model
				updateSparkEngineOptionsModel := new(watsonxdatav2.UpdateSparkEngineOptions)
				updateSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				updateSparkEngineOptionsModel.Body = updateSparkEngineBodyModelAsPatch
				updateSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdateSparkEngineWithContext(ctx, updateSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdateSparkEngine(updateSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdateSparkEngineWithContext(ctx, updateSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateSparkEnginePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "spark engine for running sql queries", "engine_details": {"api_key": "apikey", "connection_string": "https://xyz.<region>.ae.cloud.123.com/v3/analytics_engines/<spark_iae_id>", "default_config": {"config1": "Config1", "config2": "Config2"}, "default_version": "4.8.3", "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications", "wxd_engine_endpoint": "$HOST/v1/1698311655308796/engines/spark817", "wxd_history_server_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server", "wxd_history_server_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server/ui"}, "engine_home_bucket_display_name": "test-spark-bucket", "engine_home_bucket_name": "test-spark-bucket", "engine_home_path": "spark/spark1234", "engine_home_volume": "test-spark-volume", "engine_home_volume_id": "1704979825978585", "engine_home_volume_name": "my-volume", "engine_home_volume_storage_class": "nfs-client", "engine_home_volume_storage_size": "5Gi", "engine_sub_type": "java/cpp", "instance_id": "spark-id", "managed_by": "fully/self", "scale_config": {"auto_scale_enabled": true, "current_number_of_nodes": 2, "maximum_number_of_nodes": 5, "minimum_number_of_nodes": 1, "node_type": "medium", "number_of_nodes": 2}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "origin": "external", "status": "Registered", "tags": ["Tags"], "type": "spark"}`)
				}))
			})
			It(`Invoke UpdateSparkEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdateSparkEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the SparkEngineResourceLimit model
				sparkEngineResourceLimitModel := new(watsonxdatav2.SparkEngineResourceLimit)
				sparkEngineResourceLimitModel.Cores = core.StringPtr("1")
				sparkEngineResourceLimitModel.Memory = core.StringPtr("4G")

				// Construct an instance of the UpdateSparkEngineBodyEngineDetails model
				updateSparkEngineBodyEngineDetailsModel := new(watsonxdatav2.UpdateSparkEngineBodyEngineDetails)
				updateSparkEngineBodyEngineDetailsModel.DefaultConfig = map[string]string{"key1": "testString"}
				updateSparkEngineBodyEngineDetailsModel.DefaultVersion = core.StringPtr("3.4")
				updateSparkEngineBodyEngineDetailsModel.EngineHomeBucketName = core.StringPtr("test-spark-bucket")
				updateSparkEngineBodyEngineDetailsModel.ResourceLimitEnabled = core.BoolPtr(true)
				updateSparkEngineBodyEngineDetailsModel.ResourceLimits = sparkEngineResourceLimitModel

				// Construct an instance of the UpdateSparkEngineBody model
				updateSparkEngineBodyModel := new(watsonxdatav2.UpdateSparkEngineBody)
				updateSparkEngineBodyModel.Description = core.StringPtr("Updated Description")
				updateSparkEngineBodyModel.EngineDetails = updateSparkEngineBodyEngineDetailsModel
				updateSparkEngineBodyModel.EngineDisplayName = core.StringPtr("Updated Display Name")
				updateSparkEngineBodyModel.Tags = []string{"tag1", "tag2"}
				updateSparkEngineBodyModelAsPatch, asPatchErr := updateSparkEngineBodyModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSparkEngineOptions model
				updateSparkEngineOptionsModel := new(watsonxdatav2.UpdateSparkEngineOptions)
				updateSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				updateSparkEngineOptionsModel.Body = updateSparkEngineBodyModelAsPatch
				updateSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdateSparkEngine(updateSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateSparkEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SparkEngineResourceLimit model
				sparkEngineResourceLimitModel := new(watsonxdatav2.SparkEngineResourceLimit)
				sparkEngineResourceLimitModel.Cores = core.StringPtr("1")
				sparkEngineResourceLimitModel.Memory = core.StringPtr("4G")

				// Construct an instance of the UpdateSparkEngineBodyEngineDetails model
				updateSparkEngineBodyEngineDetailsModel := new(watsonxdatav2.UpdateSparkEngineBodyEngineDetails)
				updateSparkEngineBodyEngineDetailsModel.DefaultConfig = map[string]string{"key1": "testString"}
				updateSparkEngineBodyEngineDetailsModel.DefaultVersion = core.StringPtr("3.4")
				updateSparkEngineBodyEngineDetailsModel.EngineHomeBucketName = core.StringPtr("test-spark-bucket")
				updateSparkEngineBodyEngineDetailsModel.ResourceLimitEnabled = core.BoolPtr(true)
				updateSparkEngineBodyEngineDetailsModel.ResourceLimits = sparkEngineResourceLimitModel

				// Construct an instance of the UpdateSparkEngineBody model
				updateSparkEngineBodyModel := new(watsonxdatav2.UpdateSparkEngineBody)
				updateSparkEngineBodyModel.Description = core.StringPtr("Updated Description")
				updateSparkEngineBodyModel.EngineDetails = updateSparkEngineBodyEngineDetailsModel
				updateSparkEngineBodyModel.EngineDisplayName = core.StringPtr("Updated Display Name")
				updateSparkEngineBodyModel.Tags = []string{"tag1", "tag2"}
				updateSparkEngineBodyModelAsPatch, asPatchErr := updateSparkEngineBodyModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSparkEngineOptions model
				updateSparkEngineOptionsModel := new(watsonxdatav2.UpdateSparkEngineOptions)
				updateSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				updateSparkEngineOptionsModel.Body = updateSparkEngineBodyModelAsPatch
				updateSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdateSparkEngine(updateSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateSparkEngineOptions model with no property values
				updateSparkEngineOptionsModelNew := new(watsonxdatav2.UpdateSparkEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdateSparkEngine(updateSparkEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateSparkEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SparkEngineResourceLimit model
				sparkEngineResourceLimitModel := new(watsonxdatav2.SparkEngineResourceLimit)
				sparkEngineResourceLimitModel.Cores = core.StringPtr("1")
				sparkEngineResourceLimitModel.Memory = core.StringPtr("4G")

				// Construct an instance of the UpdateSparkEngineBodyEngineDetails model
				updateSparkEngineBodyEngineDetailsModel := new(watsonxdatav2.UpdateSparkEngineBodyEngineDetails)
				updateSparkEngineBodyEngineDetailsModel.DefaultConfig = map[string]string{"key1": "testString"}
				updateSparkEngineBodyEngineDetailsModel.DefaultVersion = core.StringPtr("3.4")
				updateSparkEngineBodyEngineDetailsModel.EngineHomeBucketName = core.StringPtr("test-spark-bucket")
				updateSparkEngineBodyEngineDetailsModel.ResourceLimitEnabled = core.BoolPtr(true)
				updateSparkEngineBodyEngineDetailsModel.ResourceLimits = sparkEngineResourceLimitModel

				// Construct an instance of the UpdateSparkEngineBody model
				updateSparkEngineBodyModel := new(watsonxdatav2.UpdateSparkEngineBody)
				updateSparkEngineBodyModel.Description = core.StringPtr("Updated Description")
				updateSparkEngineBodyModel.EngineDetails = updateSparkEngineBodyEngineDetailsModel
				updateSparkEngineBodyModel.EngineDisplayName = core.StringPtr("Updated Display Name")
				updateSparkEngineBodyModel.Tags = []string{"tag1", "tag2"}
				updateSparkEngineBodyModelAsPatch, asPatchErr := updateSparkEngineBodyModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSparkEngineOptions model
				updateSparkEngineOptionsModel := new(watsonxdatav2.UpdateSparkEngineOptions)
				updateSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				updateSparkEngineOptionsModel.Body = updateSparkEngineBodyModelAsPatch
				updateSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdateSparkEngine(updateSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListSparkEngineApplications(listSparkEngineApplicationsOptions *ListSparkEngineApplicationsOptions) - Operation response error`, func() {
		listSparkEngineApplicationsPath := "/spark_engines/testString/applications"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkEngineApplicationsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListSparkEngineApplications with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkEngineApplicationsOptions model
				listSparkEngineApplicationsOptionsModel := new(watsonxdatav2.ListSparkEngineApplicationsOptions)
				listSparkEngineApplicationsOptionsModel.EngineID = core.StringPtr("testString")
				listSparkEngineApplicationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEngineApplicationsOptionsModel.State = []string{"testString"}
				listSparkEngineApplicationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListSparkEngineApplications(listSparkEngineApplicationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListSparkEngineApplications(listSparkEngineApplicationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListSparkEngineApplications(listSparkEngineApplicationsOptions *ListSparkEngineApplicationsOptions)`, func() {
		listSparkEngineApplicationsPath := "/spark_engines/testString/applications"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkEngineApplicationsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"applications": [{"application_details": {"application": "s3://mybucket/wordcount.py", "arguments": ["people.txt"], "class": "org.apache.spark.examples.SparkPi", "conf": {"spark_sample_config_properpty": "SparkSampleConfigProperpty"}, "env": {"sample_env_key": "SampleEnvKey"}, "files": "s3://mybucket/myfile.txt", "jars": "Jars", "name": "SparkApplicaton1", "packages": "org.apache.spark:example_1.2.3", "repositories": "https://repo1.maven.org/maven2/", "spark_version": "3.3", "runtime": {"spark_version": "3.4"}}, "application_id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "auto_termination_time": "2020-12-08T10:00:00.000Z", "creation_time": "Saturday 28 October 2023 07:17:06.856+0000", "deploy_mode": "stand-alone", "end_time": "2020-12-08T10:00:00.000Z", "failed_time": "FailedTime", "finish_time": "Saturday 28 October 2023 07:17:38.966+0000", "id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "job_endpoint": "<host>/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/engine_applications", "return_code": "0", "runtime": {"spark_version": "3.3"}, "service_instance_id": "ServiceInstanceID", "spark_application_id": "app-20231028071726-0000", "spark_application_name": "PythonWordCount", "spark_version": "3.3", "start_time": "Saturday 28 October 2023 07:17:26.649+0000", "state": "FINISHED", "state_details": [{"code": "Code", "message": "Message", "type": "Type"}], "submission_time": "2023-11-01T11:18:49.758Z", "template_id": "spark-3.3-jaas-v2-cp4d-template", "type": "iae", "volumes": [{"mount_path": "/mount/path", "name": "my-volume", "read_only": true, "source_sub_path": "/source/path"}], "wxd_application_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications/c7b3fccf-badb-46b0-b1ef-9b3154424021/ui"}]}`)
				}))
			})
			It(`Invoke ListSparkEngineApplications successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListSparkEngineApplicationsOptions model
				listSparkEngineApplicationsOptionsModel := new(watsonxdatav2.ListSparkEngineApplicationsOptions)
				listSparkEngineApplicationsOptionsModel.EngineID = core.StringPtr("testString")
				listSparkEngineApplicationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEngineApplicationsOptionsModel.State = []string{"testString"}
				listSparkEngineApplicationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListSparkEngineApplicationsWithContext(ctx, listSparkEngineApplicationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListSparkEngineApplications(listSparkEngineApplicationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListSparkEngineApplicationsWithContext(ctx, listSparkEngineApplicationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkEngineApplicationsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"applications": [{"application_details": {"application": "s3://mybucket/wordcount.py", "arguments": ["people.txt"], "class": "org.apache.spark.examples.SparkPi", "conf": {"spark_sample_config_properpty": "SparkSampleConfigProperpty"}, "env": {"sample_env_key": "SampleEnvKey"}, "files": "s3://mybucket/myfile.txt", "jars": "Jars", "name": "SparkApplicaton1", "packages": "org.apache.spark:example_1.2.3", "repositories": "https://repo1.maven.org/maven2/", "spark_version": "3.3", "runtime": {"spark_version": "3.4"}}, "application_id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "auto_termination_time": "2020-12-08T10:00:00.000Z", "creation_time": "Saturday 28 October 2023 07:17:06.856+0000", "deploy_mode": "stand-alone", "end_time": "2020-12-08T10:00:00.000Z", "failed_time": "FailedTime", "finish_time": "Saturday 28 October 2023 07:17:38.966+0000", "id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "job_endpoint": "<host>/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/engine_applications", "return_code": "0", "runtime": {"spark_version": "3.3"}, "service_instance_id": "ServiceInstanceID", "spark_application_id": "app-20231028071726-0000", "spark_application_name": "PythonWordCount", "spark_version": "3.3", "start_time": "Saturday 28 October 2023 07:17:26.649+0000", "state": "FINISHED", "state_details": [{"code": "Code", "message": "Message", "type": "Type"}], "submission_time": "2023-11-01T11:18:49.758Z", "template_id": "spark-3.3-jaas-v2-cp4d-template", "type": "iae", "volumes": [{"mount_path": "/mount/path", "name": "my-volume", "read_only": true, "source_sub_path": "/source/path"}], "wxd_application_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications/c7b3fccf-badb-46b0-b1ef-9b3154424021/ui"}]}`)
				}))
			})
			It(`Invoke ListSparkEngineApplications successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListSparkEngineApplications(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListSparkEngineApplicationsOptions model
				listSparkEngineApplicationsOptionsModel := new(watsonxdatav2.ListSparkEngineApplicationsOptions)
				listSparkEngineApplicationsOptionsModel.EngineID = core.StringPtr("testString")
				listSparkEngineApplicationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEngineApplicationsOptionsModel.State = []string{"testString"}
				listSparkEngineApplicationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListSparkEngineApplications(listSparkEngineApplicationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListSparkEngineApplications with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkEngineApplicationsOptions model
				listSparkEngineApplicationsOptionsModel := new(watsonxdatav2.ListSparkEngineApplicationsOptions)
				listSparkEngineApplicationsOptionsModel.EngineID = core.StringPtr("testString")
				listSparkEngineApplicationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEngineApplicationsOptionsModel.State = []string{"testString"}
				listSparkEngineApplicationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListSparkEngineApplications(listSparkEngineApplicationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListSparkEngineApplicationsOptions model with no property values
				listSparkEngineApplicationsOptionsModelNew := new(watsonxdatav2.ListSparkEngineApplicationsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListSparkEngineApplications(listSparkEngineApplicationsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListSparkEngineApplications successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkEngineApplicationsOptions model
				listSparkEngineApplicationsOptionsModel := new(watsonxdatav2.ListSparkEngineApplicationsOptions)
				listSparkEngineApplicationsOptionsModel.EngineID = core.StringPtr("testString")
				listSparkEngineApplicationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEngineApplicationsOptionsModel.State = []string{"testString"}
				listSparkEngineApplicationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListSparkEngineApplications(listSparkEngineApplicationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSparkEngineApplication(createSparkEngineApplicationOptions *CreateSparkEngineApplicationOptions) - Operation response error`, func() {
		createSparkEngineApplicationPath := "/spark_engines/testString/applications"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEngineApplicationPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateSparkEngineApplication with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SparkApplicationConfig model
				sparkApplicationConfigModel := new(watsonxdatav2.SparkApplicationConfig)
				sparkApplicationConfigModel.SparkSampleConfigProperpty = core.StringPtr("testString")

				// Construct an instance of the SparkApplicationEnv model
				sparkApplicationEnvModel := new(watsonxdatav2.SparkApplicationEnv)
				sparkApplicationEnvModel.SampleEnvKey = core.StringPtr("testString")

				// Construct an instance of the SparkApplicationDetailsRuntime model
				sparkApplicationDetailsRuntimeModel := new(watsonxdatav2.SparkApplicationDetailsRuntime)
				sparkApplicationDetailsRuntimeModel.SparkVersion = core.StringPtr("3.4")

				// Construct an instance of the SparkApplicationDetails model
				sparkApplicationDetailsModel := new(watsonxdatav2.SparkApplicationDetails)
				sparkApplicationDetailsModel.Application = core.StringPtr("/opt/ibm/spark/examples/src/main/python/wordcount.py")
				sparkApplicationDetailsModel.Arguments = []string{"/opt/ibm/spark/examples/src/main/resources/people.txt"}
				sparkApplicationDetailsModel.Class = core.StringPtr("org.apache.spark.examples.SparkPi")
				sparkApplicationDetailsModel.Conf = sparkApplicationConfigModel
				sparkApplicationDetailsModel.Env = sparkApplicationEnvModel
				sparkApplicationDetailsModel.Files = core.StringPtr("s3://mybucket/myfile.txt")
				sparkApplicationDetailsModel.Jars = core.StringPtr("testString")
				sparkApplicationDetailsModel.Name = core.StringPtr("SparkApplicaton1")
				sparkApplicationDetailsModel.Packages = core.StringPtr("org.apache.spark:example_1.2.3")
				sparkApplicationDetailsModel.Repositories = core.StringPtr("https://repo1.maven.org/maven2/")
				sparkApplicationDetailsModel.SparkVersion = core.StringPtr("3.3")
				sparkApplicationDetailsModel.Runtime = sparkApplicationDetailsRuntimeModel

				// Construct an instance of the SparkVolumeDetails model
				sparkVolumeDetailsModel := new(watsonxdatav2.SparkVolumeDetails)
				sparkVolumeDetailsModel.MountPath = core.StringPtr("/mount/path")
				sparkVolumeDetailsModel.Name = core.StringPtr("my-volume")
				sparkVolumeDetailsModel.ReadOnly = core.BoolPtr(true)
				sparkVolumeDetailsModel.SourceSubPath = core.StringPtr("/source/path")

				// Construct an instance of the CreateSparkEngineApplicationOptions model
				createSparkEngineApplicationOptionsModel := new(watsonxdatav2.CreateSparkEngineApplicationOptions)
				createSparkEngineApplicationOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.ApplicationDetails = sparkApplicationDetailsModel
				createSparkEngineApplicationOptionsModel.JobEndpoint = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.ServiceInstanceID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.Type = core.StringPtr("iae")
				createSparkEngineApplicationOptionsModel.Volumes = []watsonxdatav2.SparkVolumeDetails{*sparkVolumeDetailsModel}
				createSparkEngineApplicationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.State = []string{"testString"}
				createSparkEngineApplicationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateSparkEngineApplication(createSparkEngineApplicationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateSparkEngineApplication(createSparkEngineApplicationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSparkEngineApplication(createSparkEngineApplicationOptions *CreateSparkEngineApplicationOptions)`, func() {
		createSparkEngineApplicationPath := "/spark_engines/testString/applications"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEngineApplicationPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"application_details": {"application": "s3://mybucket/wordcount.py", "arguments": ["people.txt"], "class": "org.apache.spark.examples.SparkPi", "conf": {"spark_sample_config_properpty": "SparkSampleConfigProperpty"}, "env": {"sample_env_key": "SampleEnvKey"}, "files": "s3://mybucket/myfile.txt", "jars": "Jars", "name": "SparkApplicaton1", "packages": "org.apache.spark:example_1.2.3", "repositories": "https://repo1.maven.org/maven2/", "spark_version": "3.3", "runtime": {"spark_version": "3.4"}}, "application_id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "auto_termination_time": "2020-12-08T10:00:00.000Z", "creation_time": "Saturday 28 October 2023 07:17:06.856+0000", "deploy_mode": "stand-alone", "end_time": "2020-12-08T10:00:00.000Z", "failed_time": "FailedTime", "finish_time": "Saturday 28 October 2023 07:17:38.966+0000", "id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "job_endpoint": "<host>/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/engine_applications", "return_code": "0", "runtime": {"spark_version": "3.3"}, "service_instance_id": "ServiceInstanceID", "spark_application_id": "app-20231028071726-0000", "spark_application_name": "PythonWordCount", "spark_version": "3.3", "start_time": "Saturday 28 October 2023 07:17:26.649+0000", "state": "FINISHED", "state_details": [{"code": "Code", "message": "Message", "type": "Type"}], "submission_time": "2023-11-01T11:18:49.758Z", "template_id": "spark-3.3-jaas-v2-cp4d-template", "type": "iae", "volumes": [{"mount_path": "/mount/path", "name": "my-volume", "read_only": true, "source_sub_path": "/source/path"}], "wxd_application_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications/c7b3fccf-badb-46b0-b1ef-9b3154424021/ui"}`)
				}))
			})
			It(`Invoke CreateSparkEngineApplication successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the SparkApplicationConfig model
				sparkApplicationConfigModel := new(watsonxdatav2.SparkApplicationConfig)
				sparkApplicationConfigModel.SparkSampleConfigProperpty = core.StringPtr("testString")

				// Construct an instance of the SparkApplicationEnv model
				sparkApplicationEnvModel := new(watsonxdatav2.SparkApplicationEnv)
				sparkApplicationEnvModel.SampleEnvKey = core.StringPtr("testString")

				// Construct an instance of the SparkApplicationDetailsRuntime model
				sparkApplicationDetailsRuntimeModel := new(watsonxdatav2.SparkApplicationDetailsRuntime)
				sparkApplicationDetailsRuntimeModel.SparkVersion = core.StringPtr("3.4")

				// Construct an instance of the SparkApplicationDetails model
				sparkApplicationDetailsModel := new(watsonxdatav2.SparkApplicationDetails)
				sparkApplicationDetailsModel.Application = core.StringPtr("/opt/ibm/spark/examples/src/main/python/wordcount.py")
				sparkApplicationDetailsModel.Arguments = []string{"/opt/ibm/spark/examples/src/main/resources/people.txt"}
				sparkApplicationDetailsModel.Class = core.StringPtr("org.apache.spark.examples.SparkPi")
				sparkApplicationDetailsModel.Conf = sparkApplicationConfigModel
				sparkApplicationDetailsModel.Env = sparkApplicationEnvModel
				sparkApplicationDetailsModel.Files = core.StringPtr("s3://mybucket/myfile.txt")
				sparkApplicationDetailsModel.Jars = core.StringPtr("testString")
				sparkApplicationDetailsModel.Name = core.StringPtr("SparkApplicaton1")
				sparkApplicationDetailsModel.Packages = core.StringPtr("org.apache.spark:example_1.2.3")
				sparkApplicationDetailsModel.Repositories = core.StringPtr("https://repo1.maven.org/maven2/")
				sparkApplicationDetailsModel.SparkVersion = core.StringPtr("3.3")
				sparkApplicationDetailsModel.Runtime = sparkApplicationDetailsRuntimeModel

				// Construct an instance of the SparkVolumeDetails model
				sparkVolumeDetailsModel := new(watsonxdatav2.SparkVolumeDetails)
				sparkVolumeDetailsModel.MountPath = core.StringPtr("/mount/path")
				sparkVolumeDetailsModel.Name = core.StringPtr("my-volume")
				sparkVolumeDetailsModel.ReadOnly = core.BoolPtr(true)
				sparkVolumeDetailsModel.SourceSubPath = core.StringPtr("/source/path")

				// Construct an instance of the CreateSparkEngineApplicationOptions model
				createSparkEngineApplicationOptionsModel := new(watsonxdatav2.CreateSparkEngineApplicationOptions)
				createSparkEngineApplicationOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.ApplicationDetails = sparkApplicationDetailsModel
				createSparkEngineApplicationOptionsModel.JobEndpoint = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.ServiceInstanceID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.Type = core.StringPtr("iae")
				createSparkEngineApplicationOptionsModel.Volumes = []watsonxdatav2.SparkVolumeDetails{*sparkVolumeDetailsModel}
				createSparkEngineApplicationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.State = []string{"testString"}
				createSparkEngineApplicationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateSparkEngineApplicationWithContext(ctx, createSparkEngineApplicationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateSparkEngineApplication(createSparkEngineApplicationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateSparkEngineApplicationWithContext(ctx, createSparkEngineApplicationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEngineApplicationPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"application_details": {"application": "s3://mybucket/wordcount.py", "arguments": ["people.txt"], "class": "org.apache.spark.examples.SparkPi", "conf": {"spark_sample_config_properpty": "SparkSampleConfigProperpty"}, "env": {"sample_env_key": "SampleEnvKey"}, "files": "s3://mybucket/myfile.txt", "jars": "Jars", "name": "SparkApplicaton1", "packages": "org.apache.spark:example_1.2.3", "repositories": "https://repo1.maven.org/maven2/", "spark_version": "3.3", "runtime": {"spark_version": "3.4"}}, "application_id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "auto_termination_time": "2020-12-08T10:00:00.000Z", "creation_time": "Saturday 28 October 2023 07:17:06.856+0000", "deploy_mode": "stand-alone", "end_time": "2020-12-08T10:00:00.000Z", "failed_time": "FailedTime", "finish_time": "Saturday 28 October 2023 07:17:38.966+0000", "id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "job_endpoint": "<host>/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/engine_applications", "return_code": "0", "runtime": {"spark_version": "3.3"}, "service_instance_id": "ServiceInstanceID", "spark_application_id": "app-20231028071726-0000", "spark_application_name": "PythonWordCount", "spark_version": "3.3", "start_time": "Saturday 28 October 2023 07:17:26.649+0000", "state": "FINISHED", "state_details": [{"code": "Code", "message": "Message", "type": "Type"}], "submission_time": "2023-11-01T11:18:49.758Z", "template_id": "spark-3.3-jaas-v2-cp4d-template", "type": "iae", "volumes": [{"mount_path": "/mount/path", "name": "my-volume", "read_only": true, "source_sub_path": "/source/path"}], "wxd_application_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications/c7b3fccf-badb-46b0-b1ef-9b3154424021/ui"}`)
				}))
			})
			It(`Invoke CreateSparkEngineApplication successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateSparkEngineApplication(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the SparkApplicationConfig model
				sparkApplicationConfigModel := new(watsonxdatav2.SparkApplicationConfig)
				sparkApplicationConfigModel.SparkSampleConfigProperpty = core.StringPtr("testString")

				// Construct an instance of the SparkApplicationEnv model
				sparkApplicationEnvModel := new(watsonxdatav2.SparkApplicationEnv)
				sparkApplicationEnvModel.SampleEnvKey = core.StringPtr("testString")

				// Construct an instance of the SparkApplicationDetailsRuntime model
				sparkApplicationDetailsRuntimeModel := new(watsonxdatav2.SparkApplicationDetailsRuntime)
				sparkApplicationDetailsRuntimeModel.SparkVersion = core.StringPtr("3.4")

				// Construct an instance of the SparkApplicationDetails model
				sparkApplicationDetailsModel := new(watsonxdatav2.SparkApplicationDetails)
				sparkApplicationDetailsModel.Application = core.StringPtr("/opt/ibm/spark/examples/src/main/python/wordcount.py")
				sparkApplicationDetailsModel.Arguments = []string{"/opt/ibm/spark/examples/src/main/resources/people.txt"}
				sparkApplicationDetailsModel.Class = core.StringPtr("org.apache.spark.examples.SparkPi")
				sparkApplicationDetailsModel.Conf = sparkApplicationConfigModel
				sparkApplicationDetailsModel.Env = sparkApplicationEnvModel
				sparkApplicationDetailsModel.Files = core.StringPtr("s3://mybucket/myfile.txt")
				sparkApplicationDetailsModel.Jars = core.StringPtr("testString")
				sparkApplicationDetailsModel.Name = core.StringPtr("SparkApplicaton1")
				sparkApplicationDetailsModel.Packages = core.StringPtr("org.apache.spark:example_1.2.3")
				sparkApplicationDetailsModel.Repositories = core.StringPtr("https://repo1.maven.org/maven2/")
				sparkApplicationDetailsModel.SparkVersion = core.StringPtr("3.3")
				sparkApplicationDetailsModel.Runtime = sparkApplicationDetailsRuntimeModel

				// Construct an instance of the SparkVolumeDetails model
				sparkVolumeDetailsModel := new(watsonxdatav2.SparkVolumeDetails)
				sparkVolumeDetailsModel.MountPath = core.StringPtr("/mount/path")
				sparkVolumeDetailsModel.Name = core.StringPtr("my-volume")
				sparkVolumeDetailsModel.ReadOnly = core.BoolPtr(true)
				sparkVolumeDetailsModel.SourceSubPath = core.StringPtr("/source/path")

				// Construct an instance of the CreateSparkEngineApplicationOptions model
				createSparkEngineApplicationOptionsModel := new(watsonxdatav2.CreateSparkEngineApplicationOptions)
				createSparkEngineApplicationOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.ApplicationDetails = sparkApplicationDetailsModel
				createSparkEngineApplicationOptionsModel.JobEndpoint = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.ServiceInstanceID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.Type = core.StringPtr("iae")
				createSparkEngineApplicationOptionsModel.Volumes = []watsonxdatav2.SparkVolumeDetails{*sparkVolumeDetailsModel}
				createSparkEngineApplicationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.State = []string{"testString"}
				createSparkEngineApplicationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateSparkEngineApplication(createSparkEngineApplicationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateSparkEngineApplication with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SparkApplicationConfig model
				sparkApplicationConfigModel := new(watsonxdatav2.SparkApplicationConfig)
				sparkApplicationConfigModel.SparkSampleConfigProperpty = core.StringPtr("testString")

				// Construct an instance of the SparkApplicationEnv model
				sparkApplicationEnvModel := new(watsonxdatav2.SparkApplicationEnv)
				sparkApplicationEnvModel.SampleEnvKey = core.StringPtr("testString")

				// Construct an instance of the SparkApplicationDetailsRuntime model
				sparkApplicationDetailsRuntimeModel := new(watsonxdatav2.SparkApplicationDetailsRuntime)
				sparkApplicationDetailsRuntimeModel.SparkVersion = core.StringPtr("3.4")

				// Construct an instance of the SparkApplicationDetails model
				sparkApplicationDetailsModel := new(watsonxdatav2.SparkApplicationDetails)
				sparkApplicationDetailsModel.Application = core.StringPtr("/opt/ibm/spark/examples/src/main/python/wordcount.py")
				sparkApplicationDetailsModel.Arguments = []string{"/opt/ibm/spark/examples/src/main/resources/people.txt"}
				sparkApplicationDetailsModel.Class = core.StringPtr("org.apache.spark.examples.SparkPi")
				sparkApplicationDetailsModel.Conf = sparkApplicationConfigModel
				sparkApplicationDetailsModel.Env = sparkApplicationEnvModel
				sparkApplicationDetailsModel.Files = core.StringPtr("s3://mybucket/myfile.txt")
				sparkApplicationDetailsModel.Jars = core.StringPtr("testString")
				sparkApplicationDetailsModel.Name = core.StringPtr("SparkApplicaton1")
				sparkApplicationDetailsModel.Packages = core.StringPtr("org.apache.spark:example_1.2.3")
				sparkApplicationDetailsModel.Repositories = core.StringPtr("https://repo1.maven.org/maven2/")
				sparkApplicationDetailsModel.SparkVersion = core.StringPtr("3.3")
				sparkApplicationDetailsModel.Runtime = sparkApplicationDetailsRuntimeModel

				// Construct an instance of the SparkVolumeDetails model
				sparkVolumeDetailsModel := new(watsonxdatav2.SparkVolumeDetails)
				sparkVolumeDetailsModel.MountPath = core.StringPtr("/mount/path")
				sparkVolumeDetailsModel.Name = core.StringPtr("my-volume")
				sparkVolumeDetailsModel.ReadOnly = core.BoolPtr(true)
				sparkVolumeDetailsModel.SourceSubPath = core.StringPtr("/source/path")

				// Construct an instance of the CreateSparkEngineApplicationOptions model
				createSparkEngineApplicationOptionsModel := new(watsonxdatav2.CreateSparkEngineApplicationOptions)
				createSparkEngineApplicationOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.ApplicationDetails = sparkApplicationDetailsModel
				createSparkEngineApplicationOptionsModel.JobEndpoint = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.ServiceInstanceID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.Type = core.StringPtr("iae")
				createSparkEngineApplicationOptionsModel.Volumes = []watsonxdatav2.SparkVolumeDetails{*sparkVolumeDetailsModel}
				createSparkEngineApplicationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.State = []string{"testString"}
				createSparkEngineApplicationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateSparkEngineApplication(createSparkEngineApplicationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateSparkEngineApplicationOptions model with no property values
				createSparkEngineApplicationOptionsModelNew := new(watsonxdatav2.CreateSparkEngineApplicationOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateSparkEngineApplication(createSparkEngineApplicationOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateSparkEngineApplication successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SparkApplicationConfig model
				sparkApplicationConfigModel := new(watsonxdatav2.SparkApplicationConfig)
				sparkApplicationConfigModel.SparkSampleConfigProperpty = core.StringPtr("testString")

				// Construct an instance of the SparkApplicationEnv model
				sparkApplicationEnvModel := new(watsonxdatav2.SparkApplicationEnv)
				sparkApplicationEnvModel.SampleEnvKey = core.StringPtr("testString")

				// Construct an instance of the SparkApplicationDetailsRuntime model
				sparkApplicationDetailsRuntimeModel := new(watsonxdatav2.SparkApplicationDetailsRuntime)
				sparkApplicationDetailsRuntimeModel.SparkVersion = core.StringPtr("3.4")

				// Construct an instance of the SparkApplicationDetails model
				sparkApplicationDetailsModel := new(watsonxdatav2.SparkApplicationDetails)
				sparkApplicationDetailsModel.Application = core.StringPtr("/opt/ibm/spark/examples/src/main/python/wordcount.py")
				sparkApplicationDetailsModel.Arguments = []string{"/opt/ibm/spark/examples/src/main/resources/people.txt"}
				sparkApplicationDetailsModel.Class = core.StringPtr("org.apache.spark.examples.SparkPi")
				sparkApplicationDetailsModel.Conf = sparkApplicationConfigModel
				sparkApplicationDetailsModel.Env = sparkApplicationEnvModel
				sparkApplicationDetailsModel.Files = core.StringPtr("s3://mybucket/myfile.txt")
				sparkApplicationDetailsModel.Jars = core.StringPtr("testString")
				sparkApplicationDetailsModel.Name = core.StringPtr("SparkApplicaton1")
				sparkApplicationDetailsModel.Packages = core.StringPtr("org.apache.spark:example_1.2.3")
				sparkApplicationDetailsModel.Repositories = core.StringPtr("https://repo1.maven.org/maven2/")
				sparkApplicationDetailsModel.SparkVersion = core.StringPtr("3.3")
				sparkApplicationDetailsModel.Runtime = sparkApplicationDetailsRuntimeModel

				// Construct an instance of the SparkVolumeDetails model
				sparkVolumeDetailsModel := new(watsonxdatav2.SparkVolumeDetails)
				sparkVolumeDetailsModel.MountPath = core.StringPtr("/mount/path")
				sparkVolumeDetailsModel.Name = core.StringPtr("my-volume")
				sparkVolumeDetailsModel.ReadOnly = core.BoolPtr(true)
				sparkVolumeDetailsModel.SourceSubPath = core.StringPtr("/source/path")

				// Construct an instance of the CreateSparkEngineApplicationOptions model
				createSparkEngineApplicationOptionsModel := new(watsonxdatav2.CreateSparkEngineApplicationOptions)
				createSparkEngineApplicationOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.ApplicationDetails = sparkApplicationDetailsModel
				createSparkEngineApplicationOptionsModel.JobEndpoint = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.ServiceInstanceID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.Type = core.StringPtr("iae")
				createSparkEngineApplicationOptionsModel.Volumes = []watsonxdatav2.SparkVolumeDetails{*sparkVolumeDetailsModel}
				createSparkEngineApplicationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.State = []string{"testString"}
				createSparkEngineApplicationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateSparkEngineApplication(createSparkEngineApplicationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteSparkEngineApplications(deleteSparkEngineApplicationsOptions *DeleteSparkEngineApplicationsOptions)`, func() {
		deleteSparkEngineApplicationsPath := "/spark_engines/testString/applications"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteSparkEngineApplicationsPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["application_id"]).To(Equal([]string{"testString"}))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteSparkEngineApplications successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteSparkEngineApplications(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteSparkEngineApplicationsOptions model
				deleteSparkEngineApplicationsOptionsModel := new(watsonxdatav2.DeleteSparkEngineApplicationsOptions)
				deleteSparkEngineApplicationsOptionsModel.EngineID = core.StringPtr("testString")
				deleteSparkEngineApplicationsOptionsModel.ApplicationID = core.StringPtr("testString")
				deleteSparkEngineApplicationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteSparkEngineApplicationsOptionsModel.State = []string{"testString"}
				deleteSparkEngineApplicationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteSparkEngineApplications(deleteSparkEngineApplicationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteSparkEngineApplications with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteSparkEngineApplicationsOptions model
				deleteSparkEngineApplicationsOptionsModel := new(watsonxdatav2.DeleteSparkEngineApplicationsOptions)
				deleteSparkEngineApplicationsOptionsModel.EngineID = core.StringPtr("testString")
				deleteSparkEngineApplicationsOptionsModel.ApplicationID = core.StringPtr("testString")
				deleteSparkEngineApplicationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteSparkEngineApplicationsOptionsModel.State = []string{"testString"}
				deleteSparkEngineApplicationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteSparkEngineApplications(deleteSparkEngineApplicationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteSparkEngineApplicationsOptions model with no property values
				deleteSparkEngineApplicationsOptionsModelNew := new(watsonxdatav2.DeleteSparkEngineApplicationsOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteSparkEngineApplications(deleteSparkEngineApplicationsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSparkEngineApplicationStatus(getSparkEngineApplicationStatusOptions *GetSparkEngineApplicationStatusOptions) - Operation response error`, func() {
		getSparkEngineApplicationStatusPath := "/spark_engines/testString/applications/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEngineApplicationStatusPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetSparkEngineApplicationStatus with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineApplicationStatusOptions model
				getSparkEngineApplicationStatusOptionsModel := new(watsonxdatav2.GetSparkEngineApplicationStatusOptions)
				getSparkEngineApplicationStatusOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.ApplicationID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetSparkEngineApplicationStatus(getSparkEngineApplicationStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetSparkEngineApplicationStatus(getSparkEngineApplicationStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSparkEngineApplicationStatus(getSparkEngineApplicationStatusOptions *GetSparkEngineApplicationStatusOptions)`, func() {
		getSparkEngineApplicationStatusPath := "/spark_engines/testString/applications/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEngineApplicationStatusPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"application_details": {"application": "s3://mybucket/wordcount.py", "arguments": ["people.txt"], "class": "org.apache.spark.examples.SparkPi", "conf": {"spark_sample_config_properpty": "SparkSampleConfigProperpty"}, "env": {"sample_env_key": "SampleEnvKey"}, "files": "s3://mybucket/myfile.txt", "jars": "Jars", "name": "SparkApplicaton1", "packages": "org.apache.spark:example_1.2.3", "repositories": "https://repo1.maven.org/maven2/", "spark_version": "3.3", "runtime": {"spark_version": "3.4"}}, "application_id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "auto_termination_time": "2020-12-08T10:00:00.000Z", "creation_time": "Saturday 28 October 2023 07:17:06.856+0000", "deploy_mode": "stand-alone", "end_time": "2020-12-08T10:00:00.000Z", "failed_time": "FailedTime", "finish_time": "Saturday 28 October 2023 07:17:38.966+0000", "id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "job_endpoint": "<host>/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/engine_applications", "return_code": "0", "runtime": {"spark_version": "3.3"}, "service_instance_id": "ServiceInstanceID", "spark_application_id": "app-20231028071726-0000", "spark_application_name": "PythonWordCount", "spark_version": "3.3", "start_time": "Saturday 28 October 2023 07:17:26.649+0000", "state": "FINISHED", "state_details": [{"code": "Code", "message": "Message", "type": "Type"}], "submission_time": "2023-11-01T11:18:49.758Z", "template_id": "spark-3.3-jaas-v2-cp4d-template", "type": "iae", "volumes": [{"mount_path": "/mount/path", "name": "my-volume", "read_only": true, "source_sub_path": "/source/path"}], "wxd_application_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications/c7b3fccf-badb-46b0-b1ef-9b3154424021/ui"}`)
				}))
			})
			It(`Invoke GetSparkEngineApplicationStatus successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetSparkEngineApplicationStatusOptions model
				getSparkEngineApplicationStatusOptionsModel := new(watsonxdatav2.GetSparkEngineApplicationStatusOptions)
				getSparkEngineApplicationStatusOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.ApplicationID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetSparkEngineApplicationStatusWithContext(ctx, getSparkEngineApplicationStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetSparkEngineApplicationStatus(getSparkEngineApplicationStatusOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetSparkEngineApplicationStatusWithContext(ctx, getSparkEngineApplicationStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEngineApplicationStatusPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"application_details": {"application": "s3://mybucket/wordcount.py", "arguments": ["people.txt"], "class": "org.apache.spark.examples.SparkPi", "conf": {"spark_sample_config_properpty": "SparkSampleConfigProperpty"}, "env": {"sample_env_key": "SampleEnvKey"}, "files": "s3://mybucket/myfile.txt", "jars": "Jars", "name": "SparkApplicaton1", "packages": "org.apache.spark:example_1.2.3", "repositories": "https://repo1.maven.org/maven2/", "spark_version": "3.3", "runtime": {"spark_version": "3.4"}}, "application_id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "auto_termination_time": "2020-12-08T10:00:00.000Z", "creation_time": "Saturday 28 October 2023 07:17:06.856+0000", "deploy_mode": "stand-alone", "end_time": "2020-12-08T10:00:00.000Z", "failed_time": "FailedTime", "finish_time": "Saturday 28 October 2023 07:17:38.966+0000", "id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "job_endpoint": "<host>/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/engine_applications", "return_code": "0", "runtime": {"spark_version": "3.3"}, "service_instance_id": "ServiceInstanceID", "spark_application_id": "app-20231028071726-0000", "spark_application_name": "PythonWordCount", "spark_version": "3.3", "start_time": "Saturday 28 October 2023 07:17:26.649+0000", "state": "FINISHED", "state_details": [{"code": "Code", "message": "Message", "type": "Type"}], "submission_time": "2023-11-01T11:18:49.758Z", "template_id": "spark-3.3-jaas-v2-cp4d-template", "type": "iae", "volumes": [{"mount_path": "/mount/path", "name": "my-volume", "read_only": true, "source_sub_path": "/source/path"}], "wxd_application_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications/c7b3fccf-badb-46b0-b1ef-9b3154424021/ui"}`)
				}))
			})
			It(`Invoke GetSparkEngineApplicationStatus successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetSparkEngineApplicationStatus(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSparkEngineApplicationStatusOptions model
				getSparkEngineApplicationStatusOptionsModel := new(watsonxdatav2.GetSparkEngineApplicationStatusOptions)
				getSparkEngineApplicationStatusOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.ApplicationID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetSparkEngineApplicationStatus(getSparkEngineApplicationStatusOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetSparkEngineApplicationStatus with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineApplicationStatusOptions model
				getSparkEngineApplicationStatusOptionsModel := new(watsonxdatav2.GetSparkEngineApplicationStatusOptions)
				getSparkEngineApplicationStatusOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.ApplicationID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetSparkEngineApplicationStatus(getSparkEngineApplicationStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetSparkEngineApplicationStatusOptions model with no property values
				getSparkEngineApplicationStatusOptionsModelNew := new(watsonxdatav2.GetSparkEngineApplicationStatusOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetSparkEngineApplicationStatus(getSparkEngineApplicationStatusOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetSparkEngineApplicationStatus successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineApplicationStatusOptions model
				getSparkEngineApplicationStatusOptionsModel := new(watsonxdatav2.GetSparkEngineApplicationStatusOptions)
				getSparkEngineApplicationStatusOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.ApplicationID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetSparkEngineApplicationStatus(getSparkEngineApplicationStatusOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListSparkEngineCatalogs(listSparkEngineCatalogsOptions *ListSparkEngineCatalogsOptions) - Operation response error`, func() {
		listSparkEngineCatalogsPath := "/spark_engines/testString/catalogs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkEngineCatalogsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListSparkEngineCatalogs with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkEngineCatalogsOptions model
				listSparkEngineCatalogsOptionsModel := new(watsonxdatav2.ListSparkEngineCatalogsOptions)
				listSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListSparkEngineCatalogs(listSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListSparkEngineCatalogs(listSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListSparkEngineCatalogs(listSparkEngineCatalogsOptions *ListSparkEngineCatalogsOptions)`, func() {
		listSparkEngineCatalogsPath := "/spark_engines/testString/catalogs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkEngineCatalogsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke ListSparkEngineCatalogs successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListSparkEngineCatalogsOptions model
				listSparkEngineCatalogsOptionsModel := new(watsonxdatav2.ListSparkEngineCatalogsOptions)
				listSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListSparkEngineCatalogsWithContext(ctx, listSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListSparkEngineCatalogs(listSparkEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListSparkEngineCatalogsWithContext(ctx, listSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkEngineCatalogsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke ListSparkEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListSparkEngineCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListSparkEngineCatalogsOptions model
				listSparkEngineCatalogsOptionsModel := new(watsonxdatav2.ListSparkEngineCatalogsOptions)
				listSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListSparkEngineCatalogs(listSparkEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListSparkEngineCatalogs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkEngineCatalogsOptions model
				listSparkEngineCatalogsOptionsModel := new(watsonxdatav2.ListSparkEngineCatalogsOptions)
				listSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListSparkEngineCatalogs(listSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListSparkEngineCatalogsOptions model with no property values
				listSparkEngineCatalogsOptionsModelNew := new(watsonxdatav2.ListSparkEngineCatalogsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListSparkEngineCatalogs(listSparkEngineCatalogsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListSparkEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkEngineCatalogsOptions model
				listSparkEngineCatalogsOptionsModel := new(watsonxdatav2.ListSparkEngineCatalogsOptions)
				listSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListSparkEngineCatalogs(listSparkEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSparkEngineCatalogs(createSparkEngineCatalogsOptions *CreateSparkEngineCatalogsOptions) - Operation response error`, func() {
		createSparkEngineCatalogsPath := "/spark_engines/testString/catalogs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEngineCatalogsPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateSparkEngineCatalogs with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSparkEngineCatalogsOptions model
				createSparkEngineCatalogsOptionsModel := new(watsonxdatav2.CreateSparkEngineCatalogsOptions)
				createSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				createSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateSparkEngineCatalogs(createSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateSparkEngineCatalogs(createSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSparkEngineCatalogs(createSparkEngineCatalogsOptions *CreateSparkEngineCatalogsOptions)`, func() {
		createSparkEngineCatalogsPath := "/spark_engines/testString/catalogs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEngineCatalogsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke CreateSparkEngineCatalogs successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreateSparkEngineCatalogsOptions model
				createSparkEngineCatalogsOptionsModel := new(watsonxdatav2.CreateSparkEngineCatalogsOptions)
				createSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				createSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateSparkEngineCatalogsWithContext(ctx, createSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateSparkEngineCatalogs(createSparkEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateSparkEngineCatalogsWithContext(ctx, createSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEngineCatalogsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke CreateSparkEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateSparkEngineCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreateSparkEngineCatalogsOptions model
				createSparkEngineCatalogsOptionsModel := new(watsonxdatav2.CreateSparkEngineCatalogsOptions)
				createSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				createSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateSparkEngineCatalogs(createSparkEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateSparkEngineCatalogs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSparkEngineCatalogsOptions model
				createSparkEngineCatalogsOptionsModel := new(watsonxdatav2.CreateSparkEngineCatalogsOptions)
				createSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				createSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateSparkEngineCatalogs(createSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateSparkEngineCatalogsOptions model with no property values
				createSparkEngineCatalogsOptionsModelNew := new(watsonxdatav2.CreateSparkEngineCatalogsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateSparkEngineCatalogs(createSparkEngineCatalogsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateSparkEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSparkEngineCatalogsOptions model
				createSparkEngineCatalogsOptionsModel := new(watsonxdatav2.CreateSparkEngineCatalogsOptions)
				createSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				createSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateSparkEngineCatalogs(createSparkEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteSparkEngineCatalogs(deleteSparkEngineCatalogsOptions *DeleteSparkEngineCatalogsOptions)`, func() {
		deleteSparkEngineCatalogsPath := "/spark_engines/testString/catalogs"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteSparkEngineCatalogsPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["catalog_names"]).To(Equal([]string{"testString"}))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteSparkEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteSparkEngineCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteSparkEngineCatalogsOptions model
				deleteSparkEngineCatalogsOptionsModel := new(watsonxdatav2.DeleteSparkEngineCatalogsOptions)
				deleteSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				deleteSparkEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				deleteSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteSparkEngineCatalogs(deleteSparkEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteSparkEngineCatalogs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteSparkEngineCatalogsOptions model
				deleteSparkEngineCatalogsOptionsModel := new(watsonxdatav2.DeleteSparkEngineCatalogsOptions)
				deleteSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				deleteSparkEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				deleteSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteSparkEngineCatalogs(deleteSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteSparkEngineCatalogsOptions model with no property values
				deleteSparkEngineCatalogsOptionsModelNew := new(watsonxdatav2.DeleteSparkEngineCatalogsOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteSparkEngineCatalogs(deleteSparkEngineCatalogsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSparkEngineCatalog(getSparkEngineCatalogOptions *GetSparkEngineCatalogOptions) - Operation response error`, func() {
		getSparkEngineCatalogPath := "/spark_engines/testString/catalogs/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEngineCatalogPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetSparkEngineCatalog with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineCatalogOptions model
				getSparkEngineCatalogOptionsModel := new(watsonxdatav2.GetSparkEngineCatalogOptions)
				getSparkEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetSparkEngineCatalog(getSparkEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetSparkEngineCatalog(getSparkEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSparkEngineCatalog(getSparkEngineCatalogOptions *GetSparkEngineCatalogOptions)`, func() {
		getSparkEngineCatalogPath := "/spark_engines/testString/catalogs/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEngineCatalogPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke GetSparkEngineCatalog successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetSparkEngineCatalogOptions model
				getSparkEngineCatalogOptionsModel := new(watsonxdatav2.GetSparkEngineCatalogOptions)
				getSparkEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetSparkEngineCatalogWithContext(ctx, getSparkEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetSparkEngineCatalog(getSparkEngineCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetSparkEngineCatalogWithContext(ctx, getSparkEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEngineCatalogPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke GetSparkEngineCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetSparkEngineCatalog(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSparkEngineCatalogOptions model
				getSparkEngineCatalogOptionsModel := new(watsonxdatav2.GetSparkEngineCatalogOptions)
				getSparkEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetSparkEngineCatalog(getSparkEngineCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetSparkEngineCatalog with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineCatalogOptions model
				getSparkEngineCatalogOptionsModel := new(watsonxdatav2.GetSparkEngineCatalogOptions)
				getSparkEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetSparkEngineCatalog(getSparkEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetSparkEngineCatalogOptions model with no property values
				getSparkEngineCatalogOptionsModelNew := new(watsonxdatav2.GetSparkEngineCatalogOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetSparkEngineCatalog(getSparkEngineCatalogOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetSparkEngineCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineCatalogOptions model
				getSparkEngineCatalogOptionsModel := new(watsonxdatav2.GetSparkEngineCatalogOptions)
				getSparkEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetSparkEngineCatalog(getSparkEngineCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSparkEngineHistoryServer(getSparkEngineHistoryServerOptions *GetSparkEngineHistoryServerOptions) - Operation response error`, func() {
		getSparkEngineHistoryServerPath := "/spark_engines/testString/history_server"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEngineHistoryServerPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetSparkEngineHistoryServer with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineHistoryServerOptions model
				getSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.GetSparkEngineHistoryServerOptions)
				getSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetSparkEngineHistoryServer(getSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetSparkEngineHistoryServer(getSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSparkEngineHistoryServer(getSparkEngineHistoryServerOptions *GetSparkEngineHistoryServerOptions)`, func() {
		getSparkEngineHistoryServerPath := "/spark_engines/testString/history_server"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEngineHistoryServerPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"auto_termination_time": "2022-02-24T07:37:47Z", "cores": "1", "memory": "4G", "start_time": "2022-02-21T07:37:47Z", "state": "started"}`)
				}))
			})
			It(`Invoke GetSparkEngineHistoryServer successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetSparkEngineHistoryServerOptions model
				getSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.GetSparkEngineHistoryServerOptions)
				getSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetSparkEngineHistoryServerWithContext(ctx, getSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetSparkEngineHistoryServer(getSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetSparkEngineHistoryServerWithContext(ctx, getSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEngineHistoryServerPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"auto_termination_time": "2022-02-24T07:37:47Z", "cores": "1", "memory": "4G", "start_time": "2022-02-21T07:37:47Z", "state": "started"}`)
				}))
			})
			It(`Invoke GetSparkEngineHistoryServer successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetSparkEngineHistoryServer(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSparkEngineHistoryServerOptions model
				getSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.GetSparkEngineHistoryServerOptions)
				getSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetSparkEngineHistoryServer(getSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetSparkEngineHistoryServer with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineHistoryServerOptions model
				getSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.GetSparkEngineHistoryServerOptions)
				getSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetSparkEngineHistoryServer(getSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetSparkEngineHistoryServerOptions model with no property values
				getSparkEngineHistoryServerOptionsModelNew := new(watsonxdatav2.GetSparkEngineHistoryServerOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetSparkEngineHistoryServer(getSparkEngineHistoryServerOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetSparkEngineHistoryServer successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineHistoryServerOptions model
				getSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.GetSparkEngineHistoryServerOptions)
				getSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetSparkEngineHistoryServer(getSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`StartSparkEngineHistoryServer(startSparkEngineHistoryServerOptions *StartSparkEngineHistoryServerOptions) - Operation response error`, func() {
		startSparkEngineHistoryServerPath := "/spark_engines/testString/history_server"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(startSparkEngineHistoryServerPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke StartSparkEngineHistoryServer with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the StartSparkEngineHistoryServerOptions model
				startSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.StartSparkEngineHistoryServerOptions)
				startSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				startSparkEngineHistoryServerOptionsModel.Cores = core.StringPtr("1")
				startSparkEngineHistoryServerOptionsModel.Memory = core.StringPtr("4G")
				startSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				startSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.StartSparkEngineHistoryServer(startSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.StartSparkEngineHistoryServer(startSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`StartSparkEngineHistoryServer(startSparkEngineHistoryServerOptions *StartSparkEngineHistoryServerOptions)`, func() {
		startSparkEngineHistoryServerPath := "/spark_engines/testString/history_server"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(startSparkEngineHistoryServerPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"auto_termination_time": "2022-02-24T07:37:47Z", "cores": "1", "memory": "4G", "start_time": "2022-02-21T07:37:47Z", "state": "started"}`)
				}))
			})
			It(`Invoke StartSparkEngineHistoryServer successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the StartSparkEngineHistoryServerOptions model
				startSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.StartSparkEngineHistoryServerOptions)
				startSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				startSparkEngineHistoryServerOptionsModel.Cores = core.StringPtr("1")
				startSparkEngineHistoryServerOptionsModel.Memory = core.StringPtr("4G")
				startSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				startSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.StartSparkEngineHistoryServerWithContext(ctx, startSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.StartSparkEngineHistoryServer(startSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.StartSparkEngineHistoryServerWithContext(ctx, startSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(startSparkEngineHistoryServerPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"auto_termination_time": "2022-02-24T07:37:47Z", "cores": "1", "memory": "4G", "start_time": "2022-02-21T07:37:47Z", "state": "started"}`)
				}))
			})
			It(`Invoke StartSparkEngineHistoryServer successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.StartSparkEngineHistoryServer(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the StartSparkEngineHistoryServerOptions model
				startSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.StartSparkEngineHistoryServerOptions)
				startSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				startSparkEngineHistoryServerOptionsModel.Cores = core.StringPtr("1")
				startSparkEngineHistoryServerOptionsModel.Memory = core.StringPtr("4G")
				startSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				startSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.StartSparkEngineHistoryServer(startSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke StartSparkEngineHistoryServer with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the StartSparkEngineHistoryServerOptions model
				startSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.StartSparkEngineHistoryServerOptions)
				startSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				startSparkEngineHistoryServerOptionsModel.Cores = core.StringPtr("1")
				startSparkEngineHistoryServerOptionsModel.Memory = core.StringPtr("4G")
				startSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				startSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.StartSparkEngineHistoryServer(startSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the StartSparkEngineHistoryServerOptions model with no property values
				startSparkEngineHistoryServerOptionsModelNew := new(watsonxdatav2.StartSparkEngineHistoryServerOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.StartSparkEngineHistoryServer(startSparkEngineHistoryServerOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke StartSparkEngineHistoryServer successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the StartSparkEngineHistoryServerOptions model
				startSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.StartSparkEngineHistoryServerOptions)
				startSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				startSparkEngineHistoryServerOptionsModel.Cores = core.StringPtr("1")
				startSparkEngineHistoryServerOptionsModel.Memory = core.StringPtr("4G")
				startSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				startSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.StartSparkEngineHistoryServer(startSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteSparkEngineHistoryServer(deleteSparkEngineHistoryServerOptions *DeleteSparkEngineHistoryServerOptions)`, func() {
		deleteSparkEngineHistoryServerPath := "/spark_engines/testString/history_server"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteSparkEngineHistoryServerPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteSparkEngineHistoryServer successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteSparkEngineHistoryServer(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteSparkEngineHistoryServerOptions model
				deleteSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.DeleteSparkEngineHistoryServerOptions)
				deleteSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				deleteSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteSparkEngineHistoryServer(deleteSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteSparkEngineHistoryServer with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteSparkEngineHistoryServerOptions model
				deleteSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.DeleteSparkEngineHistoryServerOptions)
				deleteSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				deleteSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteSparkEngineHistoryServer(deleteSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteSparkEngineHistoryServerOptions model with no property values
				deleteSparkEngineHistoryServerOptionsModelNew := new(watsonxdatav2.DeleteSparkEngineHistoryServerOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteSparkEngineHistoryServer(deleteSparkEngineHistoryServerOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PauseSparkEngine(pauseSparkEngineOptions *PauseSparkEngineOptions) - Operation response error`, func() {
		pauseSparkEnginePath := "/spark_engines/testString/pause"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(pauseSparkEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke PauseSparkEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PauseSparkEngineOptions model
				pauseSparkEngineOptionsModel := new(watsonxdatav2.PauseSparkEngineOptions)
				pauseSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				pauseSparkEngineOptionsModel.Force = core.BoolPtr(true)
				pauseSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pauseSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.PauseSparkEngine(pauseSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.PauseSparkEngine(pauseSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PauseSparkEngine(pauseSparkEngineOptions *PauseSparkEngineOptions)`, func() {
		pauseSparkEnginePath := "/spark_engines/testString/pause"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(pauseSparkEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke PauseSparkEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the PauseSparkEngineOptions model
				pauseSparkEngineOptionsModel := new(watsonxdatav2.PauseSparkEngineOptions)
				pauseSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				pauseSparkEngineOptionsModel.Force = core.BoolPtr(true)
				pauseSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pauseSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.PauseSparkEngineWithContext(ctx, pauseSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.PauseSparkEngine(pauseSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.PauseSparkEngineWithContext(ctx, pauseSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(pauseSparkEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke PauseSparkEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.PauseSparkEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the PauseSparkEngineOptions model
				pauseSparkEngineOptionsModel := new(watsonxdatav2.PauseSparkEngineOptions)
				pauseSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				pauseSparkEngineOptionsModel.Force = core.BoolPtr(true)
				pauseSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pauseSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.PauseSparkEngine(pauseSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke PauseSparkEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PauseSparkEngineOptions model
				pauseSparkEngineOptionsModel := new(watsonxdatav2.PauseSparkEngineOptions)
				pauseSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				pauseSparkEngineOptionsModel.Force = core.BoolPtr(true)
				pauseSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pauseSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.PauseSparkEngine(pauseSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the PauseSparkEngineOptions model with no property values
				pauseSparkEngineOptionsModelNew := new(watsonxdatav2.PauseSparkEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.PauseSparkEngine(pauseSparkEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke PauseSparkEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PauseSparkEngineOptions model
				pauseSparkEngineOptionsModel := new(watsonxdatav2.PauseSparkEngineOptions)
				pauseSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				pauseSparkEngineOptionsModel.Force = core.BoolPtr(true)
				pauseSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pauseSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.PauseSparkEngine(pauseSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ResumeSparkEngine(resumeSparkEngineOptions *ResumeSparkEngineOptions) - Operation response error`, func() {
		resumeSparkEnginePath := "/spark_engines/testString/resume"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(resumeSparkEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ResumeSparkEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ResumeSparkEngineOptions model
				resumeSparkEngineOptionsModel := new(watsonxdatav2.ResumeSparkEngineOptions)
				resumeSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumeSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumeSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ResumeSparkEngine(resumeSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ResumeSparkEngine(resumeSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ResumeSparkEngine(resumeSparkEngineOptions *ResumeSparkEngineOptions)`, func() {
		resumeSparkEnginePath := "/spark_engines/testString/resume"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(resumeSparkEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke ResumeSparkEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ResumeSparkEngineOptions model
				resumeSparkEngineOptionsModel := new(watsonxdatav2.ResumeSparkEngineOptions)
				resumeSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumeSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumeSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ResumeSparkEngineWithContext(ctx, resumeSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ResumeSparkEngine(resumeSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ResumeSparkEngineWithContext(ctx, resumeSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(resumeSparkEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke ResumeSparkEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ResumeSparkEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ResumeSparkEngineOptions model
				resumeSparkEngineOptionsModel := new(watsonxdatav2.ResumeSparkEngineOptions)
				resumeSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumeSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumeSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ResumeSparkEngine(resumeSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ResumeSparkEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ResumeSparkEngineOptions model
				resumeSparkEngineOptionsModel := new(watsonxdatav2.ResumeSparkEngineOptions)
				resumeSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumeSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumeSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ResumeSparkEngine(resumeSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ResumeSparkEngineOptions model with no property values
				resumeSparkEngineOptionsModelNew := new(watsonxdatav2.ResumeSparkEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ResumeSparkEngine(resumeSparkEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ResumeSparkEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ResumeSparkEngineOptions model
				resumeSparkEngineOptionsModel := new(watsonxdatav2.ResumeSparkEngineOptions)
				resumeSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumeSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumeSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ResumeSparkEngine(resumeSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ScaleSparkEngine(scaleSparkEngineOptions *ScaleSparkEngineOptions) - Operation response error`, func() {
		scaleSparkEnginePath := "/spark_engines/testString/scale"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(scaleSparkEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ScaleSparkEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ScaleSparkEngineOptions model
				scaleSparkEngineOptionsModel := new(watsonxdatav2.ScaleSparkEngineOptions)
				scaleSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				scaleSparkEngineOptionsModel.NumberOfNodes = core.Int64Ptr(int64(2))
				scaleSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scaleSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ScaleSparkEngine(scaleSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ScaleSparkEngine(scaleSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ScaleSparkEngine(scaleSparkEngineOptions *ScaleSparkEngineOptions)`, func() {
		scaleSparkEnginePath := "/spark_engines/testString/scale"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(scaleSparkEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke ScaleSparkEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ScaleSparkEngineOptions model
				scaleSparkEngineOptionsModel := new(watsonxdatav2.ScaleSparkEngineOptions)
				scaleSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				scaleSparkEngineOptionsModel.NumberOfNodes = core.Int64Ptr(int64(2))
				scaleSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scaleSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ScaleSparkEngineWithContext(ctx, scaleSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ScaleSparkEngine(scaleSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ScaleSparkEngineWithContext(ctx, scaleSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(scaleSparkEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke ScaleSparkEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ScaleSparkEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ScaleSparkEngineOptions model
				scaleSparkEngineOptionsModel := new(watsonxdatav2.ScaleSparkEngineOptions)
				scaleSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				scaleSparkEngineOptionsModel.NumberOfNodes = core.Int64Ptr(int64(2))
				scaleSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scaleSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ScaleSparkEngine(scaleSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ScaleSparkEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ScaleSparkEngineOptions model
				scaleSparkEngineOptionsModel := new(watsonxdatav2.ScaleSparkEngineOptions)
				scaleSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				scaleSparkEngineOptionsModel.NumberOfNodes = core.Int64Ptr(int64(2))
				scaleSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scaleSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ScaleSparkEngine(scaleSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ScaleSparkEngineOptions model with no property values
				scaleSparkEngineOptionsModelNew := new(watsonxdatav2.ScaleSparkEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ScaleSparkEngine(scaleSparkEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(202)
				}))
			})
			It(`Invoke ScaleSparkEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ScaleSparkEngineOptions model
				scaleSparkEngineOptionsModel := new(watsonxdatav2.ScaleSparkEngineOptions)
				scaleSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				scaleSparkEngineOptionsModel.NumberOfNodes = core.Int64Ptr(int64(2))
				scaleSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scaleSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ScaleSparkEngine(scaleSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListSparkVersions(listSparkVersionsOptions *ListSparkVersionsOptions) - Operation response error`, func() {
		listSparkVersionsPath := "/spark_versions"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkVersionsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListSparkVersions with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkVersionsOptions model
				listSparkVersionsOptionsModel := new(watsonxdatav2.ListSparkVersionsOptions)
				listSparkVersionsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkVersionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListSparkVersions(listSparkVersionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListSparkVersions(listSparkVersionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListSparkVersions(listSparkVersionsOptions *ListSparkVersionsOptions)`, func() {
		listSparkVersionsPath := "/spark_versions"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkVersionsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}, "spark_versions": [{"display_name": "Instance Name"}]}`)
				}))
			})
			It(`Invoke ListSparkVersions successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListSparkVersionsOptions model
				listSparkVersionsOptionsModel := new(watsonxdatav2.ListSparkVersionsOptions)
				listSparkVersionsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkVersionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListSparkVersionsWithContext(ctx, listSparkVersionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListSparkVersions(listSparkVersionsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListSparkVersionsWithContext(ctx, listSparkVersionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkVersionsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}, "spark_versions": [{"display_name": "Instance Name"}]}`)
				}))
			})
			It(`Invoke ListSparkVersions successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListSparkVersions(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListSparkVersionsOptions model
				listSparkVersionsOptionsModel := new(watsonxdatav2.ListSparkVersionsOptions)
				listSparkVersionsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkVersionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListSparkVersions(listSparkVersionsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListSparkVersions with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkVersionsOptions model
				listSparkVersionsOptionsModel := new(watsonxdatav2.ListSparkVersionsOptions)
				listSparkVersionsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkVersionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListSparkVersions(listSparkVersionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListSparkVersions successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkVersionsOptions model
				listSparkVersionsOptionsModel := new(watsonxdatav2.ListSparkVersionsOptions)
				listSparkVersionsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkVersionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListSparkVersions(listSparkVersionsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListCatalogs(listCatalogsOptions *ListCatalogsOptions) - Operation response error`, func() {
		listCatalogsPath := "/catalogs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListCatalogs with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := new(watsonxdatav2.ListCatalogsOptions)
				listCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListCatalogs(listCatalogsOptions *ListCatalogsOptions)`, func() {
		listCatalogsPath := "/catalogs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke ListCatalogs successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := new(watsonxdatav2.ListCatalogsOptions)
				listCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListCatalogsWithContext(ctx, listCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListCatalogsWithContext(ctx, listCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke ListCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := new(watsonxdatav2.ListCatalogsOptions)
				listCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListCatalogs with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := new(watsonxdatav2.ListCatalogsOptions)
				listCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := new(watsonxdatav2.ListCatalogsOptions)
				listCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCatalog(getCatalogOptions *GetCatalogOptions) - Operation response error`, func() {
		getCatalogPath := "/catalogs/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetCatalog with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetCatalogOptions model
				getCatalogOptionsModel := new(watsonxdatav2.GetCatalogOptions)
				getCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCatalog(getCatalogOptions *GetCatalogOptions)`, func() {
		getCatalogPath := "/catalogs/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke GetCatalog successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetCatalogOptions model
				getCatalogOptionsModel := new(watsonxdatav2.GetCatalogOptions)
				getCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetCatalogWithContext(ctx, getCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetCatalogWithContext(ctx, getCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_names": "CatalogNames", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke GetCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetCatalog(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetCatalogOptions model
				getCatalogOptionsModel := new(watsonxdatav2.GetCatalogOptions)
				getCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetCatalog with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetCatalogOptions model
				getCatalogOptionsModel := new(watsonxdatav2.GetCatalogOptions)
				getCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetCatalogOptions model with no property values
				getCatalogOptionsModelNew := new(watsonxdatav2.GetCatalogOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetCatalog(getCatalogOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetCatalogOptions model
				getCatalogOptionsModel := new(watsonxdatav2.GetCatalogOptions)
				getCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListSchemas(listSchemasOptions *ListSchemasOptions) - Operation response error`, func() {
		listSchemasPath := "/catalogs/testString/schemas"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSchemasPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListSchemas with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSchemasOptions model
				listSchemasOptionsModel := new(watsonxdatav2.ListSchemasOptions)
				listSchemasOptionsModel.EngineID = core.StringPtr("testString")
				listSchemasOptionsModel.CatalogID = core.StringPtr("testString")
				listSchemasOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSchemasOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListSchemas(listSchemasOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListSchemas(listSchemasOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListSchemas(listSchemasOptions *ListSchemasOptions)`, func() {
		listSchemasPath := "/catalogs/testString/schemas"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSchemasPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}, "schemas": ["Schemas"]}`)
				}))
			})
			It(`Invoke ListSchemas successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListSchemasOptions model
				listSchemasOptionsModel := new(watsonxdatav2.ListSchemasOptions)
				listSchemasOptionsModel.EngineID = core.StringPtr("testString")
				listSchemasOptionsModel.CatalogID = core.StringPtr("testString")
				listSchemasOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSchemasOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListSchemasWithContext(ctx, listSchemasOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListSchemas(listSchemasOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListSchemasWithContext(ctx, listSchemasOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSchemasPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}, "schemas": ["Schemas"]}`)
				}))
			})
			It(`Invoke ListSchemas successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListSchemas(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListSchemasOptions model
				listSchemasOptionsModel := new(watsonxdatav2.ListSchemasOptions)
				listSchemasOptionsModel.EngineID = core.StringPtr("testString")
				listSchemasOptionsModel.CatalogID = core.StringPtr("testString")
				listSchemasOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSchemasOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListSchemas(listSchemasOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListSchemas with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSchemasOptions model
				listSchemasOptionsModel := new(watsonxdatav2.ListSchemasOptions)
				listSchemasOptionsModel.EngineID = core.StringPtr("testString")
				listSchemasOptionsModel.CatalogID = core.StringPtr("testString")
				listSchemasOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSchemasOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListSchemas(listSchemasOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListSchemasOptions model with no property values
				listSchemasOptionsModelNew := new(watsonxdatav2.ListSchemasOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListSchemas(listSchemasOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListSchemas successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSchemasOptions model
				listSchemasOptionsModel := new(watsonxdatav2.ListSchemasOptions)
				listSchemasOptionsModel.EngineID = core.StringPtr("testString")
				listSchemasOptionsModel.CatalogID = core.StringPtr("testString")
				listSchemasOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSchemasOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListSchemas(listSchemasOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSchema(createSchemaOptions *CreateSchemaOptions) - Operation response error`, func() {
		createSchemaPath := "/catalogs/testString/schemas"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSchemaPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateSchema with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSchemaOptions model
				createSchemaOptionsModel := new(watsonxdatav2.CreateSchemaOptions)
				createSchemaOptionsModel.EngineID = core.StringPtr("testString")
				createSchemaOptionsModel.CatalogID = core.StringPtr("testString")
				createSchemaOptionsModel.CustomPath = core.StringPtr("sample-path")
				createSchemaOptionsModel.SchemaName = core.StringPtr("SampleSchema1")
				createSchemaOptionsModel.BucketName = core.StringPtr("sample-bucket")
				createSchemaOptionsModel.Hostname = core.StringPtr("db2@hostname.com")
				createSchemaOptionsModel.Port = core.Int64Ptr(int64(4553))
				createSchemaOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSchemaOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateSchema(createSchemaOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateSchema(createSchemaOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSchema(createSchemaOptions *CreateSchemaOptions)`, func() {
		createSchemaPath := "/catalogs/testString/schemas"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSchemaPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke CreateSchema successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreateSchemaOptions model
				createSchemaOptionsModel := new(watsonxdatav2.CreateSchemaOptions)
				createSchemaOptionsModel.EngineID = core.StringPtr("testString")
				createSchemaOptionsModel.CatalogID = core.StringPtr("testString")
				createSchemaOptionsModel.CustomPath = core.StringPtr("sample-path")
				createSchemaOptionsModel.SchemaName = core.StringPtr("SampleSchema1")
				createSchemaOptionsModel.BucketName = core.StringPtr("sample-bucket")
				createSchemaOptionsModel.Hostname = core.StringPtr("db2@hostname.com")
				createSchemaOptionsModel.Port = core.Int64Ptr(int64(4553))
				createSchemaOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSchemaOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateSchemaWithContext(ctx, createSchemaOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateSchema(createSchemaOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateSchemaWithContext(ctx, createSchemaOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSchemaPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke CreateSchema successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateSchema(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreateSchemaOptions model
				createSchemaOptionsModel := new(watsonxdatav2.CreateSchemaOptions)
				createSchemaOptionsModel.EngineID = core.StringPtr("testString")
				createSchemaOptionsModel.CatalogID = core.StringPtr("testString")
				createSchemaOptionsModel.CustomPath = core.StringPtr("sample-path")
				createSchemaOptionsModel.SchemaName = core.StringPtr("SampleSchema1")
				createSchemaOptionsModel.BucketName = core.StringPtr("sample-bucket")
				createSchemaOptionsModel.Hostname = core.StringPtr("db2@hostname.com")
				createSchemaOptionsModel.Port = core.Int64Ptr(int64(4553))
				createSchemaOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSchemaOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateSchema(createSchemaOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateSchema with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSchemaOptions model
				createSchemaOptionsModel := new(watsonxdatav2.CreateSchemaOptions)
				createSchemaOptionsModel.EngineID = core.StringPtr("testString")
				createSchemaOptionsModel.CatalogID = core.StringPtr("testString")
				createSchemaOptionsModel.CustomPath = core.StringPtr("sample-path")
				createSchemaOptionsModel.SchemaName = core.StringPtr("SampleSchema1")
				createSchemaOptionsModel.BucketName = core.StringPtr("sample-bucket")
				createSchemaOptionsModel.Hostname = core.StringPtr("db2@hostname.com")
				createSchemaOptionsModel.Port = core.Int64Ptr(int64(4553))
				createSchemaOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSchemaOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateSchema(createSchemaOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateSchemaOptions model with no property values
				createSchemaOptionsModelNew := new(watsonxdatav2.CreateSchemaOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateSchema(createSchemaOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateSchema successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSchemaOptions model
				createSchemaOptionsModel := new(watsonxdatav2.CreateSchemaOptions)
				createSchemaOptionsModel.EngineID = core.StringPtr("testString")
				createSchemaOptionsModel.CatalogID = core.StringPtr("testString")
				createSchemaOptionsModel.CustomPath = core.StringPtr("sample-path")
				createSchemaOptionsModel.SchemaName = core.StringPtr("SampleSchema1")
				createSchemaOptionsModel.BucketName = core.StringPtr("sample-bucket")
				createSchemaOptionsModel.Hostname = core.StringPtr("db2@hostname.com")
				createSchemaOptionsModel.Port = core.Int64Ptr(int64(4553))
				createSchemaOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSchemaOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateSchema(createSchemaOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteSchema(deleteSchemaOptions *DeleteSchemaOptions)`, func() {
		deleteSchemaPath := "/catalogs/testString/schemas/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteSchemaPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteSchema successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteSchema(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteSchemaOptions model
				deleteSchemaOptionsModel := new(watsonxdatav2.DeleteSchemaOptions)
				deleteSchemaOptionsModel.EngineID = core.StringPtr("testString")
				deleteSchemaOptionsModel.CatalogID = core.StringPtr("testString")
				deleteSchemaOptionsModel.SchemaID = core.StringPtr("testString")
				deleteSchemaOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteSchemaOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteSchema(deleteSchemaOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteSchema with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteSchemaOptions model
				deleteSchemaOptionsModel := new(watsonxdatav2.DeleteSchemaOptions)
				deleteSchemaOptionsModel.EngineID = core.StringPtr("testString")
				deleteSchemaOptionsModel.CatalogID = core.StringPtr("testString")
				deleteSchemaOptionsModel.SchemaID = core.StringPtr("testString")
				deleteSchemaOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteSchemaOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteSchema(deleteSchemaOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteSchemaOptions model with no property values
				deleteSchemaOptionsModelNew := new(watsonxdatav2.DeleteSchemaOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteSchema(deleteSchemaOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListTables(listTablesOptions *ListTablesOptions) - Operation response error`, func() {
		listTablesPath := "/catalogs/testString/schemas/testString/tables"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listTablesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListTables with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListTablesOptions model
				listTablesOptionsModel := new(watsonxdatav2.ListTablesOptions)
				listTablesOptionsModel.CatalogID = core.StringPtr("testString")
				listTablesOptionsModel.SchemaID = core.StringPtr("testString")
				listTablesOptionsModel.EngineID = core.StringPtr("testString")
				listTablesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listTablesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListTables(listTablesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListTables(listTablesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListTables(listTablesOptions *ListTablesOptions)`, func() {
		listTablesPath := "/catalogs/testString/schemas/testString/tables"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listTablesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"tables": ["Tables"]}`)
				}))
			})
			It(`Invoke ListTables successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListTablesOptions model
				listTablesOptionsModel := new(watsonxdatav2.ListTablesOptions)
				listTablesOptionsModel.CatalogID = core.StringPtr("testString")
				listTablesOptionsModel.SchemaID = core.StringPtr("testString")
				listTablesOptionsModel.EngineID = core.StringPtr("testString")
				listTablesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listTablesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListTablesWithContext(ctx, listTablesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListTables(listTablesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListTablesWithContext(ctx, listTablesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listTablesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"tables": ["Tables"]}`)
				}))
			})
			It(`Invoke ListTables successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListTables(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListTablesOptions model
				listTablesOptionsModel := new(watsonxdatav2.ListTablesOptions)
				listTablesOptionsModel.CatalogID = core.StringPtr("testString")
				listTablesOptionsModel.SchemaID = core.StringPtr("testString")
				listTablesOptionsModel.EngineID = core.StringPtr("testString")
				listTablesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listTablesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListTables(listTablesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListTables with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListTablesOptions model
				listTablesOptionsModel := new(watsonxdatav2.ListTablesOptions)
				listTablesOptionsModel.CatalogID = core.StringPtr("testString")
				listTablesOptionsModel.SchemaID = core.StringPtr("testString")
				listTablesOptionsModel.EngineID = core.StringPtr("testString")
				listTablesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listTablesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListTables(listTablesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListTablesOptions model with no property values
				listTablesOptionsModelNew := new(watsonxdatav2.ListTablesOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListTables(listTablesOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListTables successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListTablesOptions model
				listTablesOptionsModel := new(watsonxdatav2.ListTablesOptions)
				listTablesOptionsModel.CatalogID = core.StringPtr("testString")
				listTablesOptionsModel.SchemaID = core.StringPtr("testString")
				listTablesOptionsModel.EngineID = core.StringPtr("testString")
				listTablesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listTablesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListTables(listTablesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetTable(getTableOptions *GetTableOptions) - Operation response error`, func() {
		getTablePath := "/catalogs/testString/schemas/testString/tables/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getTablePath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["type"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetTable with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetTableOptions model
				getTableOptionsModel := new(watsonxdatav2.GetTableOptions)
				getTableOptionsModel.CatalogID = core.StringPtr("testString")
				getTableOptionsModel.SchemaID = core.StringPtr("testString")
				getTableOptionsModel.TableID = core.StringPtr("testString")
				getTableOptionsModel.EngineID = core.StringPtr("testString")
				getTableOptionsModel.Type = core.StringPtr("testString")
				getTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetTable(getTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetTable(getTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetTable(getTableOptions *GetTableOptions)`, func() {
		getTablePath := "/catalogs/testString/schemas/testString/tables/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getTablePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["type"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"columns": [{"column_name": "expenses", "comment": "expenses column", "extra": "varchar", "length": "30", "scale": "2", "precision": "10", "type": "varchar"}], "table_name": "TableName"}`)
				}))
			})
			It(`Invoke GetTable successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetTableOptions model
				getTableOptionsModel := new(watsonxdatav2.GetTableOptions)
				getTableOptionsModel.CatalogID = core.StringPtr("testString")
				getTableOptionsModel.SchemaID = core.StringPtr("testString")
				getTableOptionsModel.TableID = core.StringPtr("testString")
				getTableOptionsModel.EngineID = core.StringPtr("testString")
				getTableOptionsModel.Type = core.StringPtr("testString")
				getTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetTableWithContext(ctx, getTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetTable(getTableOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetTableWithContext(ctx, getTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getTablePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["type"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"columns": [{"column_name": "expenses", "comment": "expenses column", "extra": "varchar", "length": "30", "scale": "2", "precision": "10", "type": "varchar"}], "table_name": "TableName"}`)
				}))
			})
			It(`Invoke GetTable successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetTable(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetTableOptions model
				getTableOptionsModel := new(watsonxdatav2.GetTableOptions)
				getTableOptionsModel.CatalogID = core.StringPtr("testString")
				getTableOptionsModel.SchemaID = core.StringPtr("testString")
				getTableOptionsModel.TableID = core.StringPtr("testString")
				getTableOptionsModel.EngineID = core.StringPtr("testString")
				getTableOptionsModel.Type = core.StringPtr("testString")
				getTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetTable(getTableOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetTable with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetTableOptions model
				getTableOptionsModel := new(watsonxdatav2.GetTableOptions)
				getTableOptionsModel.CatalogID = core.StringPtr("testString")
				getTableOptionsModel.SchemaID = core.StringPtr("testString")
				getTableOptionsModel.TableID = core.StringPtr("testString")
				getTableOptionsModel.EngineID = core.StringPtr("testString")
				getTableOptionsModel.Type = core.StringPtr("testString")
				getTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetTable(getTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetTableOptions model with no property values
				getTableOptionsModelNew := new(watsonxdatav2.GetTableOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetTable(getTableOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetTable successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetTableOptions model
				getTableOptionsModel := new(watsonxdatav2.GetTableOptions)
				getTableOptionsModel.CatalogID = core.StringPtr("testString")
				getTableOptionsModel.SchemaID = core.StringPtr("testString")
				getTableOptionsModel.TableID = core.StringPtr("testString")
				getTableOptionsModel.EngineID = core.StringPtr("testString")
				getTableOptionsModel.Type = core.StringPtr("testString")
				getTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetTable(getTableOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteTable(deleteTableOptions *DeleteTableOptions)`, func() {
		deleteTablePath := "/catalogs/testString/schemas/testString/tables/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteTablePath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["type"]).To(Equal([]string{"testString"}))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteTable successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteTable(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteTableOptions model
				deleteTableOptionsModel := new(watsonxdatav2.DeleteTableOptions)
				deleteTableOptionsModel.CatalogID = core.StringPtr("testString")
				deleteTableOptionsModel.SchemaID = core.StringPtr("testString")
				deleteTableOptionsModel.TableID = core.StringPtr("testString")
				deleteTableOptionsModel.EngineID = core.StringPtr("testString")
				deleteTableOptionsModel.Type = core.StringPtr("testString")
				deleteTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteTable(deleteTableOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteTable with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteTableOptions model
				deleteTableOptionsModel := new(watsonxdatav2.DeleteTableOptions)
				deleteTableOptionsModel.CatalogID = core.StringPtr("testString")
				deleteTableOptionsModel.SchemaID = core.StringPtr("testString")
				deleteTableOptionsModel.TableID = core.StringPtr("testString")
				deleteTableOptionsModel.EngineID = core.StringPtr("testString")
				deleteTableOptionsModel.Type = core.StringPtr("testString")
				deleteTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteTable(deleteTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteTableOptions model with no property values
				deleteTableOptionsModelNew := new(watsonxdatav2.DeleteTableOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteTable(deleteTableOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateTable(updateTableOptions *UpdateTableOptions) - Operation response error`, func() {
		updateTablePath := "/catalogs/testString/schemas/testString/tables/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateTablePath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["type"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateTable with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the TablePatch model
				tablePatchModel := new(watsonxdatav2.TablePatch)
				tablePatchModel.TableName = core.StringPtr("updated_table_name")
				tablePatchModelAsPatch, asPatchErr := tablePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateTableOptions model
				updateTableOptionsModel := new(watsonxdatav2.UpdateTableOptions)
				updateTableOptionsModel.CatalogID = core.StringPtr("testString")
				updateTableOptionsModel.SchemaID = core.StringPtr("testString")
				updateTableOptionsModel.TableID = core.StringPtr("testString")
				updateTableOptionsModel.EngineID = core.StringPtr("testString")
				updateTableOptionsModel.Body = tablePatchModelAsPatch
				updateTableOptionsModel.Type = core.StringPtr("testString")
				updateTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdateTable(updateTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdateTable(updateTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateTable(updateTableOptions *UpdateTableOptions)`, func() {
		updateTablePath := "/catalogs/testString/schemas/testString/tables/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateTablePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["type"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"columns": [{"column_name": "expenses", "comment": "expenses column", "extra": "varchar", "length": "30", "scale": "2", "precision": "10", "type": "varchar"}], "table_name": "TableName"}`)
				}))
			})
			It(`Invoke UpdateTable successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the TablePatch model
				tablePatchModel := new(watsonxdatav2.TablePatch)
				tablePatchModel.TableName = core.StringPtr("updated_table_name")
				tablePatchModelAsPatch, asPatchErr := tablePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateTableOptions model
				updateTableOptionsModel := new(watsonxdatav2.UpdateTableOptions)
				updateTableOptionsModel.CatalogID = core.StringPtr("testString")
				updateTableOptionsModel.SchemaID = core.StringPtr("testString")
				updateTableOptionsModel.TableID = core.StringPtr("testString")
				updateTableOptionsModel.EngineID = core.StringPtr("testString")
				updateTableOptionsModel.Body = tablePatchModelAsPatch
				updateTableOptionsModel.Type = core.StringPtr("testString")
				updateTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdateTableWithContext(ctx, updateTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdateTable(updateTableOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdateTableWithContext(ctx, updateTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateTablePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["type"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"columns": [{"column_name": "expenses", "comment": "expenses column", "extra": "varchar", "length": "30", "scale": "2", "precision": "10", "type": "varchar"}], "table_name": "TableName"}`)
				}))
			})
			It(`Invoke UpdateTable successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdateTable(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the TablePatch model
				tablePatchModel := new(watsonxdatav2.TablePatch)
				tablePatchModel.TableName = core.StringPtr("updated_table_name")
				tablePatchModelAsPatch, asPatchErr := tablePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateTableOptions model
				updateTableOptionsModel := new(watsonxdatav2.UpdateTableOptions)
				updateTableOptionsModel.CatalogID = core.StringPtr("testString")
				updateTableOptionsModel.SchemaID = core.StringPtr("testString")
				updateTableOptionsModel.TableID = core.StringPtr("testString")
				updateTableOptionsModel.EngineID = core.StringPtr("testString")
				updateTableOptionsModel.Body = tablePatchModelAsPatch
				updateTableOptionsModel.Type = core.StringPtr("testString")
				updateTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdateTable(updateTableOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateTable with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the TablePatch model
				tablePatchModel := new(watsonxdatav2.TablePatch)
				tablePatchModel.TableName = core.StringPtr("updated_table_name")
				tablePatchModelAsPatch, asPatchErr := tablePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateTableOptions model
				updateTableOptionsModel := new(watsonxdatav2.UpdateTableOptions)
				updateTableOptionsModel.CatalogID = core.StringPtr("testString")
				updateTableOptionsModel.SchemaID = core.StringPtr("testString")
				updateTableOptionsModel.TableID = core.StringPtr("testString")
				updateTableOptionsModel.EngineID = core.StringPtr("testString")
				updateTableOptionsModel.Body = tablePatchModelAsPatch
				updateTableOptionsModel.Type = core.StringPtr("testString")
				updateTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdateTable(updateTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateTableOptions model with no property values
				updateTableOptionsModelNew := new(watsonxdatav2.UpdateTableOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdateTable(updateTableOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateTable successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the TablePatch model
				tablePatchModel := new(watsonxdatav2.TablePatch)
				tablePatchModel.TableName = core.StringPtr("updated_table_name")
				tablePatchModelAsPatch, asPatchErr := tablePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateTableOptions model
				updateTableOptionsModel := new(watsonxdatav2.UpdateTableOptions)
				updateTableOptionsModel.CatalogID = core.StringPtr("testString")
				updateTableOptionsModel.SchemaID = core.StringPtr("testString")
				updateTableOptionsModel.TableID = core.StringPtr("testString")
				updateTableOptionsModel.EngineID = core.StringPtr("testString")
				updateTableOptionsModel.Body = tablePatchModelAsPatch
				updateTableOptionsModel.Type = core.StringPtr("testString")
				updateTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdateTable(updateTableOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListColumns(listColumnsOptions *ListColumnsOptions) - Operation response error`, func() {
		listColumnsPath := "/catalogs/testString/schemas/testString/tables/testString/columns"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listColumnsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListColumns with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListColumnsOptions model
				listColumnsOptionsModel := new(watsonxdatav2.ListColumnsOptions)
				listColumnsOptionsModel.EngineID = core.StringPtr("testString")
				listColumnsOptionsModel.CatalogID = core.StringPtr("testString")
				listColumnsOptionsModel.SchemaID = core.StringPtr("testString")
				listColumnsOptionsModel.TableID = core.StringPtr("testString")
				listColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListColumns(listColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListColumns(listColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListColumns(listColumnsOptions *ListColumnsOptions)`, func() {
		listColumnsPath := "/catalogs/testString/schemas/testString/tables/testString/columns"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listColumnsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"columns": [{"column_name": "expenses", "comment": "expenses column", "extra": "varchar", "length": "30", "scale": "2", "precision": "10", "type": "varchar"}]}`)
				}))
			})
			It(`Invoke ListColumns successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListColumnsOptions model
				listColumnsOptionsModel := new(watsonxdatav2.ListColumnsOptions)
				listColumnsOptionsModel.EngineID = core.StringPtr("testString")
				listColumnsOptionsModel.CatalogID = core.StringPtr("testString")
				listColumnsOptionsModel.SchemaID = core.StringPtr("testString")
				listColumnsOptionsModel.TableID = core.StringPtr("testString")
				listColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListColumnsWithContext(ctx, listColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListColumns(listColumnsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListColumnsWithContext(ctx, listColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listColumnsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"columns": [{"column_name": "expenses", "comment": "expenses column", "extra": "varchar", "length": "30", "scale": "2", "precision": "10", "type": "varchar"}]}`)
				}))
			})
			It(`Invoke ListColumns successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListColumns(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListColumnsOptions model
				listColumnsOptionsModel := new(watsonxdatav2.ListColumnsOptions)
				listColumnsOptionsModel.EngineID = core.StringPtr("testString")
				listColumnsOptionsModel.CatalogID = core.StringPtr("testString")
				listColumnsOptionsModel.SchemaID = core.StringPtr("testString")
				listColumnsOptionsModel.TableID = core.StringPtr("testString")
				listColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListColumns(listColumnsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListColumns with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListColumnsOptions model
				listColumnsOptionsModel := new(watsonxdatav2.ListColumnsOptions)
				listColumnsOptionsModel.EngineID = core.StringPtr("testString")
				listColumnsOptionsModel.CatalogID = core.StringPtr("testString")
				listColumnsOptionsModel.SchemaID = core.StringPtr("testString")
				listColumnsOptionsModel.TableID = core.StringPtr("testString")
				listColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListColumns(listColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListColumnsOptions model with no property values
				listColumnsOptionsModelNew := new(watsonxdatav2.ListColumnsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListColumns(listColumnsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListColumns successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListColumnsOptions model
				listColumnsOptionsModel := new(watsonxdatav2.ListColumnsOptions)
				listColumnsOptionsModel.EngineID = core.StringPtr("testString")
				listColumnsOptionsModel.CatalogID = core.StringPtr("testString")
				listColumnsOptionsModel.SchemaID = core.StringPtr("testString")
				listColumnsOptionsModel.TableID = core.StringPtr("testString")
				listColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListColumns(listColumnsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateColumns(createColumnsOptions *CreateColumnsOptions) - Operation response error`, func() {
		createColumnsPath := "/catalogs/testString/schemas/testString/tables/testString/columns"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createColumnsPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateColumns with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the Column model
				columnModel := new(watsonxdatav2.Column)
				columnModel.ColumnName = core.StringPtr("expenses")
				columnModel.Comment = core.StringPtr("expenses column")
				columnModel.Extra = core.StringPtr("varchar")
				columnModel.Length = core.StringPtr("30")
				columnModel.Scale = core.StringPtr("2")
				columnModel.Precision = core.StringPtr("10")
				columnModel.Type = core.StringPtr("varchar")

				// Construct an instance of the CreateColumnsOptions model
				createColumnsOptionsModel := new(watsonxdatav2.CreateColumnsOptions)
				createColumnsOptionsModel.EngineID = core.StringPtr("testString")
				createColumnsOptionsModel.CatalogID = core.StringPtr("testString")
				createColumnsOptionsModel.SchemaID = core.StringPtr("testString")
				createColumnsOptionsModel.TableID = core.StringPtr("testString")
				createColumnsOptionsModel.Columns = []watsonxdatav2.Column{*columnModel}
				createColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateColumns(createColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateColumns(createColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateColumns(createColumnsOptions *CreateColumnsOptions)`, func() {
		createColumnsPath := "/catalogs/testString/schemas/testString/tables/testString/columns"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createColumnsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"columns": [{"column_name": "expenses", "comment": "expenses column", "extra": "varchar", "length": "30", "scale": "2", "precision": "10", "type": "varchar"}]}`)
				}))
			})
			It(`Invoke CreateColumns successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the Column model
				columnModel := new(watsonxdatav2.Column)
				columnModel.ColumnName = core.StringPtr("expenses")
				columnModel.Comment = core.StringPtr("expenses column")
				columnModel.Extra = core.StringPtr("varchar")
				columnModel.Length = core.StringPtr("30")
				columnModel.Scale = core.StringPtr("2")
				columnModel.Precision = core.StringPtr("10")
				columnModel.Type = core.StringPtr("varchar")

				// Construct an instance of the CreateColumnsOptions model
				createColumnsOptionsModel := new(watsonxdatav2.CreateColumnsOptions)
				createColumnsOptionsModel.EngineID = core.StringPtr("testString")
				createColumnsOptionsModel.CatalogID = core.StringPtr("testString")
				createColumnsOptionsModel.SchemaID = core.StringPtr("testString")
				createColumnsOptionsModel.TableID = core.StringPtr("testString")
				createColumnsOptionsModel.Columns = []watsonxdatav2.Column{*columnModel}
				createColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateColumnsWithContext(ctx, createColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateColumns(createColumnsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateColumnsWithContext(ctx, createColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createColumnsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"columns": [{"column_name": "expenses", "comment": "expenses column", "extra": "varchar", "length": "30", "scale": "2", "precision": "10", "type": "varchar"}]}`)
				}))
			})
			It(`Invoke CreateColumns successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateColumns(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Column model
				columnModel := new(watsonxdatav2.Column)
				columnModel.ColumnName = core.StringPtr("expenses")
				columnModel.Comment = core.StringPtr("expenses column")
				columnModel.Extra = core.StringPtr("varchar")
				columnModel.Length = core.StringPtr("30")
				columnModel.Scale = core.StringPtr("2")
				columnModel.Precision = core.StringPtr("10")
				columnModel.Type = core.StringPtr("varchar")

				// Construct an instance of the CreateColumnsOptions model
				createColumnsOptionsModel := new(watsonxdatav2.CreateColumnsOptions)
				createColumnsOptionsModel.EngineID = core.StringPtr("testString")
				createColumnsOptionsModel.CatalogID = core.StringPtr("testString")
				createColumnsOptionsModel.SchemaID = core.StringPtr("testString")
				createColumnsOptionsModel.TableID = core.StringPtr("testString")
				createColumnsOptionsModel.Columns = []watsonxdatav2.Column{*columnModel}
				createColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateColumns(createColumnsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateColumns with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the Column model
				columnModel := new(watsonxdatav2.Column)
				columnModel.ColumnName = core.StringPtr("expenses")
				columnModel.Comment = core.StringPtr("expenses column")
				columnModel.Extra = core.StringPtr("varchar")
				columnModel.Length = core.StringPtr("30")
				columnModel.Scale = core.StringPtr("2")
				columnModel.Precision = core.StringPtr("10")
				columnModel.Type = core.StringPtr("varchar")

				// Construct an instance of the CreateColumnsOptions model
				createColumnsOptionsModel := new(watsonxdatav2.CreateColumnsOptions)
				createColumnsOptionsModel.EngineID = core.StringPtr("testString")
				createColumnsOptionsModel.CatalogID = core.StringPtr("testString")
				createColumnsOptionsModel.SchemaID = core.StringPtr("testString")
				createColumnsOptionsModel.TableID = core.StringPtr("testString")
				createColumnsOptionsModel.Columns = []watsonxdatav2.Column{*columnModel}
				createColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateColumns(createColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateColumnsOptions model with no property values
				createColumnsOptionsModelNew := new(watsonxdatav2.CreateColumnsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateColumns(createColumnsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateColumns successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the Column model
				columnModel := new(watsonxdatav2.Column)
				columnModel.ColumnName = core.StringPtr("expenses")
				columnModel.Comment = core.StringPtr("expenses column")
				columnModel.Extra = core.StringPtr("varchar")
				columnModel.Length = core.StringPtr("30")
				columnModel.Scale = core.StringPtr("2")
				columnModel.Precision = core.StringPtr("10")
				columnModel.Type = core.StringPtr("varchar")

				// Construct an instance of the CreateColumnsOptions model
				createColumnsOptionsModel := new(watsonxdatav2.CreateColumnsOptions)
				createColumnsOptionsModel.EngineID = core.StringPtr("testString")
				createColumnsOptionsModel.CatalogID = core.StringPtr("testString")
				createColumnsOptionsModel.SchemaID = core.StringPtr("testString")
				createColumnsOptionsModel.TableID = core.StringPtr("testString")
				createColumnsOptionsModel.Columns = []watsonxdatav2.Column{*columnModel}
				createColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateColumns(createColumnsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteColumn(deleteColumnOptions *DeleteColumnOptions)`, func() {
		deleteColumnPath := "/catalogs/testString/schemas/testString/tables/testString/columns/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteColumnPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteColumn successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteColumn(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteColumnOptions model
				deleteColumnOptionsModel := new(watsonxdatav2.DeleteColumnOptions)
				deleteColumnOptionsModel.EngineID = core.StringPtr("testString")
				deleteColumnOptionsModel.CatalogID = core.StringPtr("testString")
				deleteColumnOptionsModel.SchemaID = core.StringPtr("testString")
				deleteColumnOptionsModel.TableID = core.StringPtr("testString")
				deleteColumnOptionsModel.ColumnID = core.StringPtr("testString")
				deleteColumnOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteColumnOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteColumn(deleteColumnOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteColumn with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteColumnOptions model
				deleteColumnOptionsModel := new(watsonxdatav2.DeleteColumnOptions)
				deleteColumnOptionsModel.EngineID = core.StringPtr("testString")
				deleteColumnOptionsModel.CatalogID = core.StringPtr("testString")
				deleteColumnOptionsModel.SchemaID = core.StringPtr("testString")
				deleteColumnOptionsModel.TableID = core.StringPtr("testString")
				deleteColumnOptionsModel.ColumnID = core.StringPtr("testString")
				deleteColumnOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteColumnOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteColumn(deleteColumnOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteColumnOptions model with no property values
				deleteColumnOptionsModelNew := new(watsonxdatav2.DeleteColumnOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteColumn(deleteColumnOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateColumn(updateColumnOptions *UpdateColumnOptions) - Operation response error`, func() {
		updateColumnPath := "/catalogs/testString/schemas/testString/tables/testString/columns/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateColumnPath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateColumn with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ColumnPatch model
				columnPatchModel := new(watsonxdatav2.ColumnPatch)
				columnPatchModel.ColumnName = core.StringPtr("expenses")
				columnPatchModelAsPatch, asPatchErr := columnPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateColumnOptions model
				updateColumnOptionsModel := new(watsonxdatav2.UpdateColumnOptions)
				updateColumnOptionsModel.EngineID = core.StringPtr("testString")
				updateColumnOptionsModel.CatalogID = core.StringPtr("testString")
				updateColumnOptionsModel.SchemaID = core.StringPtr("testString")
				updateColumnOptionsModel.TableID = core.StringPtr("testString")
				updateColumnOptionsModel.ColumnID = core.StringPtr("testString")
				updateColumnOptionsModel.Body = columnPatchModelAsPatch
				updateColumnOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateColumnOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdateColumn(updateColumnOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdateColumn(updateColumnOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateColumn(updateColumnOptions *UpdateColumnOptions)`, func() {
		updateColumnPath := "/catalogs/testString/schemas/testString/tables/testString/columns/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateColumnPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"column_name": "expenses", "comment": "expenses column", "extra": "varchar", "length": "30", "scale": "2", "precision": "10", "type": "varchar"}`)
				}))
			})
			It(`Invoke UpdateColumn successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ColumnPatch model
				columnPatchModel := new(watsonxdatav2.ColumnPatch)
				columnPatchModel.ColumnName = core.StringPtr("expenses")
				columnPatchModelAsPatch, asPatchErr := columnPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateColumnOptions model
				updateColumnOptionsModel := new(watsonxdatav2.UpdateColumnOptions)
				updateColumnOptionsModel.EngineID = core.StringPtr("testString")
				updateColumnOptionsModel.CatalogID = core.StringPtr("testString")
				updateColumnOptionsModel.SchemaID = core.StringPtr("testString")
				updateColumnOptionsModel.TableID = core.StringPtr("testString")
				updateColumnOptionsModel.ColumnID = core.StringPtr("testString")
				updateColumnOptionsModel.Body = columnPatchModelAsPatch
				updateColumnOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateColumnOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdateColumnWithContext(ctx, updateColumnOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdateColumn(updateColumnOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdateColumnWithContext(ctx, updateColumnOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateColumnPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"column_name": "expenses", "comment": "expenses column", "extra": "varchar", "length": "30", "scale": "2", "precision": "10", "type": "varchar"}`)
				}))
			})
			It(`Invoke UpdateColumn successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdateColumn(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ColumnPatch model
				columnPatchModel := new(watsonxdatav2.ColumnPatch)
				columnPatchModel.ColumnName = core.StringPtr("expenses")
				columnPatchModelAsPatch, asPatchErr := columnPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateColumnOptions model
				updateColumnOptionsModel := new(watsonxdatav2.UpdateColumnOptions)
				updateColumnOptionsModel.EngineID = core.StringPtr("testString")
				updateColumnOptionsModel.CatalogID = core.StringPtr("testString")
				updateColumnOptionsModel.SchemaID = core.StringPtr("testString")
				updateColumnOptionsModel.TableID = core.StringPtr("testString")
				updateColumnOptionsModel.ColumnID = core.StringPtr("testString")
				updateColumnOptionsModel.Body = columnPatchModelAsPatch
				updateColumnOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateColumnOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdateColumn(updateColumnOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateColumn with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ColumnPatch model
				columnPatchModel := new(watsonxdatav2.ColumnPatch)
				columnPatchModel.ColumnName = core.StringPtr("expenses")
				columnPatchModelAsPatch, asPatchErr := columnPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateColumnOptions model
				updateColumnOptionsModel := new(watsonxdatav2.UpdateColumnOptions)
				updateColumnOptionsModel.EngineID = core.StringPtr("testString")
				updateColumnOptionsModel.CatalogID = core.StringPtr("testString")
				updateColumnOptionsModel.SchemaID = core.StringPtr("testString")
				updateColumnOptionsModel.TableID = core.StringPtr("testString")
				updateColumnOptionsModel.ColumnID = core.StringPtr("testString")
				updateColumnOptionsModel.Body = columnPatchModelAsPatch
				updateColumnOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateColumnOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdateColumn(updateColumnOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateColumnOptions model with no property values
				updateColumnOptionsModelNew := new(watsonxdatav2.UpdateColumnOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdateColumn(updateColumnOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateColumn successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ColumnPatch model
				columnPatchModel := new(watsonxdatav2.ColumnPatch)
				columnPatchModel.ColumnName = core.StringPtr("expenses")
				columnPatchModelAsPatch, asPatchErr := columnPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateColumnOptions model
				updateColumnOptionsModel := new(watsonxdatav2.UpdateColumnOptions)
				updateColumnOptionsModel.EngineID = core.StringPtr("testString")
				updateColumnOptionsModel.CatalogID = core.StringPtr("testString")
				updateColumnOptionsModel.SchemaID = core.StringPtr("testString")
				updateColumnOptionsModel.TableID = core.StringPtr("testString")
				updateColumnOptionsModel.ColumnID = core.StringPtr("testString")
				updateColumnOptionsModel.Body = columnPatchModelAsPatch
				updateColumnOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateColumnOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdateColumn(updateColumnOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListTableSnapshots(listTableSnapshotsOptions *ListTableSnapshotsOptions) - Operation response error`, func() {
		listTableSnapshotsPath := "/catalogs/testString/schemas/testString/tables/testString/snapshots"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listTableSnapshotsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListTableSnapshots with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListTableSnapshotsOptions model
				listTableSnapshotsOptionsModel := new(watsonxdatav2.ListTableSnapshotsOptions)
				listTableSnapshotsOptionsModel.EngineID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.CatalogID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.SchemaID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.TableID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListTableSnapshots(listTableSnapshotsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListTableSnapshots(listTableSnapshotsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListTableSnapshots(listTableSnapshotsOptions *ListTableSnapshotsOptions)`, func() {
		listTableSnapshotsPath := "/catalogs/testString/schemas/testString/tables/testString/snapshots"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listTableSnapshotsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"snapshots": [{"added_data_files": "1", "added_files_size": "17425", "added_records": "3277", "changed_partition_count": "1", "committed_at": "1609379392", "operation": "alter", "snapshot_id": "2332342122211222", "total_data_files": "2", "total_delete_files": "0", "total_equality_deletes": "0", "total_position_deletes": "0", "total_records": "5000"}]}`)
				}))
			})
			It(`Invoke ListTableSnapshots successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListTableSnapshotsOptions model
				listTableSnapshotsOptionsModel := new(watsonxdatav2.ListTableSnapshotsOptions)
				listTableSnapshotsOptionsModel.EngineID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.CatalogID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.SchemaID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.TableID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListTableSnapshotsWithContext(ctx, listTableSnapshotsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListTableSnapshots(listTableSnapshotsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListTableSnapshotsWithContext(ctx, listTableSnapshotsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listTableSnapshotsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"snapshots": [{"added_data_files": "1", "added_files_size": "17425", "added_records": "3277", "changed_partition_count": "1", "committed_at": "1609379392", "operation": "alter", "snapshot_id": "2332342122211222", "total_data_files": "2", "total_delete_files": "0", "total_equality_deletes": "0", "total_position_deletes": "0", "total_records": "5000"}]}`)
				}))
			})
			It(`Invoke ListTableSnapshots successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListTableSnapshots(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListTableSnapshotsOptions model
				listTableSnapshotsOptionsModel := new(watsonxdatav2.ListTableSnapshotsOptions)
				listTableSnapshotsOptionsModel.EngineID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.CatalogID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.SchemaID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.TableID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListTableSnapshots(listTableSnapshotsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListTableSnapshots with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListTableSnapshotsOptions model
				listTableSnapshotsOptionsModel := new(watsonxdatav2.ListTableSnapshotsOptions)
				listTableSnapshotsOptionsModel.EngineID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.CatalogID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.SchemaID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.TableID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListTableSnapshots(listTableSnapshotsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListTableSnapshotsOptions model with no property values
				listTableSnapshotsOptionsModelNew := new(watsonxdatav2.ListTableSnapshotsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListTableSnapshots(listTableSnapshotsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListTableSnapshots successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListTableSnapshotsOptions model
				listTableSnapshotsOptionsModel := new(watsonxdatav2.ListTableSnapshotsOptions)
				listTableSnapshotsOptionsModel.EngineID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.CatalogID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.SchemaID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.TableID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListTableSnapshots(listTableSnapshotsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RollbackTable(rollbackTableOptions *RollbackTableOptions) - Operation response error`, func() {
		rollbackTablePath := "/catalogs/testString/schemas/testString/tables/testString/rollback"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(rollbackTablePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke RollbackTable with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RollbackTableOptions model
				rollbackTableOptionsModel := new(watsonxdatav2.RollbackTableOptions)
				rollbackTableOptionsModel.EngineID = core.StringPtr("testString")
				rollbackTableOptionsModel.CatalogID = core.StringPtr("testString")
				rollbackTableOptionsModel.SchemaID = core.StringPtr("testString")
				rollbackTableOptionsModel.TableID = core.StringPtr("testString")
				rollbackTableOptionsModel.SnapshotID = core.StringPtr("testString")
				rollbackTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				rollbackTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.RollbackTable(rollbackTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.RollbackTable(rollbackTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RollbackTable(rollbackTableOptions *RollbackTableOptions)`, func() {
		rollbackTablePath := "/catalogs/testString/schemas/testString/tables/testString/rollback"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(rollbackTablePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke RollbackTable successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the RollbackTableOptions model
				rollbackTableOptionsModel := new(watsonxdatav2.RollbackTableOptions)
				rollbackTableOptionsModel.EngineID = core.StringPtr("testString")
				rollbackTableOptionsModel.CatalogID = core.StringPtr("testString")
				rollbackTableOptionsModel.SchemaID = core.StringPtr("testString")
				rollbackTableOptionsModel.TableID = core.StringPtr("testString")
				rollbackTableOptionsModel.SnapshotID = core.StringPtr("testString")
				rollbackTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				rollbackTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.RollbackTableWithContext(ctx, rollbackTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.RollbackTable(rollbackTableOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.RollbackTableWithContext(ctx, rollbackTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(rollbackTablePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke RollbackTable successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.RollbackTable(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the RollbackTableOptions model
				rollbackTableOptionsModel := new(watsonxdatav2.RollbackTableOptions)
				rollbackTableOptionsModel.EngineID = core.StringPtr("testString")
				rollbackTableOptionsModel.CatalogID = core.StringPtr("testString")
				rollbackTableOptionsModel.SchemaID = core.StringPtr("testString")
				rollbackTableOptionsModel.TableID = core.StringPtr("testString")
				rollbackTableOptionsModel.SnapshotID = core.StringPtr("testString")
				rollbackTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				rollbackTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.RollbackTable(rollbackTableOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke RollbackTable with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RollbackTableOptions model
				rollbackTableOptionsModel := new(watsonxdatav2.RollbackTableOptions)
				rollbackTableOptionsModel.EngineID = core.StringPtr("testString")
				rollbackTableOptionsModel.CatalogID = core.StringPtr("testString")
				rollbackTableOptionsModel.SchemaID = core.StringPtr("testString")
				rollbackTableOptionsModel.TableID = core.StringPtr("testString")
				rollbackTableOptionsModel.SnapshotID = core.StringPtr("testString")
				rollbackTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				rollbackTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.RollbackTable(rollbackTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the RollbackTableOptions model with no property values
				rollbackTableOptionsModelNew := new(watsonxdatav2.RollbackTableOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.RollbackTable(rollbackTableOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke RollbackTable successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RollbackTableOptions model
				rollbackTableOptionsModel := new(watsonxdatav2.RollbackTableOptions)
				rollbackTableOptionsModel.EngineID = core.StringPtr("testString")
				rollbackTableOptionsModel.CatalogID = core.StringPtr("testString")
				rollbackTableOptionsModel.SchemaID = core.StringPtr("testString")
				rollbackTableOptionsModel.TableID = core.StringPtr("testString")
				rollbackTableOptionsModel.SnapshotID = core.StringPtr("testString")
				rollbackTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				rollbackTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.RollbackTable(rollbackTableOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateSyncCatalog(updateSyncCatalogOptions *UpdateSyncCatalogOptions) - Operation response error`, func() {
		updateSyncCatalogPath := "/catalogs/testString/sync"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateSyncCatalogPath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateSyncCatalog with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SyncCatalogs model
				syncCatalogsModel := new(watsonxdatav2.SyncCatalogs)
				syncCatalogsModel.AutoAddNewTables = core.BoolPtr(true)
				syncCatalogsModel.SyncIcebergMd = core.BoolPtr(true)
				syncCatalogsModelAsPatch, asPatchErr := syncCatalogsModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSyncCatalogOptions model
				updateSyncCatalogOptionsModel := new(watsonxdatav2.UpdateSyncCatalogOptions)
				updateSyncCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				updateSyncCatalogOptionsModel.Body = syncCatalogsModelAsPatch
				updateSyncCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSyncCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdateSyncCatalog(updateSyncCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdateSyncCatalog(updateSyncCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateSyncCatalog(updateSyncCatalogOptions *UpdateSyncCatalogOptions)`, func() {
		updateSyncCatalogPath := "/catalogs/testString/sync"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateSyncCatalogPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke UpdateSyncCatalog successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the SyncCatalogs model
				syncCatalogsModel := new(watsonxdatav2.SyncCatalogs)
				syncCatalogsModel.AutoAddNewTables = core.BoolPtr(true)
				syncCatalogsModel.SyncIcebergMd = core.BoolPtr(true)
				syncCatalogsModelAsPatch, asPatchErr := syncCatalogsModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSyncCatalogOptions model
				updateSyncCatalogOptionsModel := new(watsonxdatav2.UpdateSyncCatalogOptions)
				updateSyncCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				updateSyncCatalogOptionsModel.Body = syncCatalogsModelAsPatch
				updateSyncCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSyncCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdateSyncCatalogWithContext(ctx, updateSyncCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdateSyncCatalog(updateSyncCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdateSyncCatalogWithContext(ctx, updateSyncCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateSyncCatalogPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke UpdateSyncCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdateSyncCatalog(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the SyncCatalogs model
				syncCatalogsModel := new(watsonxdatav2.SyncCatalogs)
				syncCatalogsModel.AutoAddNewTables = core.BoolPtr(true)
				syncCatalogsModel.SyncIcebergMd = core.BoolPtr(true)
				syncCatalogsModelAsPatch, asPatchErr := syncCatalogsModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSyncCatalogOptions model
				updateSyncCatalogOptionsModel := new(watsonxdatav2.UpdateSyncCatalogOptions)
				updateSyncCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				updateSyncCatalogOptionsModel.Body = syncCatalogsModelAsPatch
				updateSyncCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSyncCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdateSyncCatalog(updateSyncCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateSyncCatalog with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SyncCatalogs model
				syncCatalogsModel := new(watsonxdatav2.SyncCatalogs)
				syncCatalogsModel.AutoAddNewTables = core.BoolPtr(true)
				syncCatalogsModel.SyncIcebergMd = core.BoolPtr(true)
				syncCatalogsModelAsPatch, asPatchErr := syncCatalogsModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSyncCatalogOptions model
				updateSyncCatalogOptionsModel := new(watsonxdatav2.UpdateSyncCatalogOptions)
				updateSyncCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				updateSyncCatalogOptionsModel.Body = syncCatalogsModelAsPatch
				updateSyncCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSyncCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdateSyncCatalog(updateSyncCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateSyncCatalogOptions model with no property values
				updateSyncCatalogOptionsModelNew := new(watsonxdatav2.UpdateSyncCatalogOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdateSyncCatalog(updateSyncCatalogOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateSyncCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SyncCatalogs model
				syncCatalogsModel := new(watsonxdatav2.SyncCatalogs)
				syncCatalogsModel.AutoAddNewTables = core.BoolPtr(true)
				syncCatalogsModel.SyncIcebergMd = core.BoolPtr(true)
				syncCatalogsModelAsPatch, asPatchErr := syncCatalogsModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSyncCatalogOptions model
				updateSyncCatalogOptionsModel := new(watsonxdatav2.UpdateSyncCatalogOptions)
				updateSyncCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				updateSyncCatalogOptionsModel.Body = syncCatalogsModelAsPatch
				updateSyncCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSyncCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdateSyncCatalog(updateSyncCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListMilvusServices(listMilvusServicesOptions *ListMilvusServicesOptions) - Operation response error`, func() {
		listMilvusServicesPath := "/milvus_services"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listMilvusServicesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListMilvusServices with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListMilvusServicesOptions model
				listMilvusServicesOptionsModel := new(watsonxdatav2.ListMilvusServicesOptions)
				listMilvusServicesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listMilvusServicesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListMilvusServices(listMilvusServicesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListMilvusServices(listMilvusServicesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListMilvusServices(listMilvusServicesOptions *ListMilvusServicesOptions)`, func() {
		listMilvusServicesPath := "/milvus_services"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listMilvusServicesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"milvus_services": [{"access_key": "Sample bucket access key", "actions": ["Actions"], "bucket_name": "Sample bucket name", "bucket_type": "Sample bucket type", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "milvus service for running sql queries", "endpoint": "Sample bucket type", "grpc_host": "example.grpc.host", "grpc_port": 8, "host_name": "sampleMilvus", "https_host": "example.https.host", "https_port": 9, "origin": "native", "root_path": "Sample path", "secret_key": "Sample bucket secret access key", "service_display_name": "sampleService", "service_id": "sampleService123", "status": "running", "status_code": 10, "tags": ["Tags"], "tshirt_size": "small", "type": "milvus"}]}`)
				}))
			})
			It(`Invoke ListMilvusServices successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListMilvusServicesOptions model
				listMilvusServicesOptionsModel := new(watsonxdatav2.ListMilvusServicesOptions)
				listMilvusServicesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listMilvusServicesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListMilvusServicesWithContext(ctx, listMilvusServicesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListMilvusServices(listMilvusServicesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListMilvusServicesWithContext(ctx, listMilvusServicesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listMilvusServicesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"milvus_services": [{"access_key": "Sample bucket access key", "actions": ["Actions"], "bucket_name": "Sample bucket name", "bucket_type": "Sample bucket type", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "milvus service for running sql queries", "endpoint": "Sample bucket type", "grpc_host": "example.grpc.host", "grpc_port": 8, "host_name": "sampleMilvus", "https_host": "example.https.host", "https_port": 9, "origin": "native", "root_path": "Sample path", "secret_key": "Sample bucket secret access key", "service_display_name": "sampleService", "service_id": "sampleService123", "status": "running", "status_code": 10, "tags": ["Tags"], "tshirt_size": "small", "type": "milvus"}]}`)
				}))
			})
			It(`Invoke ListMilvusServices successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListMilvusServices(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListMilvusServicesOptions model
				listMilvusServicesOptionsModel := new(watsonxdatav2.ListMilvusServicesOptions)
				listMilvusServicesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listMilvusServicesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListMilvusServices(listMilvusServicesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListMilvusServices with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListMilvusServicesOptions model
				listMilvusServicesOptionsModel := new(watsonxdatav2.ListMilvusServicesOptions)
				listMilvusServicesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listMilvusServicesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListMilvusServices(listMilvusServicesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListMilvusServices successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListMilvusServicesOptions model
				listMilvusServicesOptionsModel := new(watsonxdatav2.ListMilvusServicesOptions)
				listMilvusServicesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listMilvusServicesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListMilvusServices(listMilvusServicesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateMilvusService(createMilvusServiceOptions *CreateMilvusServiceOptions) - Operation response error`, func() {
		createMilvusServicePath := "/milvus_services"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createMilvusServicePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateMilvusService with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateMilvusServiceOptions model
				createMilvusServiceOptionsModel := new(watsonxdatav2.CreateMilvusServiceOptions)
				createMilvusServiceOptionsModel.BucketName = core.StringPtr("Sample bucket name")
				createMilvusServiceOptionsModel.Origin = core.StringPtr("native")
				createMilvusServiceOptionsModel.RootPath = core.StringPtr("Sample path")
				createMilvusServiceOptionsModel.ServiceDisplayName = core.StringPtr("sampleService")
				createMilvusServiceOptionsModel.BucketType = core.StringPtr("Sample bucket type")
				createMilvusServiceOptionsModel.Description = core.StringPtr("milvus service for running sql queries")
				createMilvusServiceOptionsModel.Tags = []string{"tag1", "tag2"}
				createMilvusServiceOptionsModel.TshirtSize = core.StringPtr("small")
				createMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateMilvusService(createMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateMilvusService(createMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateMilvusService(createMilvusServiceOptions *CreateMilvusServiceOptions)`, func() {
		createMilvusServicePath := "/milvus_services"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createMilvusServicePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"access_key": "Sample bucket access key", "actions": ["Actions"], "bucket_name": "Sample bucket name", "bucket_type": "Sample bucket type", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "milvus service for running sql queries", "endpoint": "Sample bucket type", "grpc_host": "example.grpc.host", "grpc_port": 8, "host_name": "sampleMilvus", "https_host": "example.https.host", "https_port": 9, "origin": "native", "root_path": "Sample path", "secret_key": "Sample bucket secret access key", "service_display_name": "sampleService", "service_id": "sampleService123", "status": "running", "status_code": 10, "tags": ["Tags"], "tshirt_size": "small", "type": "milvus"}`)
				}))
			})
			It(`Invoke CreateMilvusService successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreateMilvusServiceOptions model
				createMilvusServiceOptionsModel := new(watsonxdatav2.CreateMilvusServiceOptions)
				createMilvusServiceOptionsModel.BucketName = core.StringPtr("Sample bucket name")
				createMilvusServiceOptionsModel.Origin = core.StringPtr("native")
				createMilvusServiceOptionsModel.RootPath = core.StringPtr("Sample path")
				createMilvusServiceOptionsModel.ServiceDisplayName = core.StringPtr("sampleService")
				createMilvusServiceOptionsModel.BucketType = core.StringPtr("Sample bucket type")
				createMilvusServiceOptionsModel.Description = core.StringPtr("milvus service for running sql queries")
				createMilvusServiceOptionsModel.Tags = []string{"tag1", "tag2"}
				createMilvusServiceOptionsModel.TshirtSize = core.StringPtr("small")
				createMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateMilvusServiceWithContext(ctx, createMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateMilvusService(createMilvusServiceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateMilvusServiceWithContext(ctx, createMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createMilvusServicePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"access_key": "Sample bucket access key", "actions": ["Actions"], "bucket_name": "Sample bucket name", "bucket_type": "Sample bucket type", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "milvus service for running sql queries", "endpoint": "Sample bucket type", "grpc_host": "example.grpc.host", "grpc_port": 8, "host_name": "sampleMilvus", "https_host": "example.https.host", "https_port": 9, "origin": "native", "root_path": "Sample path", "secret_key": "Sample bucket secret access key", "service_display_name": "sampleService", "service_id": "sampleService123", "status": "running", "status_code": 10, "tags": ["Tags"], "tshirt_size": "small", "type": "milvus"}`)
				}))
			})
			It(`Invoke CreateMilvusService successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateMilvusService(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreateMilvusServiceOptions model
				createMilvusServiceOptionsModel := new(watsonxdatav2.CreateMilvusServiceOptions)
				createMilvusServiceOptionsModel.BucketName = core.StringPtr("Sample bucket name")
				createMilvusServiceOptionsModel.Origin = core.StringPtr("native")
				createMilvusServiceOptionsModel.RootPath = core.StringPtr("Sample path")
				createMilvusServiceOptionsModel.ServiceDisplayName = core.StringPtr("sampleService")
				createMilvusServiceOptionsModel.BucketType = core.StringPtr("Sample bucket type")
				createMilvusServiceOptionsModel.Description = core.StringPtr("milvus service for running sql queries")
				createMilvusServiceOptionsModel.Tags = []string{"tag1", "tag2"}
				createMilvusServiceOptionsModel.TshirtSize = core.StringPtr("small")
				createMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateMilvusService(createMilvusServiceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateMilvusService with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateMilvusServiceOptions model
				createMilvusServiceOptionsModel := new(watsonxdatav2.CreateMilvusServiceOptions)
				createMilvusServiceOptionsModel.BucketName = core.StringPtr("Sample bucket name")
				createMilvusServiceOptionsModel.Origin = core.StringPtr("native")
				createMilvusServiceOptionsModel.RootPath = core.StringPtr("Sample path")
				createMilvusServiceOptionsModel.ServiceDisplayName = core.StringPtr("sampleService")
				createMilvusServiceOptionsModel.BucketType = core.StringPtr("Sample bucket type")
				createMilvusServiceOptionsModel.Description = core.StringPtr("milvus service for running sql queries")
				createMilvusServiceOptionsModel.Tags = []string{"tag1", "tag2"}
				createMilvusServiceOptionsModel.TshirtSize = core.StringPtr("small")
				createMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateMilvusService(createMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateMilvusServiceOptions model with no property values
				createMilvusServiceOptionsModelNew := new(watsonxdatav2.CreateMilvusServiceOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateMilvusService(createMilvusServiceOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateMilvusService successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateMilvusServiceOptions model
				createMilvusServiceOptionsModel := new(watsonxdatav2.CreateMilvusServiceOptions)
				createMilvusServiceOptionsModel.BucketName = core.StringPtr("Sample bucket name")
				createMilvusServiceOptionsModel.Origin = core.StringPtr("native")
				createMilvusServiceOptionsModel.RootPath = core.StringPtr("Sample path")
				createMilvusServiceOptionsModel.ServiceDisplayName = core.StringPtr("sampleService")
				createMilvusServiceOptionsModel.BucketType = core.StringPtr("Sample bucket type")
				createMilvusServiceOptionsModel.Description = core.StringPtr("milvus service for running sql queries")
				createMilvusServiceOptionsModel.Tags = []string{"tag1", "tag2"}
				createMilvusServiceOptionsModel.TshirtSize = core.StringPtr("small")
				createMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateMilvusService(createMilvusServiceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetMilvusService(getMilvusServiceOptions *GetMilvusServiceOptions) - Operation response error`, func() {
		getMilvusServicePath := "/milvus_services/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getMilvusServicePath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetMilvusService with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetMilvusServiceOptions model
				getMilvusServiceOptionsModel := new(watsonxdatav2.GetMilvusServiceOptions)
				getMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				getMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetMilvusService(getMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetMilvusService(getMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetMilvusService(getMilvusServiceOptions *GetMilvusServiceOptions)`, func() {
		getMilvusServicePath := "/milvus_services/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getMilvusServicePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"access_key": "Sample bucket access key", "actions": ["Actions"], "bucket_name": "Sample bucket name", "bucket_type": "Sample bucket type", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "milvus service for running sql queries", "endpoint": "Sample bucket type", "grpc_host": "example.grpc.host", "grpc_port": 8, "host_name": "sampleMilvus", "https_host": "example.https.host", "https_port": 9, "origin": "native", "root_path": "Sample path", "secret_key": "Sample bucket secret access key", "service_display_name": "sampleService", "service_id": "sampleService123", "status": "running", "status_code": 10, "tags": ["Tags"], "tshirt_size": "small", "type": "milvus"}`)
				}))
			})
			It(`Invoke GetMilvusService successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetMilvusServiceOptions model
				getMilvusServiceOptionsModel := new(watsonxdatav2.GetMilvusServiceOptions)
				getMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				getMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetMilvusServiceWithContext(ctx, getMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetMilvusService(getMilvusServiceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetMilvusServiceWithContext(ctx, getMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getMilvusServicePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"access_key": "Sample bucket access key", "actions": ["Actions"], "bucket_name": "Sample bucket name", "bucket_type": "Sample bucket type", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "milvus service for running sql queries", "endpoint": "Sample bucket type", "grpc_host": "example.grpc.host", "grpc_port": 8, "host_name": "sampleMilvus", "https_host": "example.https.host", "https_port": 9, "origin": "native", "root_path": "Sample path", "secret_key": "Sample bucket secret access key", "service_display_name": "sampleService", "service_id": "sampleService123", "status": "running", "status_code": 10, "tags": ["Tags"], "tshirt_size": "small", "type": "milvus"}`)
				}))
			})
			It(`Invoke GetMilvusService successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetMilvusService(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetMilvusServiceOptions model
				getMilvusServiceOptionsModel := new(watsonxdatav2.GetMilvusServiceOptions)
				getMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				getMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetMilvusService(getMilvusServiceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetMilvusService with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetMilvusServiceOptions model
				getMilvusServiceOptionsModel := new(watsonxdatav2.GetMilvusServiceOptions)
				getMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				getMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetMilvusService(getMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetMilvusServiceOptions model with no property values
				getMilvusServiceOptionsModelNew := new(watsonxdatav2.GetMilvusServiceOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetMilvusService(getMilvusServiceOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetMilvusService successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetMilvusServiceOptions model
				getMilvusServiceOptionsModel := new(watsonxdatav2.GetMilvusServiceOptions)
				getMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				getMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetMilvusService(getMilvusServiceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteMilvusService(deleteMilvusServiceOptions *DeleteMilvusServiceOptions)`, func() {
		deleteMilvusServicePath := "/milvus_services/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteMilvusServicePath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteMilvusService successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteMilvusService(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteMilvusServiceOptions model
				deleteMilvusServiceOptionsModel := new(watsonxdatav2.DeleteMilvusServiceOptions)
				deleteMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				deleteMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteMilvusService(deleteMilvusServiceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteMilvusService with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteMilvusServiceOptions model
				deleteMilvusServiceOptionsModel := new(watsonxdatav2.DeleteMilvusServiceOptions)
				deleteMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				deleteMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteMilvusService(deleteMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteMilvusServiceOptions model with no property values
				deleteMilvusServiceOptionsModelNew := new(watsonxdatav2.DeleteMilvusServiceOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteMilvusService(deleteMilvusServiceOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateMilvusService(updateMilvusServiceOptions *UpdateMilvusServiceOptions) - Operation response error`, func() {
		updateMilvusServicePath := "/milvus_services/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateMilvusServicePath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateMilvusService with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the MilvusServicePatch model
				milvusServicePatchModel := new(watsonxdatav2.MilvusServicePatch)
				milvusServicePatchModel.Description = core.StringPtr("updated description for milvus service")
				milvusServicePatchModel.ServiceDisplayName = core.StringPtr("sampleService")
				milvusServicePatchModel.Tags = []string{"tag1", "tag2"}
				milvusServicePatchModelAsPatch, asPatchErr := milvusServicePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateMilvusServiceOptions model
				updateMilvusServiceOptionsModel := new(watsonxdatav2.UpdateMilvusServiceOptions)
				updateMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				updateMilvusServiceOptionsModel.Body = milvusServicePatchModelAsPatch
				updateMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdateMilvusService(updateMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdateMilvusService(updateMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateMilvusService(updateMilvusServiceOptions *UpdateMilvusServiceOptions)`, func() {
		updateMilvusServicePath := "/milvus_services/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateMilvusServicePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"access_key": "Sample bucket access key", "actions": ["Actions"], "bucket_name": "Sample bucket name", "bucket_type": "Sample bucket type", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "milvus service for running sql queries", "endpoint": "Sample bucket type", "grpc_host": "example.grpc.host", "grpc_port": 8, "host_name": "sampleMilvus", "https_host": "example.https.host", "https_port": 9, "origin": "native", "root_path": "Sample path", "secret_key": "Sample bucket secret access key", "service_display_name": "sampleService", "service_id": "sampleService123", "status": "running", "status_code": 10, "tags": ["Tags"], "tshirt_size": "small", "type": "milvus"}`)
				}))
			})
			It(`Invoke UpdateMilvusService successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the MilvusServicePatch model
				milvusServicePatchModel := new(watsonxdatav2.MilvusServicePatch)
				milvusServicePatchModel.Description = core.StringPtr("updated description for milvus service")
				milvusServicePatchModel.ServiceDisplayName = core.StringPtr("sampleService")
				milvusServicePatchModel.Tags = []string{"tag1", "tag2"}
				milvusServicePatchModelAsPatch, asPatchErr := milvusServicePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateMilvusServiceOptions model
				updateMilvusServiceOptionsModel := new(watsonxdatav2.UpdateMilvusServiceOptions)
				updateMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				updateMilvusServiceOptionsModel.Body = milvusServicePatchModelAsPatch
				updateMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdateMilvusServiceWithContext(ctx, updateMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdateMilvusService(updateMilvusServiceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdateMilvusServiceWithContext(ctx, updateMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateMilvusServicePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"access_key": "Sample bucket access key", "actions": ["Actions"], "bucket_name": "Sample bucket name", "bucket_type": "Sample bucket type", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "milvus service for running sql queries", "endpoint": "Sample bucket type", "grpc_host": "example.grpc.host", "grpc_port": 8, "host_name": "sampleMilvus", "https_host": "example.https.host", "https_port": 9, "origin": "native", "root_path": "Sample path", "secret_key": "Sample bucket secret access key", "service_display_name": "sampleService", "service_id": "sampleService123", "status": "running", "status_code": 10, "tags": ["Tags"], "tshirt_size": "small", "type": "milvus"}`)
				}))
			})
			It(`Invoke UpdateMilvusService successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdateMilvusService(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the MilvusServicePatch model
				milvusServicePatchModel := new(watsonxdatav2.MilvusServicePatch)
				milvusServicePatchModel.Description = core.StringPtr("updated description for milvus service")
				milvusServicePatchModel.ServiceDisplayName = core.StringPtr("sampleService")
				milvusServicePatchModel.Tags = []string{"tag1", "tag2"}
				milvusServicePatchModelAsPatch, asPatchErr := milvusServicePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateMilvusServiceOptions model
				updateMilvusServiceOptionsModel := new(watsonxdatav2.UpdateMilvusServiceOptions)
				updateMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				updateMilvusServiceOptionsModel.Body = milvusServicePatchModelAsPatch
				updateMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdateMilvusService(updateMilvusServiceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateMilvusService with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the MilvusServicePatch model
				milvusServicePatchModel := new(watsonxdatav2.MilvusServicePatch)
				milvusServicePatchModel.Description = core.StringPtr("updated description for milvus service")
				milvusServicePatchModel.ServiceDisplayName = core.StringPtr("sampleService")
				milvusServicePatchModel.Tags = []string{"tag1", "tag2"}
				milvusServicePatchModelAsPatch, asPatchErr := milvusServicePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateMilvusServiceOptions model
				updateMilvusServiceOptionsModel := new(watsonxdatav2.UpdateMilvusServiceOptions)
				updateMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				updateMilvusServiceOptionsModel.Body = milvusServicePatchModelAsPatch
				updateMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdateMilvusService(updateMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateMilvusServiceOptions model with no property values
				updateMilvusServiceOptionsModelNew := new(watsonxdatav2.UpdateMilvusServiceOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdateMilvusService(updateMilvusServiceOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateMilvusService successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the MilvusServicePatch model
				milvusServicePatchModel := new(watsonxdatav2.MilvusServicePatch)
				milvusServicePatchModel.Description = core.StringPtr("updated description for milvus service")
				milvusServicePatchModel.ServiceDisplayName = core.StringPtr("sampleService")
				milvusServicePatchModel.Tags = []string{"tag1", "tag2"}
				milvusServicePatchModelAsPatch, asPatchErr := milvusServicePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateMilvusServiceOptions model
				updateMilvusServiceOptionsModel := new(watsonxdatav2.UpdateMilvusServiceOptions)
				updateMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				updateMilvusServiceOptionsModel.Body = milvusServicePatchModelAsPatch
				updateMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdateMilvusService(updateMilvusServiceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListMilvusServiceDatabases(listMilvusServiceDatabasesOptions *ListMilvusServiceDatabasesOptions) - Operation response error`, func() {
		listMilvusServiceDatabasesPath := "/milvus_services/testString/databases"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listMilvusServiceDatabasesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListMilvusServiceDatabases with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListMilvusServiceDatabasesOptions model
				listMilvusServiceDatabasesOptionsModel := new(watsonxdatav2.ListMilvusServiceDatabasesOptions)
				listMilvusServiceDatabasesOptionsModel.ServiceID = core.StringPtr("testString")
				listMilvusServiceDatabasesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listMilvusServiceDatabasesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListMilvusServiceDatabases(listMilvusServiceDatabasesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListMilvusServiceDatabases(listMilvusServiceDatabasesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListMilvusServiceDatabases(listMilvusServiceDatabasesOptions *ListMilvusServiceDatabasesOptions)`, func() {
		listMilvusServiceDatabasesPath := "/milvus_services/testString/databases"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listMilvusServiceDatabasesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"databases": ["default"]}`)
				}))
			})
			It(`Invoke ListMilvusServiceDatabases successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListMilvusServiceDatabasesOptions model
				listMilvusServiceDatabasesOptionsModel := new(watsonxdatav2.ListMilvusServiceDatabasesOptions)
				listMilvusServiceDatabasesOptionsModel.ServiceID = core.StringPtr("testString")
				listMilvusServiceDatabasesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listMilvusServiceDatabasesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListMilvusServiceDatabasesWithContext(ctx, listMilvusServiceDatabasesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListMilvusServiceDatabases(listMilvusServiceDatabasesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListMilvusServiceDatabasesWithContext(ctx, listMilvusServiceDatabasesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listMilvusServiceDatabasesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"databases": ["default"]}`)
				}))
			})
			It(`Invoke ListMilvusServiceDatabases successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListMilvusServiceDatabases(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListMilvusServiceDatabasesOptions model
				listMilvusServiceDatabasesOptionsModel := new(watsonxdatav2.ListMilvusServiceDatabasesOptions)
				listMilvusServiceDatabasesOptionsModel.ServiceID = core.StringPtr("testString")
				listMilvusServiceDatabasesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listMilvusServiceDatabasesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListMilvusServiceDatabases(listMilvusServiceDatabasesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListMilvusServiceDatabases with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListMilvusServiceDatabasesOptions model
				listMilvusServiceDatabasesOptionsModel := new(watsonxdatav2.ListMilvusServiceDatabasesOptions)
				listMilvusServiceDatabasesOptionsModel.ServiceID = core.StringPtr("testString")
				listMilvusServiceDatabasesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listMilvusServiceDatabasesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListMilvusServiceDatabases(listMilvusServiceDatabasesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListMilvusServiceDatabasesOptions model with no property values
				listMilvusServiceDatabasesOptionsModelNew := new(watsonxdatav2.ListMilvusServiceDatabasesOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListMilvusServiceDatabases(listMilvusServiceDatabasesOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListMilvusServiceDatabases successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListMilvusServiceDatabasesOptions model
				listMilvusServiceDatabasesOptionsModel := new(watsonxdatav2.ListMilvusServiceDatabasesOptions)
				listMilvusServiceDatabasesOptionsModel.ServiceID = core.StringPtr("testString")
				listMilvusServiceDatabasesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listMilvusServiceDatabasesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListMilvusServiceDatabases(listMilvusServiceDatabasesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListMilvusDatabaseCollections(listMilvusDatabaseCollectionsOptions *ListMilvusDatabaseCollectionsOptions) - Operation response error`, func() {
		listMilvusDatabaseCollectionsPath := "/milvus_services/testString/databases/testString/collections"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listMilvusDatabaseCollectionsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListMilvusDatabaseCollections with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListMilvusDatabaseCollectionsOptions model
				listMilvusDatabaseCollectionsOptionsModel := new(watsonxdatav2.ListMilvusDatabaseCollectionsOptions)
				listMilvusDatabaseCollectionsOptionsModel.ServiceID = core.StringPtr("testString")
				listMilvusDatabaseCollectionsOptionsModel.DatabaseID = core.StringPtr("testString")
				listMilvusDatabaseCollectionsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listMilvusDatabaseCollectionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListMilvusDatabaseCollections(listMilvusDatabaseCollectionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListMilvusDatabaseCollections(listMilvusDatabaseCollectionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListMilvusDatabaseCollections(listMilvusDatabaseCollectionsOptions *ListMilvusDatabaseCollectionsOptions)`, func() {
		listMilvusDatabaseCollectionsPath := "/milvus_services/testString/databases/testString/collections"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listMilvusDatabaseCollectionsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"collections": [{"collection_id": 12, "collection_name": "col1", "physical_channels": ["PhysicalChannels"], "virtual_channels": ["VirtualChannels"]}]}`)
				}))
			})
			It(`Invoke ListMilvusDatabaseCollections successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListMilvusDatabaseCollectionsOptions model
				listMilvusDatabaseCollectionsOptionsModel := new(watsonxdatav2.ListMilvusDatabaseCollectionsOptions)
				listMilvusDatabaseCollectionsOptionsModel.ServiceID = core.StringPtr("testString")
				listMilvusDatabaseCollectionsOptionsModel.DatabaseID = core.StringPtr("testString")
				listMilvusDatabaseCollectionsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listMilvusDatabaseCollectionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListMilvusDatabaseCollectionsWithContext(ctx, listMilvusDatabaseCollectionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListMilvusDatabaseCollections(listMilvusDatabaseCollectionsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListMilvusDatabaseCollectionsWithContext(ctx, listMilvusDatabaseCollectionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listMilvusDatabaseCollectionsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"collections": [{"collection_id": 12, "collection_name": "col1", "physical_channels": ["PhysicalChannels"], "virtual_channels": ["VirtualChannels"]}]}`)
				}))
			})
			It(`Invoke ListMilvusDatabaseCollections successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListMilvusDatabaseCollections(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListMilvusDatabaseCollectionsOptions model
				listMilvusDatabaseCollectionsOptionsModel := new(watsonxdatav2.ListMilvusDatabaseCollectionsOptions)
				listMilvusDatabaseCollectionsOptionsModel.ServiceID = core.StringPtr("testString")
				listMilvusDatabaseCollectionsOptionsModel.DatabaseID = core.StringPtr("testString")
				listMilvusDatabaseCollectionsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listMilvusDatabaseCollectionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListMilvusDatabaseCollections(listMilvusDatabaseCollectionsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListMilvusDatabaseCollections with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListMilvusDatabaseCollectionsOptions model
				listMilvusDatabaseCollectionsOptionsModel := new(watsonxdatav2.ListMilvusDatabaseCollectionsOptions)
				listMilvusDatabaseCollectionsOptionsModel.ServiceID = core.StringPtr("testString")
				listMilvusDatabaseCollectionsOptionsModel.DatabaseID = core.StringPtr("testString")
				listMilvusDatabaseCollectionsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listMilvusDatabaseCollectionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListMilvusDatabaseCollections(listMilvusDatabaseCollectionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListMilvusDatabaseCollectionsOptions model with no property values
				listMilvusDatabaseCollectionsOptionsModelNew := new(watsonxdatav2.ListMilvusDatabaseCollectionsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListMilvusDatabaseCollections(listMilvusDatabaseCollectionsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListMilvusDatabaseCollections successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListMilvusDatabaseCollectionsOptions model
				listMilvusDatabaseCollectionsOptionsModel := new(watsonxdatav2.ListMilvusDatabaseCollectionsOptions)
				listMilvusDatabaseCollectionsOptionsModel.ServiceID = core.StringPtr("testString")
				listMilvusDatabaseCollectionsOptionsModel.DatabaseID = core.StringPtr("testString")
				listMilvusDatabaseCollectionsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listMilvusDatabaseCollectionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListMilvusDatabaseCollections(listMilvusDatabaseCollectionsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateMilvusServicePause(createMilvusServicePauseOptions *CreateMilvusServicePauseOptions) - Operation response error`, func() {
		createMilvusServicePausePath := "/milvus_services/testString/pause"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createMilvusServicePausePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateMilvusServicePause with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateMilvusServicePauseOptions model
				createMilvusServicePauseOptionsModel := new(watsonxdatav2.CreateMilvusServicePauseOptions)
				createMilvusServicePauseOptionsModel.ServiceID = core.StringPtr("testString")
				createMilvusServicePauseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServicePauseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateMilvusServicePause(createMilvusServicePauseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateMilvusServicePause(createMilvusServicePauseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateMilvusServicePause(createMilvusServicePauseOptions *CreateMilvusServicePauseOptions)`, func() {
		createMilvusServicePausePath := "/milvus_services/testString/pause"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createMilvusServicePausePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke CreateMilvusServicePause successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreateMilvusServicePauseOptions model
				createMilvusServicePauseOptionsModel := new(watsonxdatav2.CreateMilvusServicePauseOptions)
				createMilvusServicePauseOptionsModel.ServiceID = core.StringPtr("testString")
				createMilvusServicePauseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServicePauseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateMilvusServicePauseWithContext(ctx, createMilvusServicePauseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateMilvusServicePause(createMilvusServicePauseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateMilvusServicePauseWithContext(ctx, createMilvusServicePauseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createMilvusServicePausePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke CreateMilvusServicePause successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateMilvusServicePause(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreateMilvusServicePauseOptions model
				createMilvusServicePauseOptionsModel := new(watsonxdatav2.CreateMilvusServicePauseOptions)
				createMilvusServicePauseOptionsModel.ServiceID = core.StringPtr("testString")
				createMilvusServicePauseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServicePauseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateMilvusServicePause(createMilvusServicePauseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateMilvusServicePause with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateMilvusServicePauseOptions model
				createMilvusServicePauseOptionsModel := new(watsonxdatav2.CreateMilvusServicePauseOptions)
				createMilvusServicePauseOptionsModel.ServiceID = core.StringPtr("testString")
				createMilvusServicePauseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServicePauseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateMilvusServicePause(createMilvusServicePauseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateMilvusServicePauseOptions model with no property values
				createMilvusServicePauseOptionsModelNew := new(watsonxdatav2.CreateMilvusServicePauseOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateMilvusServicePause(createMilvusServicePauseOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateMilvusServicePause successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateMilvusServicePauseOptions model
				createMilvusServicePauseOptionsModel := new(watsonxdatav2.CreateMilvusServicePauseOptions)
				createMilvusServicePauseOptionsModel.ServiceID = core.StringPtr("testString")
				createMilvusServicePauseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServicePauseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateMilvusServicePause(createMilvusServicePauseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateMilvusServiceResume(createMilvusServiceResumeOptions *CreateMilvusServiceResumeOptions) - Operation response error`, func() {
		createMilvusServiceResumePath := "/milvus_services/testString/resume"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createMilvusServiceResumePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateMilvusServiceResume with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateMilvusServiceResumeOptions model
				createMilvusServiceResumeOptionsModel := new(watsonxdatav2.CreateMilvusServiceResumeOptions)
				createMilvusServiceResumeOptionsModel.ServiceID = core.StringPtr("testString")
				createMilvusServiceResumeOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServiceResumeOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateMilvusServiceResume(createMilvusServiceResumeOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateMilvusServiceResume(createMilvusServiceResumeOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateMilvusServiceResume(createMilvusServiceResumeOptions *CreateMilvusServiceResumeOptions)`, func() {
		createMilvusServiceResumePath := "/milvus_services/testString/resume"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createMilvusServiceResumePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke CreateMilvusServiceResume successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreateMilvusServiceResumeOptions model
				createMilvusServiceResumeOptionsModel := new(watsonxdatav2.CreateMilvusServiceResumeOptions)
				createMilvusServiceResumeOptionsModel.ServiceID = core.StringPtr("testString")
				createMilvusServiceResumeOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServiceResumeOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateMilvusServiceResumeWithContext(ctx, createMilvusServiceResumeOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateMilvusServiceResume(createMilvusServiceResumeOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateMilvusServiceResumeWithContext(ctx, createMilvusServiceResumeOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createMilvusServiceResumePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke CreateMilvusServiceResume successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateMilvusServiceResume(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreateMilvusServiceResumeOptions model
				createMilvusServiceResumeOptionsModel := new(watsonxdatav2.CreateMilvusServiceResumeOptions)
				createMilvusServiceResumeOptionsModel.ServiceID = core.StringPtr("testString")
				createMilvusServiceResumeOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServiceResumeOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateMilvusServiceResume(createMilvusServiceResumeOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateMilvusServiceResume with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateMilvusServiceResumeOptions model
				createMilvusServiceResumeOptionsModel := new(watsonxdatav2.CreateMilvusServiceResumeOptions)
				createMilvusServiceResumeOptionsModel.ServiceID = core.StringPtr("testString")
				createMilvusServiceResumeOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServiceResumeOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateMilvusServiceResume(createMilvusServiceResumeOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateMilvusServiceResumeOptions model with no property values
				createMilvusServiceResumeOptionsModelNew := new(watsonxdatav2.CreateMilvusServiceResumeOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateMilvusServiceResume(createMilvusServiceResumeOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateMilvusServiceResume successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateMilvusServiceResumeOptions model
				createMilvusServiceResumeOptionsModel := new(watsonxdatav2.CreateMilvusServiceResumeOptions)
				createMilvusServiceResumeOptionsModel.ServiceID = core.StringPtr("testString")
				createMilvusServiceResumeOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServiceResumeOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateMilvusServiceResume(createMilvusServiceResumeOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateMilvusServiceScale(createMilvusServiceScaleOptions *CreateMilvusServiceScaleOptions) - Operation response error`, func() {
		createMilvusServiceScalePath := "/milvus_services/testString/scale"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createMilvusServiceScalePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateMilvusServiceScale with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateMilvusServiceScaleOptions model
				createMilvusServiceScaleOptionsModel := new(watsonxdatav2.CreateMilvusServiceScaleOptions)
				createMilvusServiceScaleOptionsModel.ServiceID = core.StringPtr("testString")
				createMilvusServiceScaleOptionsModel.TshirtSize = core.StringPtr("small")
				createMilvusServiceScaleOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServiceScaleOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateMilvusServiceScale(createMilvusServiceScaleOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateMilvusServiceScale(createMilvusServiceScaleOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateMilvusServiceScale(createMilvusServiceScaleOptions *CreateMilvusServiceScaleOptions)`, func() {
		createMilvusServiceScalePath := "/milvus_services/testString/scale"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createMilvusServiceScalePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke CreateMilvusServiceScale successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreateMilvusServiceScaleOptions model
				createMilvusServiceScaleOptionsModel := new(watsonxdatav2.CreateMilvusServiceScaleOptions)
				createMilvusServiceScaleOptionsModel.ServiceID = core.StringPtr("testString")
				createMilvusServiceScaleOptionsModel.TshirtSize = core.StringPtr("small")
				createMilvusServiceScaleOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServiceScaleOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateMilvusServiceScaleWithContext(ctx, createMilvusServiceScaleOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateMilvusServiceScale(createMilvusServiceScaleOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateMilvusServiceScaleWithContext(ctx, createMilvusServiceScaleOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createMilvusServiceScalePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke CreateMilvusServiceScale successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateMilvusServiceScale(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreateMilvusServiceScaleOptions model
				createMilvusServiceScaleOptionsModel := new(watsonxdatav2.CreateMilvusServiceScaleOptions)
				createMilvusServiceScaleOptionsModel.ServiceID = core.StringPtr("testString")
				createMilvusServiceScaleOptionsModel.TshirtSize = core.StringPtr("small")
				createMilvusServiceScaleOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServiceScaleOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateMilvusServiceScale(createMilvusServiceScaleOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateMilvusServiceScale with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateMilvusServiceScaleOptions model
				createMilvusServiceScaleOptionsModel := new(watsonxdatav2.CreateMilvusServiceScaleOptions)
				createMilvusServiceScaleOptionsModel.ServiceID = core.StringPtr("testString")
				createMilvusServiceScaleOptionsModel.TshirtSize = core.StringPtr("small")
				createMilvusServiceScaleOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServiceScaleOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateMilvusServiceScale(createMilvusServiceScaleOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateMilvusServiceScaleOptions model with no property values
				createMilvusServiceScaleOptionsModelNew := new(watsonxdatav2.CreateMilvusServiceScaleOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateMilvusServiceScale(createMilvusServiceScaleOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateMilvusServiceScale successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateMilvusServiceScaleOptions model
				createMilvusServiceScaleOptionsModel := new(watsonxdatav2.CreateMilvusServiceScaleOptions)
				createMilvusServiceScaleOptionsModel.ServiceID = core.StringPtr("testString")
				createMilvusServiceScaleOptionsModel.TshirtSize = core.StringPtr("small")
				createMilvusServiceScaleOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServiceScaleOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateMilvusServiceScale(createMilvusServiceScaleOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListIngestionJobs(listIngestionJobsOptions *ListIngestionJobsOptions) - Operation response error`, func() {
		listIngestionJobsPath := "/ingestion_jobs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listIngestionJobsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["start"]).To(Equal([]string{"1"}))
					Expect(req.URL.Query()["jobs_per_page"]).To(Equal([]string{fmt.Sprint(int64(1))}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListIngestionJobs with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListIngestionJobsOptions model
				listIngestionJobsOptionsModel := new(watsonxdatav2.ListIngestionJobsOptions)
				listIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listIngestionJobsOptionsModel.Start = core.StringPtr("1")
				listIngestionJobsOptionsModel.JobsPerPage = core.Int64Ptr(int64(1))
				listIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListIngestionJobs(listIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListIngestionJobs(listIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListIngestionJobs(listIngestionJobsOptions *ListIngestionJobsOptions)`, func() {
		listIngestionJobsPath := "/ingestion_jobs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listIngestionJobsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["start"]).To(Equal([]string{"1"}))
					Expect(req.URL.Query()["jobs_per_page"]).To(Equal([]string{fmt.Sprint(int64(1))}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"ingestion_jobs": [{"create_if_not_exist": false, "csv_property": {"encoding": "utf-8", "escape_character": "|", "field_delimiter": ",", "header": true, "line_delimiter": "\n"}, "details": "Path does not exist 'demobucket/data/yellow_tripdata_2022-01.parquet'. Detail: [errno 2] No such file or directory", "end_timestamp": "1685088775", "engine_id": "spark123", "engine_name": "sparkdemo", "execute_config": {"driver_cores": 1, "driver_memory": "2G", "executor_cores": 1, "executor_memory": "2G", "num_executors": 1}, "instance_id": "1684432229673971", "job_id": "ingestion-1699459946935", "partition_by": "col1, col2", "schema": "{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}", "source_data_files": "s3://demobucket/data/yellow_tripdata_2022-01.parquet", "source_file_type": "csv", "start_timestamp": "1685084455", "status": "running", "target_table": "demodb.test.targettable", "username": "ibmlhadmin", "validate_csv_header": false}], "first": {"href": "http://api.example.com/collection?start=eyJvZmZzZXQiOjAsImRvbmUiOnRydWV9"}, "next": {"href": "http://api.example.com/collection?start=eyJvZmZzZXQiOjAsImRvbmUiOnRydWV9"}}`)
				}))
			})
			It(`Invoke ListIngestionJobs successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListIngestionJobsOptions model
				listIngestionJobsOptionsModel := new(watsonxdatav2.ListIngestionJobsOptions)
				listIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listIngestionJobsOptionsModel.Start = core.StringPtr("1")
				listIngestionJobsOptionsModel.JobsPerPage = core.Int64Ptr(int64(1))
				listIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListIngestionJobsWithContext(ctx, listIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListIngestionJobs(listIngestionJobsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListIngestionJobsWithContext(ctx, listIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listIngestionJobsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["start"]).To(Equal([]string{"1"}))
					Expect(req.URL.Query()["jobs_per_page"]).To(Equal([]string{fmt.Sprint(int64(1))}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"ingestion_jobs": [{"create_if_not_exist": false, "csv_property": {"encoding": "utf-8", "escape_character": "|", "field_delimiter": ",", "header": true, "line_delimiter": "\n"}, "details": "Path does not exist 'demobucket/data/yellow_tripdata_2022-01.parquet'. Detail: [errno 2] No such file or directory", "end_timestamp": "1685088775", "engine_id": "spark123", "engine_name": "sparkdemo", "execute_config": {"driver_cores": 1, "driver_memory": "2G", "executor_cores": 1, "executor_memory": "2G", "num_executors": 1}, "instance_id": "1684432229673971", "job_id": "ingestion-1699459946935", "partition_by": "col1, col2", "schema": "{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}", "source_data_files": "s3://demobucket/data/yellow_tripdata_2022-01.parquet", "source_file_type": "csv", "start_timestamp": "1685084455", "status": "running", "target_table": "demodb.test.targettable", "username": "ibmlhadmin", "validate_csv_header": false}], "first": {"href": "http://api.example.com/collection?start=eyJvZmZzZXQiOjAsImRvbmUiOnRydWV9"}, "next": {"href": "http://api.example.com/collection?start=eyJvZmZzZXQiOjAsImRvbmUiOnRydWV9"}}`)
				}))
			})
			It(`Invoke ListIngestionJobs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListIngestionJobs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListIngestionJobsOptions model
				listIngestionJobsOptionsModel := new(watsonxdatav2.ListIngestionJobsOptions)
				listIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listIngestionJobsOptionsModel.Start = core.StringPtr("1")
				listIngestionJobsOptionsModel.JobsPerPage = core.Int64Ptr(int64(1))
				listIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListIngestionJobs(listIngestionJobsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListIngestionJobs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListIngestionJobsOptions model
				listIngestionJobsOptionsModel := new(watsonxdatav2.ListIngestionJobsOptions)
				listIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listIngestionJobsOptionsModel.Start = core.StringPtr("1")
				listIngestionJobsOptionsModel.JobsPerPage = core.Int64Ptr(int64(1))
				listIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListIngestionJobs(listIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListIngestionJobsOptions model with no property values
				listIngestionJobsOptionsModelNew := new(watsonxdatav2.ListIngestionJobsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListIngestionJobs(listIngestionJobsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListIngestionJobs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListIngestionJobsOptions model
				listIngestionJobsOptionsModel := new(watsonxdatav2.ListIngestionJobsOptions)
				listIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listIngestionJobsOptionsModel.Start = core.StringPtr("1")
				listIngestionJobsOptionsModel.JobsPerPage = core.Int64Ptr(int64(1))
				listIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListIngestionJobs(listIngestionJobsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Test pagination helper method on response`, func() {
			It(`Invoke GetNextStart successfully`, func() {
				responseObject := new(watsonxdatav2.IngestionJobCollection)
				nextObject := new(watsonxdatav2.IngestionJobCollectionPage)
				nextObject.Href = core.StringPtr("ibm.com?start=abc-123")
				responseObject.Next = nextObject

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(Equal(core.StringPtr("abc-123")))
			})
			It(`Invoke GetNextStart without a "Next" property in the response`, func() {
				responseObject := new(watsonxdatav2.IngestionJobCollection)

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
			It(`Invoke GetNextStart without any query params in the "Next" URL`, func() {
				responseObject := new(watsonxdatav2.IngestionJobCollection)
				nextObject := new(watsonxdatav2.IngestionJobCollectionPage)
				nextObject.Href = core.StringPtr("ibm.com")
				responseObject.Next = nextObject

				value, err := responseObject.GetNextStart()
				Expect(err).To(BeNil())
				Expect(value).To(BeNil())
			})
		})
		Context(`Using mock server endpoint - paginated response`, func() {
			BeforeEach(func() {
				var requestNumber int = 0
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listIngestionJobsPath))
					Expect(req.Method).To(Equal("GET"))

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					requestNumber++
					if requestNumber == 1 {
						fmt.Fprintf(res, "%s", `{"next":{"href":"https://myhost.com/somePath?start=1"},"total_count":2,"limit":1,"ingestion_jobs":[{"create_if_not_exist":false,"csv_property":{"encoding":"utf-8","escape_character":"|","field_delimiter":",","header":true,"line_delimiter":"\n"},"details":"Path does not exist 'demobucket/data/yellow_tripdata_2022-01.parquet'. Detail: [errno 2] No such file or directory","end_timestamp":"1685088775","engine_id":"spark123","engine_name":"sparkdemo","execute_config":{"driver_cores":1,"driver_memory":"2G","executor_cores":1,"executor_memory":"2G","num_executors":1},"instance_id":"1684432229673971","job_id":"ingestion-1699459946935","partition_by":"col1, col2","schema":"{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}","source_data_files":"s3://demobucket/data/yellow_tripdata_2022-01.parquet","source_file_type":"csv","start_timestamp":"1685084455","status":"running","target_table":"demodb.test.targettable","username":"ibmlhadmin","validate_csv_header":false}]}`)
					} else if requestNumber == 2 {
						fmt.Fprintf(res, "%s", `{"total_count":2,"limit":1,"ingestion_jobs":[{"create_if_not_exist":false,"csv_property":{"encoding":"utf-8","escape_character":"|","field_delimiter":",","header":true,"line_delimiter":"\n"},"details":"Path does not exist 'demobucket/data/yellow_tripdata_2022-01.parquet'. Detail: [errno 2] No such file or directory","end_timestamp":"1685088775","engine_id":"spark123","engine_name":"sparkdemo","execute_config":{"driver_cores":1,"driver_memory":"2G","executor_cores":1,"executor_memory":"2G","num_executors":1},"instance_id":"1684432229673971","job_id":"ingestion-1699459946935","partition_by":"col1, col2","schema":"{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}","source_data_files":"s3://demobucket/data/yellow_tripdata_2022-01.parquet","source_file_type":"csv","start_timestamp":"1685084455","status":"running","target_table":"demodb.test.targettable","username":"ibmlhadmin","validate_csv_header":false}]}`)
					} else {
						res.WriteHeader(400)
					}
				}))
			})
			It(`Use IngestionJobsPager.GetNext successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				listIngestionJobsOptionsModel := &watsonxdatav2.ListIngestionJobsOptions{
					AuthInstanceID: core.StringPtr("testString"),
					JobsPerPage: core.Int64Ptr(int64(1)),
				}

				pager, err := watsonxDataService.NewIngestionJobsPager(listIngestionJobsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				var allResults []watsonxdatav2.IngestionJob
				for pager.HasNext() {
					nextPage, err := pager.GetNext()
					Expect(err).To(BeNil())
					Expect(nextPage).ToNot(BeNil())
					allResults = append(allResults, nextPage...)
				}
				Expect(len(allResults)).To(Equal(2))
			})
			It(`Use IngestionJobsPager.GetAll successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				listIngestionJobsOptionsModel := &watsonxdatav2.ListIngestionJobsOptions{
					AuthInstanceID: core.StringPtr("testString"),
					JobsPerPage: core.Int64Ptr(int64(1)),
				}

				pager, err := watsonxDataService.NewIngestionJobsPager(listIngestionJobsOptionsModel)
				Expect(err).To(BeNil())
				Expect(pager).ToNot(BeNil())

				allResults, err := pager.GetAll()
				Expect(err).To(BeNil())
				Expect(allResults).ToNot(BeNil())
				Expect(len(allResults)).To(Equal(2))
			})
		})
	})
	Describe(`CreateIngestionJobs(createIngestionJobsOptions *CreateIngestionJobsOptions) - Operation response error`, func() {
		createIngestionJobsPath := "/ingestion_jobs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createIngestionJobsPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateIngestionJobs with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the IngestionJobPrototypeCsvProperty model
				ingestionJobPrototypeCsvPropertyModel := new(watsonxdatav2.IngestionJobPrototypeCsvProperty)
				ingestionJobPrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				ingestionJobPrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				ingestionJobPrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				ingestionJobPrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				ingestionJobPrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")

				// Construct an instance of the IngestionJobPrototypeExecuteConfig model
				ingestionJobPrototypeExecuteConfigModel := new(watsonxdatav2.IngestionJobPrototypeExecuteConfig)
				ingestionJobPrototypeExecuteConfigModel.DriverCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.DriverMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.ExecutorCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.ExecutorMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.NumExecutors = core.Int64Ptr(int64(1))

				// Construct an instance of the CreateIngestionJobsOptions model
				createIngestionJobsOptionsModel := new(watsonxdatav2.CreateIngestionJobsOptions)
				createIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIngestionJobsOptionsModel.JobID = core.StringPtr("ingestion-1699459946935")
				createIngestionJobsOptionsModel.SourceDataFiles = core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createIngestionJobsOptionsModel.TargetTable = core.StringPtr("demodb.test.targettable")
				createIngestionJobsOptionsModel.Username = core.StringPtr("user1")
				createIngestionJobsOptionsModel.CreateIfNotExist = core.BoolPtr(false)
				createIngestionJobsOptionsModel.CsvProperty = ingestionJobPrototypeCsvPropertyModel
				createIngestionJobsOptionsModel.EngineID = core.StringPtr("spark123")
				createIngestionJobsOptionsModel.ExecuteConfig = ingestionJobPrototypeExecuteConfigModel
				createIngestionJobsOptionsModel.PartitionBy = core.StringPtr("col1, col2")
				createIngestionJobsOptionsModel.Schema = core.StringPtr("{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}")
				createIngestionJobsOptionsModel.SourceFileType = core.StringPtr("csv")
				createIngestionJobsOptionsModel.ValidateCsvHeader = core.BoolPtr(false)
				createIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateIngestionJobs(createIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateIngestionJobs(createIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateIngestionJobs(createIngestionJobsOptions *CreateIngestionJobsOptions)`, func() {
		createIngestionJobsPath := "/ingestion_jobs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createIngestionJobsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"create_if_not_exist": false, "csv_property": {"encoding": "utf-8", "escape_character": "|", "field_delimiter": ",", "header": true, "line_delimiter": "\n"}, "details": "Path does not exist 'demobucket/data/yellow_tripdata_2022-01.parquet'. Detail: [errno 2] No such file or directory", "end_timestamp": "1685088775", "engine_id": "spark123", "engine_name": "sparkdemo", "execute_config": {"driver_cores": 1, "driver_memory": "2G", "executor_cores": 1, "executor_memory": "2G", "num_executors": 1}, "instance_id": "1684432229673971", "job_id": "ingestion-1699459946935", "partition_by": "col1, col2", "schema": "{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}", "source_data_files": "s3://demobucket/data/yellow_tripdata_2022-01.parquet", "source_file_type": "csv", "start_timestamp": "1685084455", "status": "running", "target_table": "demodb.test.targettable", "username": "ibmlhadmin", "validate_csv_header": false}`)
				}))
			})
			It(`Invoke CreateIngestionJobs successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the IngestionJobPrototypeCsvProperty model
				ingestionJobPrototypeCsvPropertyModel := new(watsonxdatav2.IngestionJobPrototypeCsvProperty)
				ingestionJobPrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				ingestionJobPrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				ingestionJobPrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				ingestionJobPrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				ingestionJobPrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")

				// Construct an instance of the IngestionJobPrototypeExecuteConfig model
				ingestionJobPrototypeExecuteConfigModel := new(watsonxdatav2.IngestionJobPrototypeExecuteConfig)
				ingestionJobPrototypeExecuteConfigModel.DriverCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.DriverMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.ExecutorCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.ExecutorMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.NumExecutors = core.Int64Ptr(int64(1))

				// Construct an instance of the CreateIngestionJobsOptions model
				createIngestionJobsOptionsModel := new(watsonxdatav2.CreateIngestionJobsOptions)
				createIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIngestionJobsOptionsModel.JobID = core.StringPtr("ingestion-1699459946935")
				createIngestionJobsOptionsModel.SourceDataFiles = core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createIngestionJobsOptionsModel.TargetTable = core.StringPtr("demodb.test.targettable")
				createIngestionJobsOptionsModel.Username = core.StringPtr("user1")
				createIngestionJobsOptionsModel.CreateIfNotExist = core.BoolPtr(false)
				createIngestionJobsOptionsModel.CsvProperty = ingestionJobPrototypeCsvPropertyModel
				createIngestionJobsOptionsModel.EngineID = core.StringPtr("spark123")
				createIngestionJobsOptionsModel.ExecuteConfig = ingestionJobPrototypeExecuteConfigModel
				createIngestionJobsOptionsModel.PartitionBy = core.StringPtr("col1, col2")
				createIngestionJobsOptionsModel.Schema = core.StringPtr("{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}")
				createIngestionJobsOptionsModel.SourceFileType = core.StringPtr("csv")
				createIngestionJobsOptionsModel.ValidateCsvHeader = core.BoolPtr(false)
				createIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateIngestionJobsWithContext(ctx, createIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateIngestionJobs(createIngestionJobsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateIngestionJobsWithContext(ctx, createIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createIngestionJobsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"create_if_not_exist": false, "csv_property": {"encoding": "utf-8", "escape_character": "|", "field_delimiter": ",", "header": true, "line_delimiter": "\n"}, "details": "Path does not exist 'demobucket/data/yellow_tripdata_2022-01.parquet'. Detail: [errno 2] No such file or directory", "end_timestamp": "1685088775", "engine_id": "spark123", "engine_name": "sparkdemo", "execute_config": {"driver_cores": 1, "driver_memory": "2G", "executor_cores": 1, "executor_memory": "2G", "num_executors": 1}, "instance_id": "1684432229673971", "job_id": "ingestion-1699459946935", "partition_by": "col1, col2", "schema": "{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}", "source_data_files": "s3://demobucket/data/yellow_tripdata_2022-01.parquet", "source_file_type": "csv", "start_timestamp": "1685084455", "status": "running", "target_table": "demodb.test.targettable", "username": "ibmlhadmin", "validate_csv_header": false}`)
				}))
			})
			It(`Invoke CreateIngestionJobs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateIngestionJobs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the IngestionJobPrototypeCsvProperty model
				ingestionJobPrototypeCsvPropertyModel := new(watsonxdatav2.IngestionJobPrototypeCsvProperty)
				ingestionJobPrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				ingestionJobPrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				ingestionJobPrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				ingestionJobPrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				ingestionJobPrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")

				// Construct an instance of the IngestionJobPrototypeExecuteConfig model
				ingestionJobPrototypeExecuteConfigModel := new(watsonxdatav2.IngestionJobPrototypeExecuteConfig)
				ingestionJobPrototypeExecuteConfigModel.DriverCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.DriverMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.ExecutorCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.ExecutorMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.NumExecutors = core.Int64Ptr(int64(1))

				// Construct an instance of the CreateIngestionJobsOptions model
				createIngestionJobsOptionsModel := new(watsonxdatav2.CreateIngestionJobsOptions)
				createIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIngestionJobsOptionsModel.JobID = core.StringPtr("ingestion-1699459946935")
				createIngestionJobsOptionsModel.SourceDataFiles = core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createIngestionJobsOptionsModel.TargetTable = core.StringPtr("demodb.test.targettable")
				createIngestionJobsOptionsModel.Username = core.StringPtr("user1")
				createIngestionJobsOptionsModel.CreateIfNotExist = core.BoolPtr(false)
				createIngestionJobsOptionsModel.CsvProperty = ingestionJobPrototypeCsvPropertyModel
				createIngestionJobsOptionsModel.EngineID = core.StringPtr("spark123")
				createIngestionJobsOptionsModel.ExecuteConfig = ingestionJobPrototypeExecuteConfigModel
				createIngestionJobsOptionsModel.PartitionBy = core.StringPtr("col1, col2")
				createIngestionJobsOptionsModel.Schema = core.StringPtr("{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}")
				createIngestionJobsOptionsModel.SourceFileType = core.StringPtr("csv")
				createIngestionJobsOptionsModel.ValidateCsvHeader = core.BoolPtr(false)
				createIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateIngestionJobs(createIngestionJobsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateIngestionJobs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the IngestionJobPrototypeCsvProperty model
				ingestionJobPrototypeCsvPropertyModel := new(watsonxdatav2.IngestionJobPrototypeCsvProperty)
				ingestionJobPrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				ingestionJobPrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				ingestionJobPrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				ingestionJobPrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				ingestionJobPrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")

				// Construct an instance of the IngestionJobPrototypeExecuteConfig model
				ingestionJobPrototypeExecuteConfigModel := new(watsonxdatav2.IngestionJobPrototypeExecuteConfig)
				ingestionJobPrototypeExecuteConfigModel.DriverCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.DriverMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.ExecutorCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.ExecutorMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.NumExecutors = core.Int64Ptr(int64(1))

				// Construct an instance of the CreateIngestionJobsOptions model
				createIngestionJobsOptionsModel := new(watsonxdatav2.CreateIngestionJobsOptions)
				createIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIngestionJobsOptionsModel.JobID = core.StringPtr("ingestion-1699459946935")
				createIngestionJobsOptionsModel.SourceDataFiles = core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createIngestionJobsOptionsModel.TargetTable = core.StringPtr("demodb.test.targettable")
				createIngestionJobsOptionsModel.Username = core.StringPtr("user1")
				createIngestionJobsOptionsModel.CreateIfNotExist = core.BoolPtr(false)
				createIngestionJobsOptionsModel.CsvProperty = ingestionJobPrototypeCsvPropertyModel
				createIngestionJobsOptionsModel.EngineID = core.StringPtr("spark123")
				createIngestionJobsOptionsModel.ExecuteConfig = ingestionJobPrototypeExecuteConfigModel
				createIngestionJobsOptionsModel.PartitionBy = core.StringPtr("col1, col2")
				createIngestionJobsOptionsModel.Schema = core.StringPtr("{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}")
				createIngestionJobsOptionsModel.SourceFileType = core.StringPtr("csv")
				createIngestionJobsOptionsModel.ValidateCsvHeader = core.BoolPtr(false)
				createIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateIngestionJobs(createIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateIngestionJobsOptions model with no property values
				createIngestionJobsOptionsModelNew := new(watsonxdatav2.CreateIngestionJobsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateIngestionJobs(createIngestionJobsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(202)
				}))
			})
			It(`Invoke CreateIngestionJobs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the IngestionJobPrototypeCsvProperty model
				ingestionJobPrototypeCsvPropertyModel := new(watsonxdatav2.IngestionJobPrototypeCsvProperty)
				ingestionJobPrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				ingestionJobPrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				ingestionJobPrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				ingestionJobPrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				ingestionJobPrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")

				// Construct an instance of the IngestionJobPrototypeExecuteConfig model
				ingestionJobPrototypeExecuteConfigModel := new(watsonxdatav2.IngestionJobPrototypeExecuteConfig)
				ingestionJobPrototypeExecuteConfigModel.DriverCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.DriverMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.ExecutorCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.ExecutorMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.NumExecutors = core.Int64Ptr(int64(1))

				// Construct an instance of the CreateIngestionJobsOptions model
				createIngestionJobsOptionsModel := new(watsonxdatav2.CreateIngestionJobsOptions)
				createIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIngestionJobsOptionsModel.JobID = core.StringPtr("ingestion-1699459946935")
				createIngestionJobsOptionsModel.SourceDataFiles = core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createIngestionJobsOptionsModel.TargetTable = core.StringPtr("demodb.test.targettable")
				createIngestionJobsOptionsModel.Username = core.StringPtr("user1")
				createIngestionJobsOptionsModel.CreateIfNotExist = core.BoolPtr(false)
				createIngestionJobsOptionsModel.CsvProperty = ingestionJobPrototypeCsvPropertyModel
				createIngestionJobsOptionsModel.EngineID = core.StringPtr("spark123")
				createIngestionJobsOptionsModel.ExecuteConfig = ingestionJobPrototypeExecuteConfigModel
				createIngestionJobsOptionsModel.PartitionBy = core.StringPtr("col1, col2")
				createIngestionJobsOptionsModel.Schema = core.StringPtr("{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}")
				createIngestionJobsOptionsModel.SourceFileType = core.StringPtr("csv")
				createIngestionJobsOptionsModel.ValidateCsvHeader = core.BoolPtr(false)
				createIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateIngestionJobs(createIngestionJobsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateIngestionJobsLocalFiles(createIngestionJobsLocalFilesOptions *CreateIngestionJobsLocalFilesOptions) - Operation response error`, func() {
		createIngestionJobsLocalFilesPath := "/ingestion_jobs_local_files"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createIngestionJobsLocalFilesPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateIngestionJobsLocalFiles with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateIngestionJobsLocalFilesOptions model
				createIngestionJobsLocalFilesOptionsModel := new(watsonxdatav2.CreateIngestionJobsLocalFilesOptions)
				createIngestionJobsLocalFilesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceDataFile = CreateMockReader("This is a mock file.")
				createIngestionJobsLocalFilesOptionsModel.TargetTable = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.JobID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.Username = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceDataFileContentType = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceFileType = core.StringPtr("csv")
				createIngestionJobsLocalFilesOptionsModel.CsvProperty = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.CreateIfNotExist = core.BoolPtr(false)
				createIngestionJobsLocalFilesOptionsModel.ValidateCsvHeader = core.BoolPtr(false)
				createIngestionJobsLocalFilesOptionsModel.ExecuteConfig = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.EngineID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateIngestionJobsLocalFiles(createIngestionJobsLocalFilesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateIngestionJobsLocalFiles(createIngestionJobsLocalFilesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateIngestionJobsLocalFiles(createIngestionJobsLocalFilesOptions *CreateIngestionJobsLocalFilesOptions)`, func() {
		createIngestionJobsLocalFilesPath := "/ingestion_jobs_local_files"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createIngestionJobsLocalFilesPath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"create_if_not_exist": false, "csv_property": {"encoding": "utf-8", "escape_character": "|", "field_delimiter": ",", "header": true, "line_delimiter": "\n"}, "details": "Path does not exist 'demobucket/data/yellow_tripdata_2022-01.parquet'. Detail: [errno 2] No such file or directory", "end_timestamp": "1685088775", "engine_id": "spark123", "engine_name": "sparkdemo", "execute_config": {"driver_cores": 1, "driver_memory": "2G", "executor_cores": 1, "executor_memory": "2G", "num_executors": 1}, "instance_id": "1684432229673971", "job_id": "ingestion-1699459946935", "partition_by": "col1, col2", "schema": "{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}", "source_data_files": "s3://demobucket/data/yellow_tripdata_2022-01.parquet", "source_file_type": "csv", "start_timestamp": "1685084455", "status": "running", "target_table": "demodb.test.targettable", "username": "ibmlhadmin", "validate_csv_header": false}`)
				}))
			})
			It(`Invoke CreateIngestionJobsLocalFiles successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreateIngestionJobsLocalFilesOptions model
				createIngestionJobsLocalFilesOptionsModel := new(watsonxdatav2.CreateIngestionJobsLocalFilesOptions)
				createIngestionJobsLocalFilesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceDataFile = CreateMockReader("This is a mock file.")
				createIngestionJobsLocalFilesOptionsModel.TargetTable = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.JobID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.Username = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceDataFileContentType = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceFileType = core.StringPtr("csv")
				createIngestionJobsLocalFilesOptionsModel.CsvProperty = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.CreateIfNotExist = core.BoolPtr(false)
				createIngestionJobsLocalFilesOptionsModel.ValidateCsvHeader = core.BoolPtr(false)
				createIngestionJobsLocalFilesOptionsModel.ExecuteConfig = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.EngineID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateIngestionJobsLocalFilesWithContext(ctx, createIngestionJobsLocalFilesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateIngestionJobsLocalFiles(createIngestionJobsLocalFilesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateIngestionJobsLocalFilesWithContext(ctx, createIngestionJobsLocalFilesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createIngestionJobsLocalFilesPath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"create_if_not_exist": false, "csv_property": {"encoding": "utf-8", "escape_character": "|", "field_delimiter": ",", "header": true, "line_delimiter": "\n"}, "details": "Path does not exist 'demobucket/data/yellow_tripdata_2022-01.parquet'. Detail: [errno 2] No such file or directory", "end_timestamp": "1685088775", "engine_id": "spark123", "engine_name": "sparkdemo", "execute_config": {"driver_cores": 1, "driver_memory": "2G", "executor_cores": 1, "executor_memory": "2G", "num_executors": 1}, "instance_id": "1684432229673971", "job_id": "ingestion-1699459946935", "partition_by": "col1, col2", "schema": "{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}", "source_data_files": "s3://demobucket/data/yellow_tripdata_2022-01.parquet", "source_file_type": "csv", "start_timestamp": "1685084455", "status": "running", "target_table": "demodb.test.targettable", "username": "ibmlhadmin", "validate_csv_header": false}`)
				}))
			})
			It(`Invoke CreateIngestionJobsLocalFiles successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateIngestionJobsLocalFiles(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreateIngestionJobsLocalFilesOptions model
				createIngestionJobsLocalFilesOptionsModel := new(watsonxdatav2.CreateIngestionJobsLocalFilesOptions)
				createIngestionJobsLocalFilesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceDataFile = CreateMockReader("This is a mock file.")
				createIngestionJobsLocalFilesOptionsModel.TargetTable = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.JobID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.Username = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceDataFileContentType = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceFileType = core.StringPtr("csv")
				createIngestionJobsLocalFilesOptionsModel.CsvProperty = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.CreateIfNotExist = core.BoolPtr(false)
				createIngestionJobsLocalFilesOptionsModel.ValidateCsvHeader = core.BoolPtr(false)
				createIngestionJobsLocalFilesOptionsModel.ExecuteConfig = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.EngineID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateIngestionJobsLocalFiles(createIngestionJobsLocalFilesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateIngestionJobsLocalFiles with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateIngestionJobsLocalFilesOptions model
				createIngestionJobsLocalFilesOptionsModel := new(watsonxdatav2.CreateIngestionJobsLocalFilesOptions)
				createIngestionJobsLocalFilesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceDataFile = CreateMockReader("This is a mock file.")
				createIngestionJobsLocalFilesOptionsModel.TargetTable = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.JobID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.Username = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceDataFileContentType = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceFileType = core.StringPtr("csv")
				createIngestionJobsLocalFilesOptionsModel.CsvProperty = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.CreateIfNotExist = core.BoolPtr(false)
				createIngestionJobsLocalFilesOptionsModel.ValidateCsvHeader = core.BoolPtr(false)
				createIngestionJobsLocalFilesOptionsModel.ExecuteConfig = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.EngineID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateIngestionJobsLocalFiles(createIngestionJobsLocalFilesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateIngestionJobsLocalFilesOptions model with no property values
				createIngestionJobsLocalFilesOptionsModelNew := new(watsonxdatav2.CreateIngestionJobsLocalFilesOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateIngestionJobsLocalFiles(createIngestionJobsLocalFilesOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(202)
				}))
			})
			It(`Invoke CreateIngestionJobsLocalFiles successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateIngestionJobsLocalFilesOptions model
				createIngestionJobsLocalFilesOptionsModel := new(watsonxdatav2.CreateIngestionJobsLocalFilesOptions)
				createIngestionJobsLocalFilesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceDataFile = CreateMockReader("This is a mock file.")
				createIngestionJobsLocalFilesOptionsModel.TargetTable = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.JobID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.Username = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceDataFileContentType = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceFileType = core.StringPtr("csv")
				createIngestionJobsLocalFilesOptionsModel.CsvProperty = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.CreateIfNotExist = core.BoolPtr(false)
				createIngestionJobsLocalFilesOptionsModel.ValidateCsvHeader = core.BoolPtr(false)
				createIngestionJobsLocalFilesOptionsModel.ExecuteConfig = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.EngineID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateIngestionJobsLocalFiles(createIngestionJobsLocalFilesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetIngestionJob(getIngestionJobOptions *GetIngestionJobOptions) - Operation response error`, func() {
		getIngestionJobPath := "/ingestion_jobs/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getIngestionJobPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetIngestionJob with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetIngestionJobOptions model
				getIngestionJobOptionsModel := new(watsonxdatav2.GetIngestionJobOptions)
				getIngestionJobOptionsModel.JobID = core.StringPtr("testString")
				getIngestionJobOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getIngestionJobOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetIngestionJob(getIngestionJobOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetIngestionJob(getIngestionJobOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetIngestionJob(getIngestionJobOptions *GetIngestionJobOptions)`, func() {
		getIngestionJobPath := "/ingestion_jobs/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getIngestionJobPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"create_if_not_exist": false, "csv_property": {"encoding": "utf-8", "escape_character": "|", "field_delimiter": ",", "header": true, "line_delimiter": "\n"}, "details": "Path does not exist 'demobucket/data/yellow_tripdata_2022-01.parquet'. Detail: [errno 2] No such file or directory", "end_timestamp": "1685088775", "engine_id": "spark123", "engine_name": "sparkdemo", "execute_config": {"driver_cores": 1, "driver_memory": "2G", "executor_cores": 1, "executor_memory": "2G", "num_executors": 1}, "instance_id": "1684432229673971", "job_id": "ingestion-1699459946935", "partition_by": "col1, col2", "schema": "{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}", "source_data_files": "s3://demobucket/data/yellow_tripdata_2022-01.parquet", "source_file_type": "csv", "start_timestamp": "1685084455", "status": "running", "target_table": "demodb.test.targettable", "username": "ibmlhadmin", "validate_csv_header": false}`)
				}))
			})
			It(`Invoke GetIngestionJob successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetIngestionJobOptions model
				getIngestionJobOptionsModel := new(watsonxdatav2.GetIngestionJobOptions)
				getIngestionJobOptionsModel.JobID = core.StringPtr("testString")
				getIngestionJobOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getIngestionJobOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetIngestionJobWithContext(ctx, getIngestionJobOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetIngestionJob(getIngestionJobOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetIngestionJobWithContext(ctx, getIngestionJobOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getIngestionJobPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"create_if_not_exist": false, "csv_property": {"encoding": "utf-8", "escape_character": "|", "field_delimiter": ",", "header": true, "line_delimiter": "\n"}, "details": "Path does not exist 'demobucket/data/yellow_tripdata_2022-01.parquet'. Detail: [errno 2] No such file or directory", "end_timestamp": "1685088775", "engine_id": "spark123", "engine_name": "sparkdemo", "execute_config": {"driver_cores": 1, "driver_memory": "2G", "executor_cores": 1, "executor_memory": "2G", "num_executors": 1}, "instance_id": "1684432229673971", "job_id": "ingestion-1699459946935", "partition_by": "col1, col2", "schema": "{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}", "source_data_files": "s3://demobucket/data/yellow_tripdata_2022-01.parquet", "source_file_type": "csv", "start_timestamp": "1685084455", "status": "running", "target_table": "demodb.test.targettable", "username": "ibmlhadmin", "validate_csv_header": false}`)
				}))
			})
			It(`Invoke GetIngestionJob successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetIngestionJob(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetIngestionJobOptions model
				getIngestionJobOptionsModel := new(watsonxdatav2.GetIngestionJobOptions)
				getIngestionJobOptionsModel.JobID = core.StringPtr("testString")
				getIngestionJobOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getIngestionJobOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetIngestionJob(getIngestionJobOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetIngestionJob with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetIngestionJobOptions model
				getIngestionJobOptionsModel := new(watsonxdatav2.GetIngestionJobOptions)
				getIngestionJobOptionsModel.JobID = core.StringPtr("testString")
				getIngestionJobOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getIngestionJobOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetIngestionJob(getIngestionJobOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetIngestionJobOptions model with no property values
				getIngestionJobOptionsModelNew := new(watsonxdatav2.GetIngestionJobOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetIngestionJob(getIngestionJobOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetIngestionJob successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetIngestionJobOptions model
				getIngestionJobOptionsModel := new(watsonxdatav2.GetIngestionJobOptions)
				getIngestionJobOptionsModel.JobID = core.StringPtr("testString")
				getIngestionJobOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getIngestionJobOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetIngestionJob(getIngestionJobOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteIngestionJobs(deleteIngestionJobsOptions *DeleteIngestionJobsOptions)`, func() {
		deleteIngestionJobsPath := "/ingestion_jobs/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteIngestionJobsPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteIngestionJobs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteIngestionJobs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteIngestionJobsOptions model
				deleteIngestionJobsOptionsModel := new(watsonxdatav2.DeleteIngestionJobsOptions)
				deleteIngestionJobsOptionsModel.JobID = core.StringPtr("testString")
				deleteIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteIngestionJobs(deleteIngestionJobsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteIngestionJobs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteIngestionJobsOptions model
				deleteIngestionJobsOptionsModel := new(watsonxdatav2.DeleteIngestionJobsOptions)
				deleteIngestionJobsOptionsModel.JobID = core.StringPtr("testString")
				deleteIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteIngestionJobs(deleteIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteIngestionJobsOptions model with no property values
				deleteIngestionJobsOptionsModelNew := new(watsonxdatav2.DeleteIngestionJobsOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteIngestionJobs(deleteIngestionJobsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreatePreviewIngestionFile(createPreviewIngestionFileOptions *CreatePreviewIngestionFileOptions) - Operation response error`, func() {
		createPreviewIngestionFilePath := "/preview_ingestion_file"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPreviewIngestionFilePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreatePreviewIngestionFile with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PreviewIngestionFilePrototypeCsvProperty model
				previewIngestionFilePrototypeCsvPropertyModel := new(watsonxdatav2.PreviewIngestionFilePrototypeCsvProperty)
				previewIngestionFilePrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				previewIngestionFilePrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				previewIngestionFilePrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				previewIngestionFilePrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				previewIngestionFilePrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")

				// Construct an instance of the CreatePreviewIngestionFileOptions model
				createPreviewIngestionFileOptionsModel := new(watsonxdatav2.CreatePreviewIngestionFileOptions)
				createPreviewIngestionFileOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPreviewIngestionFileOptionsModel.SourceDataFiles = core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createPreviewIngestionFileOptionsModel.CsvProperty = previewIngestionFilePrototypeCsvPropertyModel
				createPreviewIngestionFileOptionsModel.SourceFileType = core.StringPtr("csv")
				createPreviewIngestionFileOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreatePreviewIngestionFile(createPreviewIngestionFileOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreatePreviewIngestionFile(createPreviewIngestionFileOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreatePreviewIngestionFile(createPreviewIngestionFileOptions *CreatePreviewIngestionFileOptions)`, func() {
		createPreviewIngestionFilePath := "/preview_ingestion_file"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPreviewIngestionFilePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"column_names": ["col1"], "column_types": ["int"], "file_name": "s3://demobucket/data/yellow_tripdata_2022-01.parquet", "rows": {"row_eight": ["Jane Doe"], "row_five": ["Jane Doe"], "row_four": ["Jane Doe"], "row_nine": ["Jane Doe"], "row_one": ["Jane Doe"], "row_seven": ["Jane Doe"], "row_six": ["Jane Doe"], "row_ten": ["Jane Doe"], "row_three": ["Jane Doe"], "row_two": ["Jane Doe"]}}`)
				}))
			})
			It(`Invoke CreatePreviewIngestionFile successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the PreviewIngestionFilePrototypeCsvProperty model
				previewIngestionFilePrototypeCsvPropertyModel := new(watsonxdatav2.PreviewIngestionFilePrototypeCsvProperty)
				previewIngestionFilePrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				previewIngestionFilePrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				previewIngestionFilePrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				previewIngestionFilePrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				previewIngestionFilePrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")

				// Construct an instance of the CreatePreviewIngestionFileOptions model
				createPreviewIngestionFileOptionsModel := new(watsonxdatav2.CreatePreviewIngestionFileOptions)
				createPreviewIngestionFileOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPreviewIngestionFileOptionsModel.SourceDataFiles = core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createPreviewIngestionFileOptionsModel.CsvProperty = previewIngestionFilePrototypeCsvPropertyModel
				createPreviewIngestionFileOptionsModel.SourceFileType = core.StringPtr("csv")
				createPreviewIngestionFileOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreatePreviewIngestionFileWithContext(ctx, createPreviewIngestionFileOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreatePreviewIngestionFile(createPreviewIngestionFileOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreatePreviewIngestionFileWithContext(ctx, createPreviewIngestionFileOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPreviewIngestionFilePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"column_names": ["col1"], "column_types": ["int"], "file_name": "s3://demobucket/data/yellow_tripdata_2022-01.parquet", "rows": {"row_eight": ["Jane Doe"], "row_five": ["Jane Doe"], "row_four": ["Jane Doe"], "row_nine": ["Jane Doe"], "row_one": ["Jane Doe"], "row_seven": ["Jane Doe"], "row_six": ["Jane Doe"], "row_ten": ["Jane Doe"], "row_three": ["Jane Doe"], "row_two": ["Jane Doe"]}}`)
				}))
			})
			It(`Invoke CreatePreviewIngestionFile successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreatePreviewIngestionFile(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the PreviewIngestionFilePrototypeCsvProperty model
				previewIngestionFilePrototypeCsvPropertyModel := new(watsonxdatav2.PreviewIngestionFilePrototypeCsvProperty)
				previewIngestionFilePrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				previewIngestionFilePrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				previewIngestionFilePrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				previewIngestionFilePrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				previewIngestionFilePrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")

				// Construct an instance of the CreatePreviewIngestionFileOptions model
				createPreviewIngestionFileOptionsModel := new(watsonxdatav2.CreatePreviewIngestionFileOptions)
				createPreviewIngestionFileOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPreviewIngestionFileOptionsModel.SourceDataFiles = core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createPreviewIngestionFileOptionsModel.CsvProperty = previewIngestionFilePrototypeCsvPropertyModel
				createPreviewIngestionFileOptionsModel.SourceFileType = core.StringPtr("csv")
				createPreviewIngestionFileOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreatePreviewIngestionFile(createPreviewIngestionFileOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreatePreviewIngestionFile with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PreviewIngestionFilePrototypeCsvProperty model
				previewIngestionFilePrototypeCsvPropertyModel := new(watsonxdatav2.PreviewIngestionFilePrototypeCsvProperty)
				previewIngestionFilePrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				previewIngestionFilePrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				previewIngestionFilePrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				previewIngestionFilePrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				previewIngestionFilePrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")

				// Construct an instance of the CreatePreviewIngestionFileOptions model
				createPreviewIngestionFileOptionsModel := new(watsonxdatav2.CreatePreviewIngestionFileOptions)
				createPreviewIngestionFileOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPreviewIngestionFileOptionsModel.SourceDataFiles = core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createPreviewIngestionFileOptionsModel.CsvProperty = previewIngestionFilePrototypeCsvPropertyModel
				createPreviewIngestionFileOptionsModel.SourceFileType = core.StringPtr("csv")
				createPreviewIngestionFileOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreatePreviewIngestionFile(createPreviewIngestionFileOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreatePreviewIngestionFileOptions model with no property values
				createPreviewIngestionFileOptionsModelNew := new(watsonxdatav2.CreatePreviewIngestionFileOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreatePreviewIngestionFile(createPreviewIngestionFileOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreatePreviewIngestionFile successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PreviewIngestionFilePrototypeCsvProperty model
				previewIngestionFilePrototypeCsvPropertyModel := new(watsonxdatav2.PreviewIngestionFilePrototypeCsvProperty)
				previewIngestionFilePrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				previewIngestionFilePrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				previewIngestionFilePrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				previewIngestionFilePrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				previewIngestionFilePrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")

				// Construct an instance of the CreatePreviewIngestionFileOptions model
				createPreviewIngestionFileOptionsModel := new(watsonxdatav2.CreatePreviewIngestionFileOptions)
				createPreviewIngestionFileOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPreviewIngestionFileOptionsModel.SourceDataFiles = core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createPreviewIngestionFileOptionsModel.CsvProperty = previewIngestionFilePrototypeCsvPropertyModel
				createPreviewIngestionFileOptionsModel.SourceFileType = core.StringPtr("csv")
				createPreviewIngestionFileOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreatePreviewIngestionFile(createPreviewIngestionFileOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetEndpoints(getEndpointsOptions *GetEndpointsOptions) - Operation response error`, func() {
		getEndpointsPath := "/endpoints"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getEndpointsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetEndpoints with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetEndpointsOptions model
				getEndpointsOptionsModel := new(watsonxdatav2.GetEndpointsOptions)
				getEndpointsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getEndpointsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetEndpoints(getEndpointsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetEndpoints(getEndpointsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetEndpoints(getEndpointsOptions *GetEndpointsOptions)`, func() {
		getEndpointsPath := "/endpoints"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getEndpointsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"endpoints": [{"external_host": "https://cpg-svc.your-hostname.apps.your-domain.com", "service_type": "cpg"}]}`)
				}))
			})
			It(`Invoke GetEndpoints successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetEndpointsOptions model
				getEndpointsOptionsModel := new(watsonxdatav2.GetEndpointsOptions)
				getEndpointsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getEndpointsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetEndpointsWithContext(ctx, getEndpointsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetEndpoints(getEndpointsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetEndpointsWithContext(ctx, getEndpointsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getEndpointsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"endpoints": [{"external_host": "https://cpg-svc.your-hostname.apps.your-domain.com", "service_type": "cpg"}]}`)
				}))
			})
			It(`Invoke GetEndpoints successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetEndpoints(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetEndpointsOptions model
				getEndpointsOptionsModel := new(watsonxdatav2.GetEndpointsOptions)
				getEndpointsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getEndpointsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetEndpoints(getEndpointsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetEndpoints with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetEndpointsOptions model
				getEndpointsOptionsModel := new(watsonxdatav2.GetEndpointsOptions)
				getEndpointsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getEndpointsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetEndpoints(getEndpointsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetEndpoints successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetEndpointsOptions model
				getEndpointsOptionsModel := new(watsonxdatav2.GetEndpointsOptions)
				getEndpointsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getEndpointsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetEndpoints(getEndpointsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetAllColumns(getAllColumnsOptions *GetAllColumnsOptions) - Operation response error`, func() {
		getAllColumnsPath := "/columns"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getAllColumnsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["table_name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["catalog_name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["schema_name"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetAllColumns with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetAllColumnsOptions model
				getAllColumnsOptionsModel := new(watsonxdatav2.GetAllColumnsOptions)
				getAllColumnsOptionsModel.TableName = core.StringPtr("testString")
				getAllColumnsOptionsModel.CatalogName = core.StringPtr("testString")
				getAllColumnsOptionsModel.SchemaName = core.StringPtr("testString")
				getAllColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getAllColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetAllColumns(getAllColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetAllColumns(getAllColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetAllColumns(getAllColumnsOptions *GetAllColumnsOptions)`, func() {
		getAllColumnsPath := "/columns"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getAllColumnsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["table_name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["catalog_name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["schema_name"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"columns": [{"bucket": "Bucket", "catalog": "Catalog", "columns": [{"column": "Column", "index": 5, "type": "Type"}], "owner": "Owner", "schema": "Schema", "table": "Table"}], "message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke GetAllColumns successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetAllColumnsOptions model
				getAllColumnsOptionsModel := new(watsonxdatav2.GetAllColumnsOptions)
				getAllColumnsOptionsModel.TableName = core.StringPtr("testString")
				getAllColumnsOptionsModel.CatalogName = core.StringPtr("testString")
				getAllColumnsOptionsModel.SchemaName = core.StringPtr("testString")
				getAllColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getAllColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetAllColumnsWithContext(ctx, getAllColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetAllColumns(getAllColumnsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetAllColumnsWithContext(ctx, getAllColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getAllColumnsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["table_name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["catalog_name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["schema_name"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"columns": [{"bucket": "Bucket", "catalog": "Catalog", "columns": [{"column": "Column", "index": 5, "type": "Type"}], "owner": "Owner", "schema": "Schema", "table": "Table"}], "message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke GetAllColumns successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetAllColumns(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetAllColumnsOptions model
				getAllColumnsOptionsModel := new(watsonxdatav2.GetAllColumnsOptions)
				getAllColumnsOptionsModel.TableName = core.StringPtr("testString")
				getAllColumnsOptionsModel.CatalogName = core.StringPtr("testString")
				getAllColumnsOptionsModel.SchemaName = core.StringPtr("testString")
				getAllColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getAllColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetAllColumns(getAllColumnsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetAllColumns with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetAllColumnsOptions model
				getAllColumnsOptionsModel := new(watsonxdatav2.GetAllColumnsOptions)
				getAllColumnsOptionsModel.TableName = core.StringPtr("testString")
				getAllColumnsOptionsModel.CatalogName = core.StringPtr("testString")
				getAllColumnsOptionsModel.SchemaName = core.StringPtr("testString")
				getAllColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getAllColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetAllColumns(getAllColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetAllColumns successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetAllColumnsOptions model
				getAllColumnsOptionsModel := new(watsonxdatav2.GetAllColumnsOptions)
				getAllColumnsOptionsModel.TableName = core.StringPtr("testString")
				getAllColumnsOptionsModel.CatalogName = core.StringPtr("testString")
				getAllColumnsOptionsModel.SchemaName = core.StringPtr("testString")
				getAllColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getAllColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetAllColumns(getAllColumnsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListAllSchemas(listAllSchemasOptions *ListAllSchemasOptions) - Operation response error`, func() {
		listAllSchemasPath := "/schemas"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listAllSchemasPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["catalog_name"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListAllSchemas with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListAllSchemasOptions model
				listAllSchemasOptionsModel := new(watsonxdatav2.ListAllSchemasOptions)
				listAllSchemasOptionsModel.CatalogName = core.StringPtr("testString")
				listAllSchemasOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listAllSchemasOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListAllSchemas(listAllSchemasOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListAllSchemas(listAllSchemasOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListAllSchemas(listAllSchemasOptions *ListAllSchemasOptions)`, func() {
		listAllSchemasPath := "/schemas"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listAllSchemasPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["catalog_name"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode", "schemas": [{"bucket": "Bucket", "catalog": "Catalog", "owner": "Owner", "schema_name": "SchemaName"}]}`)
				}))
			})
			It(`Invoke ListAllSchemas successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListAllSchemasOptions model
				listAllSchemasOptionsModel := new(watsonxdatav2.ListAllSchemasOptions)
				listAllSchemasOptionsModel.CatalogName = core.StringPtr("testString")
				listAllSchemasOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listAllSchemasOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListAllSchemasWithContext(ctx, listAllSchemasOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListAllSchemas(listAllSchemasOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListAllSchemasWithContext(ctx, listAllSchemasOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listAllSchemasPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["catalog_name"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode", "schemas": [{"bucket": "Bucket", "catalog": "Catalog", "owner": "Owner", "schema_name": "SchemaName"}]}`)
				}))
			})
			It(`Invoke ListAllSchemas successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListAllSchemas(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListAllSchemasOptions model
				listAllSchemasOptionsModel := new(watsonxdatav2.ListAllSchemasOptions)
				listAllSchemasOptionsModel.CatalogName = core.StringPtr("testString")
				listAllSchemasOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listAllSchemasOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListAllSchemas(listAllSchemasOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListAllSchemas with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListAllSchemasOptions model
				listAllSchemasOptionsModel := new(watsonxdatav2.ListAllSchemasOptions)
				listAllSchemasOptionsModel.CatalogName = core.StringPtr("testString")
				listAllSchemasOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listAllSchemasOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListAllSchemas(listAllSchemasOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListAllSchemas successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListAllSchemasOptions model
				listAllSchemasOptionsModel := new(watsonxdatav2.ListAllSchemasOptions)
				listAllSchemasOptionsModel.CatalogName = core.StringPtr("testString")
				listAllSchemasOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listAllSchemasOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListAllSchemas(listAllSchemasOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSchemaDetails(getSchemaDetailsOptions *GetSchemaDetailsOptions) - Operation response error`, func() {
		getSchemaDetailsPath := "/schemas/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSchemaDetailsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["catalog_name"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetSchemaDetails with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSchemaDetailsOptions model
				getSchemaDetailsOptionsModel := new(watsonxdatav2.GetSchemaDetailsOptions)
				getSchemaDetailsOptionsModel.SchemaName = core.StringPtr("testString")
				getSchemaDetailsOptionsModel.CatalogName = core.StringPtr("testString")
				getSchemaDetailsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSchemaDetailsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetSchemaDetails(getSchemaDetailsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetSchemaDetails(getSchemaDetailsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSchemaDetails(getSchemaDetailsOptions *GetSchemaDetailsOptions)`, func() {
		getSchemaDetailsPath := "/schemas/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSchemaDetailsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["catalog_name"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"bucket": "Bucket", "catalog": "Catalog", "message": "Message", "message_code": "MessageCode", "owner": "Owner", "schema": {"bucket": "Bucket", "catalog": "Catalog", "owner": "Owner", "schema_name": "SchemaName"}, "schema_name": "SchemaName"}`)
				}))
			})
			It(`Invoke GetSchemaDetails successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetSchemaDetailsOptions model
				getSchemaDetailsOptionsModel := new(watsonxdatav2.GetSchemaDetailsOptions)
				getSchemaDetailsOptionsModel.SchemaName = core.StringPtr("testString")
				getSchemaDetailsOptionsModel.CatalogName = core.StringPtr("testString")
				getSchemaDetailsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSchemaDetailsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetSchemaDetailsWithContext(ctx, getSchemaDetailsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetSchemaDetails(getSchemaDetailsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetSchemaDetailsWithContext(ctx, getSchemaDetailsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSchemaDetailsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["catalog_name"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"bucket": "Bucket", "catalog": "Catalog", "message": "Message", "message_code": "MessageCode", "owner": "Owner", "schema": {"bucket": "Bucket", "catalog": "Catalog", "owner": "Owner", "schema_name": "SchemaName"}, "schema_name": "SchemaName"}`)
				}))
			})
			It(`Invoke GetSchemaDetails successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetSchemaDetails(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSchemaDetailsOptions model
				getSchemaDetailsOptionsModel := new(watsonxdatav2.GetSchemaDetailsOptions)
				getSchemaDetailsOptionsModel.SchemaName = core.StringPtr("testString")
				getSchemaDetailsOptionsModel.CatalogName = core.StringPtr("testString")
				getSchemaDetailsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSchemaDetailsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetSchemaDetails(getSchemaDetailsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetSchemaDetails with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSchemaDetailsOptions model
				getSchemaDetailsOptionsModel := new(watsonxdatav2.GetSchemaDetailsOptions)
				getSchemaDetailsOptionsModel.SchemaName = core.StringPtr("testString")
				getSchemaDetailsOptionsModel.CatalogName = core.StringPtr("testString")
				getSchemaDetailsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSchemaDetailsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetSchemaDetails(getSchemaDetailsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetSchemaDetailsOptions model with no property values
				getSchemaDetailsOptionsModelNew := new(watsonxdatav2.GetSchemaDetailsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetSchemaDetails(getSchemaDetailsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetSchemaDetails successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSchemaDetailsOptions model
				getSchemaDetailsOptionsModel := new(watsonxdatav2.GetSchemaDetailsOptions)
				getSchemaDetailsOptionsModel.SchemaName = core.StringPtr("testString")
				getSchemaDetailsOptionsModel.CatalogName = core.StringPtr("testString")
				getSchemaDetailsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSchemaDetailsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetSchemaDetails(getSchemaDetailsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListAllTables(listAllTablesOptions *ListAllTablesOptions) - Operation response error`, func() {
		listAllTablesPath := "/tables"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listAllTablesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["catalog_name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["schema_name"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListAllTables with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListAllTablesOptions model
				listAllTablesOptionsModel := new(watsonxdatav2.ListAllTablesOptions)
				listAllTablesOptionsModel.CatalogName = core.StringPtr("testString")
				listAllTablesOptionsModel.SchemaName = core.StringPtr("testString")
				listAllTablesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listAllTablesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListAllTables(listAllTablesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListAllTables(listAllTablesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListAllTables(listAllTablesOptions *ListAllTablesOptions)`, func() {
		listAllTablesPath := "/tables"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listAllTablesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["catalog_name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["schema_name"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode", "tables": [{"message": "Message", "message_code": "MessageCode", "tables": [{"bucket": "Bucket", "catalog": "Catalog", "columns": [{"column": "Column", "index": 5, "type": "Type"}], "owner": "Owner", "schema": "Schema", "table": "Table"}]}]}`)
				}))
			})
			It(`Invoke ListAllTables successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListAllTablesOptions model
				listAllTablesOptionsModel := new(watsonxdatav2.ListAllTablesOptions)
				listAllTablesOptionsModel.CatalogName = core.StringPtr("testString")
				listAllTablesOptionsModel.SchemaName = core.StringPtr("testString")
				listAllTablesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listAllTablesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListAllTablesWithContext(ctx, listAllTablesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListAllTables(listAllTablesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListAllTablesWithContext(ctx, listAllTablesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listAllTablesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["catalog_name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["schema_name"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode", "tables": [{"message": "Message", "message_code": "MessageCode", "tables": [{"bucket": "Bucket", "catalog": "Catalog", "columns": [{"column": "Column", "index": 5, "type": "Type"}], "owner": "Owner", "schema": "Schema", "table": "Table"}]}]}`)
				}))
			})
			It(`Invoke ListAllTables successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListAllTables(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListAllTablesOptions model
				listAllTablesOptionsModel := new(watsonxdatav2.ListAllTablesOptions)
				listAllTablesOptionsModel.CatalogName = core.StringPtr("testString")
				listAllTablesOptionsModel.SchemaName = core.StringPtr("testString")
				listAllTablesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listAllTablesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListAllTables(listAllTablesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListAllTables with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListAllTablesOptions model
				listAllTablesOptionsModel := new(watsonxdatav2.ListAllTablesOptions)
				listAllTablesOptionsModel.CatalogName = core.StringPtr("testString")
				listAllTablesOptionsModel.SchemaName = core.StringPtr("testString")
				listAllTablesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listAllTablesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListAllTables(listAllTablesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListAllTables successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListAllTablesOptions model
				listAllTablesOptionsModel := new(watsonxdatav2.ListAllTablesOptions)
				listAllTablesOptionsModel.CatalogName = core.StringPtr("testString")
				listAllTablesOptionsModel.SchemaName = core.StringPtr("testString")
				listAllTablesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listAllTablesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListAllTables(listAllTablesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetTableDetails(getTableDetailsOptions *GetTableDetailsOptions) - Operation response error`, func() {
		getTableDetailsPath := "/tables/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getTableDetailsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["catalog_name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["schema_name"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetTableDetails with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetTableDetailsOptions model
				getTableDetailsOptionsModel := new(watsonxdatav2.GetTableDetailsOptions)
				getTableDetailsOptionsModel.TableName = core.StringPtr("testString")
				getTableDetailsOptionsModel.CatalogName = core.StringPtr("testString")
				getTableDetailsOptionsModel.SchemaName = core.StringPtr("testString")
				getTableDetailsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getTableDetailsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetTableDetails(getTableDetailsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetTableDetails(getTableDetailsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetTableDetails(getTableDetailsOptions *GetTableDetailsOptions)`, func() {
		getTableDetailsPath := "/tables/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getTableDetailsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["catalog_name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["schema_name"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode", "tables": [{"bucket": "Bucket", "catalog": "Catalog", "columns": [{"column": "Column", "index": 5, "type": "Type"}], "owner": "Owner", "schema": "Schema", "table": "Table"}]}`)
				}))
			})
			It(`Invoke GetTableDetails successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetTableDetailsOptions model
				getTableDetailsOptionsModel := new(watsonxdatav2.GetTableDetailsOptions)
				getTableDetailsOptionsModel.TableName = core.StringPtr("testString")
				getTableDetailsOptionsModel.CatalogName = core.StringPtr("testString")
				getTableDetailsOptionsModel.SchemaName = core.StringPtr("testString")
				getTableDetailsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getTableDetailsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetTableDetailsWithContext(ctx, getTableDetailsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetTableDetails(getTableDetailsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetTableDetailsWithContext(ctx, getTableDetailsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getTableDetailsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["catalog_name"]).To(Equal([]string{"testString"}))
					Expect(req.URL.Query()["schema_name"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode", "tables": [{"bucket": "Bucket", "catalog": "Catalog", "columns": [{"column": "Column", "index": 5, "type": "Type"}], "owner": "Owner", "schema": "Schema", "table": "Table"}]}`)
				}))
			})
			It(`Invoke GetTableDetails successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetTableDetails(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetTableDetailsOptions model
				getTableDetailsOptionsModel := new(watsonxdatav2.GetTableDetailsOptions)
				getTableDetailsOptionsModel.TableName = core.StringPtr("testString")
				getTableDetailsOptionsModel.CatalogName = core.StringPtr("testString")
				getTableDetailsOptionsModel.SchemaName = core.StringPtr("testString")
				getTableDetailsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getTableDetailsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetTableDetails(getTableDetailsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetTableDetails with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetTableDetailsOptions model
				getTableDetailsOptionsModel := new(watsonxdatav2.GetTableDetailsOptions)
				getTableDetailsOptionsModel.TableName = core.StringPtr("testString")
				getTableDetailsOptionsModel.CatalogName = core.StringPtr("testString")
				getTableDetailsOptionsModel.SchemaName = core.StringPtr("testString")
				getTableDetailsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getTableDetailsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetTableDetails(getTableDetailsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetTableDetailsOptions model with no property values
				getTableDetailsOptionsModelNew := new(watsonxdatav2.GetTableDetailsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetTableDetails(getTableDetailsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetTableDetails successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetTableDetailsOptions model
				getTableDetailsOptionsModel := new(watsonxdatav2.GetTableDetailsOptions)
				getTableDetailsOptionsModel.TableName = core.StringPtr("testString")
				getTableDetailsOptionsModel.CatalogName = core.StringPtr("testString")
				getTableDetailsOptionsModel.SchemaName = core.StringPtr("testString")
				getTableDetailsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getTableDetailsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetTableDetails(getTableDetailsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`Model constructor tests`, func() {
		Context(`Using a service client instance`, func() {
			watsonxDataService, _ := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
				URL:           "http://watsonxdatav2modelgenerator.com",
				Authenticator: &core.NoAuthAuthenticator{},
			})
			It(`Invoke NewBucketDetails successfully`, func() {
				bucketName := "sample-bucket"
				_model, err := watsonxDataService.NewBucketDetails(bucketName)
				Expect(_model).ToNot(BeNil())
				Expect(err).To(BeNil())
			})
			It(`Invoke NewCreateActivateBucketOptions successfully`, func() {
				// Construct an instance of the CreateActivateBucketOptions model
				bucketID := "testString"
				createActivateBucketOptionsModel := watsonxDataService.NewCreateActivateBucketOptions(bucketID)
				createActivateBucketOptionsModel.SetBucketID("testString")
				createActivateBucketOptionsModel.SetAuthInstanceID("testString")
				createActivateBucketOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createActivateBucketOptionsModel).ToNot(BeNil())
				Expect(createActivateBucketOptionsModel.BucketID).To(Equal(core.StringPtr("testString")))
				Expect(createActivateBucketOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createActivateBucketOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateBucketRegistrationOptions successfully`, func() {
				// Construct an instance of the BucketCatalog model
				bucketCatalogModel := new(watsonxdatav2.BucketCatalog)
				Expect(bucketCatalogModel).ToNot(BeNil())
				bucketCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				bucketCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				bucketCatalogModel.CatalogType = core.StringPtr("iceberg")
				Expect(bucketCatalogModel.CatalogName).To(Equal(core.StringPtr("sampleCatalog")))
				Expect(bucketCatalogModel.CatalogTags).To(Equal([]string{"catalog_tag_1", "catalog_tag_2"}))
				Expect(bucketCatalogModel.CatalogType).To(Equal(core.StringPtr("iceberg")))

				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				Expect(bucketDetailsModel).ToNot(BeNil())
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.KeyFile = core.StringPtr("key_file")
				bucketDetailsModel.Provider = core.StringPtr("ibm_cos")
				bucketDetailsModel.Region = core.StringPtr("us-south")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")
				Expect(bucketDetailsModel.AccessKey).To(Equal(core.StringPtr("b9cbf248ea5c4c96947e64407108559j")))
				Expect(bucketDetailsModel.BucketName).To(Equal(core.StringPtr("sample-bucket")))
				Expect(bucketDetailsModel.Endpoint).To(Equal(core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")))
				Expect(bucketDetailsModel.KeyFile).To(Equal(core.StringPtr("key_file")))
				Expect(bucketDetailsModel.Provider).To(Equal(core.StringPtr("ibm_cos")))
				Expect(bucketDetailsModel.Region).To(Equal(core.StringPtr("us-south")))
				Expect(bucketDetailsModel.SecretKey).To(Equal(core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")))

				// Construct an instance of the StorageDetails model
				storageDetailsModel := new(watsonxdatav2.StorageDetails)
				Expect(storageDetailsModel).ToNot(BeNil())
				storageDetailsModel.AccessKey = core.StringPtr("<access_key>")
				storageDetailsModel.ApplicationID = core.StringPtr("<application_id>")
				storageDetailsModel.AuthMode = core.StringPtr("<account_key/sas/service_principle>")
				storageDetailsModel.ContainerName = core.StringPtr("sample-container")
				storageDetailsModel.DirectoryID = core.StringPtr("<directory_id>")
				storageDetailsModel.Endpoint = core.StringPtr("abfss://<container_name>@<storage_account_name>.dfs.core.windows.net/")
				storageDetailsModel.SasToken = core.StringPtr("<sas_token>")
				storageDetailsModel.SecretKey = core.StringPtr("secret_key")
				storageDetailsModel.StorageAccountName = core.StringPtr("sample-storage")
				Expect(storageDetailsModel.AccessKey).To(Equal(core.StringPtr("<access_key>")))
				Expect(storageDetailsModel.ApplicationID).To(Equal(core.StringPtr("<application_id>")))
				Expect(storageDetailsModel.AuthMode).To(Equal(core.StringPtr("<account_key/sas/service_principle>")))
				Expect(storageDetailsModel.ContainerName).To(Equal(core.StringPtr("sample-container")))
				Expect(storageDetailsModel.DirectoryID).To(Equal(core.StringPtr("<directory_id>")))
				Expect(storageDetailsModel.Endpoint).To(Equal(core.StringPtr("abfss://<container_name>@<storage_account_name>.dfs.core.windows.net/")))
				Expect(storageDetailsModel.SasToken).To(Equal(core.StringPtr("<sas_token>")))
				Expect(storageDetailsModel.SecretKey).To(Equal(core.StringPtr("secret_key")))
				Expect(storageDetailsModel.StorageAccountName).To(Equal(core.StringPtr("sample-storage")))

				// Construct an instance of the CreateBucketRegistrationOptions model
				createBucketRegistrationOptionsBucketType := "ibm_cos"
				createBucketRegistrationOptionsDescription := "COS bucket for customer data"
				createBucketRegistrationOptionsManagedBy := "ibm"
				createBucketRegistrationOptionsModel := watsonxDataService.NewCreateBucketRegistrationOptions(createBucketRegistrationOptionsBucketType, createBucketRegistrationOptionsDescription, createBucketRegistrationOptionsManagedBy)
				createBucketRegistrationOptionsModel.SetBucketType("ibm_cos")
				createBucketRegistrationOptionsModel.SetDescription("COS bucket for customer data")
				createBucketRegistrationOptionsModel.SetManagedBy("ibm")
				createBucketRegistrationOptionsModel.SetAssociatedCatalog(bucketCatalogModel)
				createBucketRegistrationOptionsModel.SetBucketDetails(bucketDetailsModel)
				createBucketRegistrationOptionsModel.SetBucketDisplayName("sample-bucket-displayname")
				createBucketRegistrationOptionsModel.SetRegion("us-south")
				createBucketRegistrationOptionsModel.SetStorageDetails(storageDetailsModel)
				createBucketRegistrationOptionsModel.SetTags([]string{"bucket-tag1", "bucket-tag2"})
				createBucketRegistrationOptionsModel.SetAuthInstanceID("testString")
				createBucketRegistrationOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createBucketRegistrationOptionsModel).ToNot(BeNil())
				Expect(createBucketRegistrationOptionsModel.BucketType).To(Equal(core.StringPtr("ibm_cos")))
				Expect(createBucketRegistrationOptionsModel.Description).To(Equal(core.StringPtr("COS bucket for customer data")))
				Expect(createBucketRegistrationOptionsModel.ManagedBy).To(Equal(core.StringPtr("ibm")))
				Expect(createBucketRegistrationOptionsModel.AssociatedCatalog).To(Equal(bucketCatalogModel))
				Expect(createBucketRegistrationOptionsModel.BucketDetails).To(Equal(bucketDetailsModel))
				Expect(createBucketRegistrationOptionsModel.BucketDisplayName).To(Equal(core.StringPtr("sample-bucket-displayname")))
				Expect(createBucketRegistrationOptionsModel.Region).To(Equal(core.StringPtr("us-south")))
				Expect(createBucketRegistrationOptionsModel.StorageDetails).To(Equal(storageDetailsModel))
				Expect(createBucketRegistrationOptionsModel.Tags).To(Equal([]string{"bucket-tag1", "bucket-tag2"}))
				Expect(createBucketRegistrationOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createBucketRegistrationOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateColumnsOptions successfully`, func() {
				// Construct an instance of the Column model
				columnModel := new(watsonxdatav2.Column)
				Expect(columnModel).ToNot(BeNil())
				columnModel.ColumnName = core.StringPtr("expenses")
				columnModel.Comment = core.StringPtr("expenses column")
				columnModel.Extra = core.StringPtr("varchar")
				columnModel.Length = core.StringPtr("30")
				columnModel.Scale = core.StringPtr("2")
				columnModel.Precision = core.StringPtr("10")
				columnModel.Type = core.StringPtr("varchar")
				Expect(columnModel.ColumnName).To(Equal(core.StringPtr("expenses")))
				Expect(columnModel.Comment).To(Equal(core.StringPtr("expenses column")))
				Expect(columnModel.Extra).To(Equal(core.StringPtr("varchar")))
				Expect(columnModel.Length).To(Equal(core.StringPtr("30")))
				Expect(columnModel.Scale).To(Equal(core.StringPtr("2")))
				Expect(columnModel.Precision).To(Equal(core.StringPtr("10")))
				Expect(columnModel.Type).To(Equal(core.StringPtr("varchar")))

				// Construct an instance of the CreateColumnsOptions model
				engineID := "testString"
				catalogID := "testString"
				schemaID := "testString"
				tableID := "testString"
				createColumnsOptionsModel := watsonxDataService.NewCreateColumnsOptions(engineID, catalogID, schemaID, tableID)
				createColumnsOptionsModel.SetEngineID("testString")
				createColumnsOptionsModel.SetCatalogID("testString")
				createColumnsOptionsModel.SetSchemaID("testString")
				createColumnsOptionsModel.SetTableID("testString")
				createColumnsOptionsModel.SetColumns([]watsonxdatav2.Column{*columnModel})
				createColumnsOptionsModel.SetAuthInstanceID("testString")
				createColumnsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createColumnsOptionsModel).ToNot(BeNil())
				Expect(createColumnsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(createColumnsOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(createColumnsOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(createColumnsOptionsModel.TableID).To(Equal(core.StringPtr("testString")))
				Expect(createColumnsOptionsModel.Columns).To(Equal([]watsonxdatav2.Column{*columnModel}))
				Expect(createColumnsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createColumnsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateDatabaseRegistrationOptions successfully`, func() {
				// Construct an instance of the DatabaseCatalog model
				databaseCatalogModel := new(watsonxdatav2.DatabaseCatalog)
				Expect(databaseCatalogModel).ToNot(BeNil())
				databaseCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				databaseCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				databaseCatalogModel.CatalogType = core.StringPtr("iceberg")
				Expect(databaseCatalogModel.CatalogName).To(Equal(core.StringPtr("sampleCatalog")))
				Expect(databaseCatalogModel.CatalogTags).To(Equal([]string{"catalog_tag_1", "catalog_tag_2"}))
				Expect(databaseCatalogModel.CatalogType).To(Equal(core.StringPtr("iceberg")))

				// Construct an instance of the DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems model
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems)
				Expect(databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel).ToNot(BeNil())
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")
				Expect(databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Encrypt).To(Equal(core.BoolPtr(true)))
				Expect(databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Key).To(Equal(core.StringPtr("abc")))
				Expect(databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel.Value).To(Equal(core.StringPtr("xyz")))

				// Construct an instance of the DatabaseDetails model
				databaseDetailsModel := new(watsonxdatav2.DatabaseDetails)
				Expect(databaseDetailsModel).ToNot(BeNil())
				databaseDetailsModel.AuthenticationType = core.StringPtr("LDAP")
				databaseDetailsModel.AuthenticationValue = core.StringPtr("LDAP")
				databaseDetailsModel.BrokerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseDetailsModel.BrokerAuthenticationType = core.StringPtr("PASSWORD")
				databaseDetailsModel.BrokerAuthenticationUser = core.StringPtr("sampleuser")
				databaseDetailsModel.BrokerHost = core.StringPtr("samplehost")
				databaseDetailsModel.BrokerPort = core.Int64Ptr(int64(4553))
				databaseDetailsModel.Certificate = core.StringPtr("contents of a pem/crt file")
				databaseDetailsModel.CertificateExtension = core.StringPtr("pem/crt")
				databaseDetailsModel.ConnectionMethod = core.StringPtr("basic, apikey")
				databaseDetailsModel.ConnectionMode = core.StringPtr("service_name")
				databaseDetailsModel.ConnectionModeValue = core.StringPtr("orclpdb")
				databaseDetailsModel.ConnectionType = core.StringPtr("JDBC, Arrow flight")
				databaseDetailsModel.ControllerAuthenticationPassword = core.StringPtr("samplepassword")
				databaseDetailsModel.ControllerAuthenticationType = core.StringPtr("PASSWORD")
				databaseDetailsModel.ControllerAuthenticationUser = core.StringPtr("sampleuser")
				databaseDetailsModel.CoordinatorHost = core.StringPtr("samplehost")
				databaseDetailsModel.CoordinatorPort = core.Int64Ptr(int64(4553))
				databaseDetailsModel.CpdHostname = core.StringPtr("samplecpdhostname")
				databaseDetailsModel.CredentialsKey = core.StringPtr("eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......")
				databaseDetailsModel.DatabaseName = core.StringPtr("new_database")
				databaseDetailsModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems{*databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel}
				databaseDetailsModel.Hostname = core.StringPtr("db2@<hostname>.com")
				databaseDetailsModel.HostnameInCertificate = core.StringPtr("samplehostname")
				databaseDetailsModel.Hosts = core.StringPtr("abc.com:1234,xyz.com:4321")
				databaseDetailsModel.InformixServer = core.StringPtr("ol_informix1410")
				databaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseDetailsModel.Port = core.Int64Ptr(int64(4553))
				databaseDetailsModel.ProjectID = core.StringPtr("conops-bigquery")
				databaseDetailsModel.Sasl = core.BoolPtr(true)
				databaseDetailsModel.SaslMechanism = core.StringPtr("plain")
				databaseDetailsModel.SchemaName = core.StringPtr("sampleSchema")
				databaseDetailsModel.Schemas = core.StringPtr("redis__name")
				databaseDetailsModel.ServiceApiKey = core.StringPtr("sampleapikey")
				databaseDetailsModel.ServiceHostname = core.StringPtr("api.dataplatform.dev.cloud.ibm.com")
				databaseDetailsModel.ServicePassword = core.StringPtr("samplepassword")
				databaseDetailsModel.ServicePort = core.Int64Ptr(int64(443))
				databaseDetailsModel.ServiceSsl = core.BoolPtr(true)
				databaseDetailsModel.ServiceTokenURL = core.StringPtr("sampletoakenurl")
				databaseDetailsModel.ServiceUsername = core.StringPtr("sampleusername")
				databaseDetailsModel.Ssl = core.BoolPtr(true)
				databaseDetailsModel.Tables = core.StringPtr("kafka_table_name, redis_table_name")
				databaseDetailsModel.Username = core.StringPtr("sampleuser")
				databaseDetailsModel.ValidateServerCertificate = core.BoolPtr(true)
				databaseDetailsModel.VerifyHostName = core.BoolPtr(true)
				databaseDetailsModel.WarehouseName = core.StringPtr("samplewrehouse")
				Expect(databaseDetailsModel.AuthenticationType).To(Equal(core.StringPtr("LDAP")))
				Expect(databaseDetailsModel.AuthenticationValue).To(Equal(core.StringPtr("LDAP")))
				Expect(databaseDetailsModel.BrokerAuthenticationPassword).To(Equal(core.StringPtr("samplepassword")))
				Expect(databaseDetailsModel.BrokerAuthenticationType).To(Equal(core.StringPtr("PASSWORD")))
				Expect(databaseDetailsModel.BrokerAuthenticationUser).To(Equal(core.StringPtr("sampleuser")))
				Expect(databaseDetailsModel.BrokerHost).To(Equal(core.StringPtr("samplehost")))
				Expect(databaseDetailsModel.BrokerPort).To(Equal(core.Int64Ptr(int64(4553))))
				Expect(databaseDetailsModel.Certificate).To(Equal(core.StringPtr("contents of a pem/crt file")))
				Expect(databaseDetailsModel.CertificateExtension).To(Equal(core.StringPtr("pem/crt")))
				Expect(databaseDetailsModel.ConnectionMethod).To(Equal(core.StringPtr("basic, apikey")))
				Expect(databaseDetailsModel.ConnectionMode).To(Equal(core.StringPtr("service_name")))
				Expect(databaseDetailsModel.ConnectionModeValue).To(Equal(core.StringPtr("orclpdb")))
				Expect(databaseDetailsModel.ConnectionType).To(Equal(core.StringPtr("JDBC, Arrow flight")))
				Expect(databaseDetailsModel.ControllerAuthenticationPassword).To(Equal(core.StringPtr("samplepassword")))
				Expect(databaseDetailsModel.ControllerAuthenticationType).To(Equal(core.StringPtr("PASSWORD")))
				Expect(databaseDetailsModel.ControllerAuthenticationUser).To(Equal(core.StringPtr("sampleuser")))
				Expect(databaseDetailsModel.CoordinatorHost).To(Equal(core.StringPtr("samplehost")))
				Expect(databaseDetailsModel.CoordinatorPort).To(Equal(core.Int64Ptr(int64(4553))))
				Expect(databaseDetailsModel.CpdHostname).To(Equal(core.StringPtr("samplecpdhostname")))
				Expect(databaseDetailsModel.CredentialsKey).To(Equal(core.StringPtr("eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......")))
				Expect(databaseDetailsModel.DatabaseName).To(Equal(core.StringPtr("new_database")))
				Expect(databaseDetailsModel.DatabaseProperties).To(Equal([]watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems{*databaseRegistrationPatchDatabaseDetailsDatabasePropertiesItemsModel}))
				Expect(databaseDetailsModel.Hostname).To(Equal(core.StringPtr("db2@<hostname>.com")))
				Expect(databaseDetailsModel.HostnameInCertificate).To(Equal(core.StringPtr("samplehostname")))
				Expect(databaseDetailsModel.Hosts).To(Equal(core.StringPtr("abc.com:1234,xyz.com:4321")))
				Expect(databaseDetailsModel.InformixServer).To(Equal(core.StringPtr("ol_informix1410")))
				Expect(databaseDetailsModel.Password).To(Equal(core.StringPtr("samplepassword")))
				Expect(databaseDetailsModel.Port).To(Equal(core.Int64Ptr(int64(4553))))
				Expect(databaseDetailsModel.ProjectID).To(Equal(core.StringPtr("conops-bigquery")))
				Expect(databaseDetailsModel.Sasl).To(Equal(core.BoolPtr(true)))
				Expect(databaseDetailsModel.SaslMechanism).To(Equal(core.StringPtr("plain")))
				Expect(databaseDetailsModel.SchemaName).To(Equal(core.StringPtr("sampleSchema")))
				Expect(databaseDetailsModel.Schemas).To(Equal(core.StringPtr("redis__name")))
				Expect(databaseDetailsModel.ServiceApiKey).To(Equal(core.StringPtr("sampleapikey")))
				Expect(databaseDetailsModel.ServiceHostname).To(Equal(core.StringPtr("api.dataplatform.dev.cloud.ibm.com")))
				Expect(databaseDetailsModel.ServicePassword).To(Equal(core.StringPtr("samplepassword")))
				Expect(databaseDetailsModel.ServicePort).To(Equal(core.Int64Ptr(int64(443))))
				Expect(databaseDetailsModel.ServiceSsl).To(Equal(core.BoolPtr(true)))
				Expect(databaseDetailsModel.ServiceTokenURL).To(Equal(core.StringPtr("sampletoakenurl")))
				Expect(databaseDetailsModel.ServiceUsername).To(Equal(core.StringPtr("sampleusername")))
				Expect(databaseDetailsModel.Ssl).To(Equal(core.BoolPtr(true)))
				Expect(databaseDetailsModel.Tables).To(Equal(core.StringPtr("kafka_table_name, redis_table_name")))
				Expect(databaseDetailsModel.Username).To(Equal(core.StringPtr("sampleuser")))
				Expect(databaseDetailsModel.ValidateServerCertificate).To(Equal(core.BoolPtr(true)))
				Expect(databaseDetailsModel.VerifyHostName).To(Equal(core.BoolPtr(true)))
				Expect(databaseDetailsModel.WarehouseName).To(Equal(core.StringPtr("samplewrehouse")))

				// Construct an instance of the DatabaseRegistrationPrototypeDatabasePropertiesItems model
				databaseRegistrationPrototypeDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems)
				Expect(databaseRegistrationPrototypeDatabasePropertiesItemsModel).ToNot(BeNil())
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")
				Expect(databaseRegistrationPrototypeDatabasePropertiesItemsModel.Encrypt).To(Equal(core.BoolPtr(true)))
				Expect(databaseRegistrationPrototypeDatabasePropertiesItemsModel.Key).To(Equal(core.StringPtr("abc")))
				Expect(databaseRegistrationPrototypeDatabasePropertiesItemsModel.Value).To(Equal(core.StringPtr("xyz")))

				// Construct an instance of the CreateDatabaseRegistrationOptions model
				createDatabaseRegistrationOptionsDatabaseDisplayName := "new_database"
				createDatabaseRegistrationOptionsDatabaseType := "db2"
				createDatabaseRegistrationOptionsModel := watsonxDataService.NewCreateDatabaseRegistrationOptions(createDatabaseRegistrationOptionsDatabaseDisplayName, createDatabaseRegistrationOptionsDatabaseType)
				createDatabaseRegistrationOptionsModel.SetDatabaseDisplayName("new_database")
				createDatabaseRegistrationOptionsModel.SetDatabaseType("db2")
				createDatabaseRegistrationOptionsModel.SetAssociatedCatalog(databaseCatalogModel)
				createDatabaseRegistrationOptionsModel.SetCreatedOn("1686792721")
				createDatabaseRegistrationOptionsModel.SetDatabaseDetails(databaseDetailsModel)
				createDatabaseRegistrationOptionsModel.SetDatabaseProperties([]watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems{*databaseRegistrationPrototypeDatabasePropertiesItemsModel})
				createDatabaseRegistrationOptionsModel.SetDescription("db2 extenal database description")
				createDatabaseRegistrationOptionsModel.SetTags([]string{"testdatabase", "userdatabase"})
				createDatabaseRegistrationOptionsModel.SetAuthInstanceID("testString")
				createDatabaseRegistrationOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createDatabaseRegistrationOptionsModel).ToNot(BeNil())
				Expect(createDatabaseRegistrationOptionsModel.DatabaseDisplayName).To(Equal(core.StringPtr("new_database")))
				Expect(createDatabaseRegistrationOptionsModel.DatabaseType).To(Equal(core.StringPtr("db2")))
				Expect(createDatabaseRegistrationOptionsModel.AssociatedCatalog).To(Equal(databaseCatalogModel))
				Expect(createDatabaseRegistrationOptionsModel.CreatedOn).To(Equal(core.StringPtr("1686792721")))
				Expect(createDatabaseRegistrationOptionsModel.DatabaseDetails).To(Equal(databaseDetailsModel))
				Expect(createDatabaseRegistrationOptionsModel.DatabaseProperties).To(Equal([]watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems{*databaseRegistrationPrototypeDatabasePropertiesItemsModel}))
				Expect(createDatabaseRegistrationOptionsModel.Description).To(Equal(core.StringPtr("db2 extenal database description")))
				Expect(createDatabaseRegistrationOptionsModel.Tags).To(Equal([]string{"testdatabase", "userdatabase"}))
				Expect(createDatabaseRegistrationOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createDatabaseRegistrationOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateDb2EngineOptions successfully`, func() {
				// Construct an instance of the Db2EngineDetailsBody model
				db2EngineDetailsBodyModel := new(watsonxdatav2.Db2EngineDetailsBody)
				Expect(db2EngineDetailsBodyModel).ToNot(BeNil())
				db2EngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				Expect(db2EngineDetailsBodyModel.ConnectionString).To(Equal(core.StringPtr("1.2.3.4")))

				// Construct an instance of the CreateDb2EngineOptions model
				createDb2EngineOptionsOrigin := "external"
				createDb2EngineOptionsModel := watsonxDataService.NewCreateDb2EngineOptions(createDb2EngineOptionsOrigin)
				createDb2EngineOptionsModel.SetOrigin("external")
				createDb2EngineOptionsModel.SetDescription("db2 engine description")
				createDb2EngineOptionsModel.SetEngineDetails(db2EngineDetailsBodyModel)
				createDb2EngineOptionsModel.SetEngineDisplayName("sampleEngine")
				createDb2EngineOptionsModel.SetTags([]string{"tag1", "tag2"})
				createDb2EngineOptionsModel.SetAuthInstanceID("testString")
				createDb2EngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createDb2EngineOptionsModel).ToNot(BeNil())
				Expect(createDb2EngineOptionsModel.Origin).To(Equal(core.StringPtr("external")))
				Expect(createDb2EngineOptionsModel.Description).To(Equal(core.StringPtr("db2 engine description")))
				Expect(createDb2EngineOptionsModel.EngineDetails).To(Equal(db2EngineDetailsBodyModel))
				Expect(createDb2EngineOptionsModel.EngineDisplayName).To(Equal(core.StringPtr("sampleEngine")))
				Expect(createDb2EngineOptionsModel.Tags).To(Equal([]string{"tag1", "tag2"}))
				Expect(createDb2EngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createDb2EngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateExecuteQueryOptions successfully`, func() {
				// Construct an instance of the CreateExecuteQueryOptions model
				engineID := "testString"
				createExecuteQueryOptionsSqlString := "select expenses from expenditure"
				createExecuteQueryOptionsModel := watsonxDataService.NewCreateExecuteQueryOptions(engineID, createExecuteQueryOptionsSqlString)
				createExecuteQueryOptionsModel.SetEngineID("testString")
				createExecuteQueryOptionsModel.SetSqlString("select expenses from expenditure")
				createExecuteQueryOptionsModel.SetCatalogName("sampleCatalog")
				createExecuteQueryOptionsModel.SetSchemaName("SampleSchema1")
				createExecuteQueryOptionsModel.SetAuthInstanceID("testString")
				createExecuteQueryOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createExecuteQueryOptionsModel).ToNot(BeNil())
				Expect(createExecuteQueryOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(createExecuteQueryOptionsModel.SqlString).To(Equal(core.StringPtr("select expenses from expenditure")))
				Expect(createExecuteQueryOptionsModel.CatalogName).To(Equal(core.StringPtr("sampleCatalog")))
				Expect(createExecuteQueryOptionsModel.SchemaName).To(Equal(core.StringPtr("SampleSchema1")))
				Expect(createExecuteQueryOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createExecuteQueryOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateHdfsStorageOptions successfully`, func() {
				// Construct an instance of the CreateHdfsStorageOptions model
				bucketDisplayName := "testString"
				bucketType := "testString"
				hmsThriftURI := "testString"
				hmsThriftPort := int64(1)
				coreSite := "testString"
				hdfsSite := "testString"
				kerberos := "testString"
				catalogName := "testString"
				catalogType := "testString"
				createHdfsStorageOptionsModel := watsonxDataService.NewCreateHdfsStorageOptions(bucketDisplayName, bucketType, hmsThriftURI, hmsThriftPort, coreSite, hdfsSite, kerberos, catalogName, catalogType)
				createHdfsStorageOptionsModel.SetBucketDisplayName("testString")
				createHdfsStorageOptionsModel.SetBucketType("testString")
				createHdfsStorageOptionsModel.SetHmsThriftURI("testString")
				createHdfsStorageOptionsModel.SetHmsThriftPort(int64(1))
				createHdfsStorageOptionsModel.SetCoreSite("testString")
				createHdfsStorageOptionsModel.SetHdfsSite("testString")
				createHdfsStorageOptionsModel.SetKerberos("testString")
				createHdfsStorageOptionsModel.SetCatalogName("testString")
				createHdfsStorageOptionsModel.SetCatalogType("testString")
				createHdfsStorageOptionsModel.SetKrb5Config("testString")
				createHdfsStorageOptionsModel.SetHiveKeytab(CreateMockReader("This is a mock file."))
				createHdfsStorageOptionsModel.SetHiveKeytabContentType("testString")
				createHdfsStorageOptionsModel.SetHdfsKeytab(CreateMockReader("This is a mock file."))
				createHdfsStorageOptionsModel.SetHdfsKeytabContentType("testString")
				createHdfsStorageOptionsModel.SetHiveServerPrincipal("testString")
				createHdfsStorageOptionsModel.SetHiveClientPrincipal("testString")
				createHdfsStorageOptionsModel.SetHdfsPrincipal("testString")
				createHdfsStorageOptionsModel.SetDescription("testString")
				createHdfsStorageOptionsModel.SetCreatedOn("testString")
				createHdfsStorageOptionsModel.SetAuthInstanceID("testString")
				createHdfsStorageOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createHdfsStorageOptionsModel).ToNot(BeNil())
				Expect(createHdfsStorageOptionsModel.BucketDisplayName).To(Equal(core.StringPtr("testString")))
				Expect(createHdfsStorageOptionsModel.BucketType).To(Equal(core.StringPtr("testString")))
				Expect(createHdfsStorageOptionsModel.HmsThriftURI).To(Equal(core.StringPtr("testString")))
				Expect(createHdfsStorageOptionsModel.HmsThriftPort).To(Equal(core.Int64Ptr(int64(1))))
				Expect(createHdfsStorageOptionsModel.CoreSite).To(Equal(core.StringPtr("testString")))
				Expect(createHdfsStorageOptionsModel.HdfsSite).To(Equal(core.StringPtr("testString")))
				Expect(createHdfsStorageOptionsModel.Kerberos).To(Equal(core.StringPtr("testString")))
				Expect(createHdfsStorageOptionsModel.CatalogName).To(Equal(core.StringPtr("testString")))
				Expect(createHdfsStorageOptionsModel.CatalogType).To(Equal(core.StringPtr("testString")))
				Expect(createHdfsStorageOptionsModel.Krb5Config).To(Equal(core.StringPtr("testString")))
				Expect(createHdfsStorageOptionsModel.HiveKeytab).To(Equal(CreateMockReader("This is a mock file.")))
				Expect(createHdfsStorageOptionsModel.HiveKeytabContentType).To(Equal(core.StringPtr("testString")))
				Expect(createHdfsStorageOptionsModel.HdfsKeytab).To(Equal(CreateMockReader("This is a mock file.")))
				Expect(createHdfsStorageOptionsModel.HdfsKeytabContentType).To(Equal(core.StringPtr("testString")))
				Expect(createHdfsStorageOptionsModel.HiveServerPrincipal).To(Equal(core.StringPtr("testString")))
				Expect(createHdfsStorageOptionsModel.HiveClientPrincipal).To(Equal(core.StringPtr("testString")))
				Expect(createHdfsStorageOptionsModel.HdfsPrincipal).To(Equal(core.StringPtr("testString")))
				Expect(createHdfsStorageOptionsModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(createHdfsStorageOptionsModel.CreatedOn).To(Equal(core.StringPtr("testString")))
				Expect(createHdfsStorageOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createHdfsStorageOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateIngestionJobsLocalFilesOptions successfully`, func() {
				// Construct an instance of the CreateIngestionJobsLocalFilesOptions model
				authInstanceID := "testString"
				sourceDataFile := CreateMockReader("This is a mock file.")
				targetTable := "testString"
				jobID := "testString"
				username := "testString"
				createIngestionJobsLocalFilesOptionsModel := watsonxDataService.NewCreateIngestionJobsLocalFilesOptions(authInstanceID, sourceDataFile, targetTable, jobID, username)
				createIngestionJobsLocalFilesOptionsModel.SetAuthInstanceID("testString")
				createIngestionJobsLocalFilesOptionsModel.SetSourceDataFile(CreateMockReader("This is a mock file."))
				createIngestionJobsLocalFilesOptionsModel.SetTargetTable("testString")
				createIngestionJobsLocalFilesOptionsModel.SetJobID("testString")
				createIngestionJobsLocalFilesOptionsModel.SetUsername("testString")
				createIngestionJobsLocalFilesOptionsModel.SetSourceDataFileContentType("testString")
				createIngestionJobsLocalFilesOptionsModel.SetSourceFileType("csv")
				createIngestionJobsLocalFilesOptionsModel.SetCsvProperty("testString")
				createIngestionJobsLocalFilesOptionsModel.SetCreateIfNotExist(false)
				createIngestionJobsLocalFilesOptionsModel.SetValidateCsvHeader(false)
				createIngestionJobsLocalFilesOptionsModel.SetExecuteConfig("testString")
				createIngestionJobsLocalFilesOptionsModel.SetEngineID("testString")
				createIngestionJobsLocalFilesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createIngestionJobsLocalFilesOptionsModel).ToNot(BeNil())
				Expect(createIngestionJobsLocalFilesOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createIngestionJobsLocalFilesOptionsModel.SourceDataFile).To(Equal(CreateMockReader("This is a mock file.")))
				Expect(createIngestionJobsLocalFilesOptionsModel.TargetTable).To(Equal(core.StringPtr("testString")))
				Expect(createIngestionJobsLocalFilesOptionsModel.JobID).To(Equal(core.StringPtr("testString")))
				Expect(createIngestionJobsLocalFilesOptionsModel.Username).To(Equal(core.StringPtr("testString")))
				Expect(createIngestionJobsLocalFilesOptionsModel.SourceDataFileContentType).To(Equal(core.StringPtr("testString")))
				Expect(createIngestionJobsLocalFilesOptionsModel.SourceFileType).To(Equal(core.StringPtr("csv")))
				Expect(createIngestionJobsLocalFilesOptionsModel.CsvProperty).To(Equal(core.StringPtr("testString")))
				Expect(createIngestionJobsLocalFilesOptionsModel.CreateIfNotExist).To(Equal(core.BoolPtr(false)))
				Expect(createIngestionJobsLocalFilesOptionsModel.ValidateCsvHeader).To(Equal(core.BoolPtr(false)))
				Expect(createIngestionJobsLocalFilesOptionsModel.ExecuteConfig).To(Equal(core.StringPtr("testString")))
				Expect(createIngestionJobsLocalFilesOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(createIngestionJobsLocalFilesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateIngestionJobsOptions successfully`, func() {
				// Construct an instance of the IngestionJobPrototypeCsvProperty model
				ingestionJobPrototypeCsvPropertyModel := new(watsonxdatav2.IngestionJobPrototypeCsvProperty)
				Expect(ingestionJobPrototypeCsvPropertyModel).ToNot(BeNil())
				ingestionJobPrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				ingestionJobPrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				ingestionJobPrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				ingestionJobPrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				ingestionJobPrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")
				Expect(ingestionJobPrototypeCsvPropertyModel.Encoding).To(Equal(core.StringPtr("utf-8")))
				Expect(ingestionJobPrototypeCsvPropertyModel.EscapeCharacter).To(Equal(core.StringPtr("\\\\")))
				Expect(ingestionJobPrototypeCsvPropertyModel.FieldDelimiter).To(Equal(core.StringPtr(",")))
				Expect(ingestionJobPrototypeCsvPropertyModel.Header).To(Equal(core.BoolPtr(true)))
				Expect(ingestionJobPrototypeCsvPropertyModel.LineDelimiter).To(Equal(core.StringPtr("\\n")))

				// Construct an instance of the IngestionJobPrototypeExecuteConfig model
				ingestionJobPrototypeExecuteConfigModel := new(watsonxdatav2.IngestionJobPrototypeExecuteConfig)
				Expect(ingestionJobPrototypeExecuteConfigModel).ToNot(BeNil())
				ingestionJobPrototypeExecuteConfigModel.DriverCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.DriverMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.ExecutorCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.ExecutorMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.NumExecutors = core.Int64Ptr(int64(1))
				Expect(ingestionJobPrototypeExecuteConfigModel.DriverCores).To(Equal(core.Int64Ptr(int64(1))))
				Expect(ingestionJobPrototypeExecuteConfigModel.DriverMemory).To(Equal(core.StringPtr("2G")))
				Expect(ingestionJobPrototypeExecuteConfigModel.ExecutorCores).To(Equal(core.Int64Ptr(int64(1))))
				Expect(ingestionJobPrototypeExecuteConfigModel.ExecutorMemory).To(Equal(core.StringPtr("2G")))
				Expect(ingestionJobPrototypeExecuteConfigModel.NumExecutors).To(Equal(core.Int64Ptr(int64(1))))

				// Construct an instance of the CreateIngestionJobsOptions model
				authInstanceID := "testString"
				createIngestionJobsOptionsJobID := "ingestion-1699459946935"
				createIngestionJobsOptionsSourceDataFiles := "s3://demobucket/data/yellow_tripdata_2022-01.parquet"
				createIngestionJobsOptionsTargetTable := "demodb.test.targettable"
				createIngestionJobsOptionsUsername := "user1"
				createIngestionJobsOptionsModel := watsonxDataService.NewCreateIngestionJobsOptions(authInstanceID, createIngestionJobsOptionsJobID, createIngestionJobsOptionsSourceDataFiles, createIngestionJobsOptionsTargetTable, createIngestionJobsOptionsUsername)
				createIngestionJobsOptionsModel.SetAuthInstanceID("testString")
				createIngestionJobsOptionsModel.SetJobID("ingestion-1699459946935")
				createIngestionJobsOptionsModel.SetSourceDataFiles("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createIngestionJobsOptionsModel.SetTargetTable("demodb.test.targettable")
				createIngestionJobsOptionsModel.SetUsername("user1")
				createIngestionJobsOptionsModel.SetCreateIfNotExist(false)
				createIngestionJobsOptionsModel.SetCsvProperty(ingestionJobPrototypeCsvPropertyModel)
				createIngestionJobsOptionsModel.SetEngineID("spark123")
				createIngestionJobsOptionsModel.SetExecuteConfig(ingestionJobPrototypeExecuteConfigModel)
				createIngestionJobsOptionsModel.SetPartitionBy("col1, col2")
				createIngestionJobsOptionsModel.SetSchema("{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}")
				createIngestionJobsOptionsModel.SetSourceFileType("csv")
				createIngestionJobsOptionsModel.SetValidateCsvHeader(false)
				createIngestionJobsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createIngestionJobsOptionsModel).ToNot(BeNil())
				Expect(createIngestionJobsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createIngestionJobsOptionsModel.JobID).To(Equal(core.StringPtr("ingestion-1699459946935")))
				Expect(createIngestionJobsOptionsModel.SourceDataFiles).To(Equal(core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")))
				Expect(createIngestionJobsOptionsModel.TargetTable).To(Equal(core.StringPtr("demodb.test.targettable")))
				Expect(createIngestionJobsOptionsModel.Username).To(Equal(core.StringPtr("user1")))
				Expect(createIngestionJobsOptionsModel.CreateIfNotExist).To(Equal(core.BoolPtr(false)))
				Expect(createIngestionJobsOptionsModel.CsvProperty).To(Equal(ingestionJobPrototypeCsvPropertyModel))
				Expect(createIngestionJobsOptionsModel.EngineID).To(Equal(core.StringPtr("spark123")))
				Expect(createIngestionJobsOptionsModel.ExecuteConfig).To(Equal(ingestionJobPrototypeExecuteConfigModel))
				Expect(createIngestionJobsOptionsModel.PartitionBy).To(Equal(core.StringPtr("col1, col2")))
				Expect(createIngestionJobsOptionsModel.Schema).To(Equal(core.StringPtr("{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}")))
				Expect(createIngestionJobsOptionsModel.SourceFileType).To(Equal(core.StringPtr("csv")))
				Expect(createIngestionJobsOptionsModel.ValidateCsvHeader).To(Equal(core.BoolPtr(false)))
				Expect(createIngestionJobsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateIntegrationOptions successfully`, func() {
				// Construct an instance of the CreateIntegrationOptions model
				createIntegrationOptionsModel := watsonxDataService.NewCreateIntegrationOptions()
				createIntegrationOptionsModel.SetApikey("testString")
				createIntegrationOptionsModel.SetEnableDataPolicyWithinWxd(false)
				createIntegrationOptionsModel.SetPassword("password")
				createIntegrationOptionsModel.SetResource("resource_name")
				createIntegrationOptionsModel.SetServiceType("ranger")
				createIntegrationOptionsModel.SetStorageCatalogs([]string{"testString"})
				createIntegrationOptionsModel.SetURL("http://abcd.efgh.com:9876/")
				createIntegrationOptionsModel.SetUsername("username")
				createIntegrationOptionsModel.SetAuthInstanceID("testString")
				createIntegrationOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createIntegrationOptionsModel).ToNot(BeNil())
				Expect(createIntegrationOptionsModel.Apikey).To(Equal(core.StringPtr("testString")))
				Expect(createIntegrationOptionsModel.EnableDataPolicyWithinWxd).To(Equal(core.BoolPtr(false)))
				Expect(createIntegrationOptionsModel.Password).To(Equal(core.StringPtr("password")))
				Expect(createIntegrationOptionsModel.Resource).To(Equal(core.StringPtr("resource_name")))
				Expect(createIntegrationOptionsModel.ServiceType).To(Equal(core.StringPtr("ranger")))
				Expect(createIntegrationOptionsModel.StorageCatalogs).To(Equal([]string{"testString"}))
				Expect(createIntegrationOptionsModel.URL).To(Equal(core.StringPtr("http://abcd.efgh.com:9876/")))
				Expect(createIntegrationOptionsModel.Username).To(Equal(core.StringPtr("username")))
				Expect(createIntegrationOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createIntegrationOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateMilvusServiceOptions successfully`, func() {
				// Construct an instance of the CreateMilvusServiceOptions model
				createMilvusServiceOptionsBucketName := "Sample bucket name"
				createMilvusServiceOptionsOrigin := "native"
				createMilvusServiceOptionsRootPath := "Sample path"
				createMilvusServiceOptionsServiceDisplayName := "sampleService"
				createMilvusServiceOptionsModel := watsonxDataService.NewCreateMilvusServiceOptions(createMilvusServiceOptionsBucketName, createMilvusServiceOptionsOrigin, createMilvusServiceOptionsRootPath, createMilvusServiceOptionsServiceDisplayName)
				createMilvusServiceOptionsModel.SetBucketName("Sample bucket name")
				createMilvusServiceOptionsModel.SetOrigin("native")
				createMilvusServiceOptionsModel.SetRootPath("Sample path")
				createMilvusServiceOptionsModel.SetServiceDisplayName("sampleService")
				createMilvusServiceOptionsModel.SetBucketType("Sample bucket type")
				createMilvusServiceOptionsModel.SetDescription("milvus service for running sql queries")
				createMilvusServiceOptionsModel.SetTags([]string{"tag1", "tag2"})
				createMilvusServiceOptionsModel.SetTshirtSize("small")
				createMilvusServiceOptionsModel.SetAuthInstanceID("testString")
				createMilvusServiceOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createMilvusServiceOptionsModel).ToNot(BeNil())
				Expect(createMilvusServiceOptionsModel.BucketName).To(Equal(core.StringPtr("Sample bucket name")))
				Expect(createMilvusServiceOptionsModel.Origin).To(Equal(core.StringPtr("native")))
				Expect(createMilvusServiceOptionsModel.RootPath).To(Equal(core.StringPtr("Sample path")))
				Expect(createMilvusServiceOptionsModel.ServiceDisplayName).To(Equal(core.StringPtr("sampleService")))
				Expect(createMilvusServiceOptionsModel.BucketType).To(Equal(core.StringPtr("Sample bucket type")))
				Expect(createMilvusServiceOptionsModel.Description).To(Equal(core.StringPtr("milvus service for running sql queries")))
				Expect(createMilvusServiceOptionsModel.Tags).To(Equal([]string{"tag1", "tag2"}))
				Expect(createMilvusServiceOptionsModel.TshirtSize).To(Equal(core.StringPtr("small")))
				Expect(createMilvusServiceOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createMilvusServiceOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateMilvusServicePauseOptions successfully`, func() {
				// Construct an instance of the CreateMilvusServicePauseOptions model
				serviceID := "testString"
				createMilvusServicePauseOptionsModel := watsonxDataService.NewCreateMilvusServicePauseOptions(serviceID)
				createMilvusServicePauseOptionsModel.SetServiceID("testString")
				createMilvusServicePauseOptionsModel.SetAuthInstanceID("testString")
				createMilvusServicePauseOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createMilvusServicePauseOptionsModel).ToNot(BeNil())
				Expect(createMilvusServicePauseOptionsModel.ServiceID).To(Equal(core.StringPtr("testString")))
				Expect(createMilvusServicePauseOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createMilvusServicePauseOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateMilvusServiceResumeOptions successfully`, func() {
				// Construct an instance of the CreateMilvusServiceResumeOptions model
				serviceID := "testString"
				createMilvusServiceResumeOptionsModel := watsonxDataService.NewCreateMilvusServiceResumeOptions(serviceID)
				createMilvusServiceResumeOptionsModel.SetServiceID("testString")
				createMilvusServiceResumeOptionsModel.SetAuthInstanceID("testString")
				createMilvusServiceResumeOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createMilvusServiceResumeOptionsModel).ToNot(BeNil())
				Expect(createMilvusServiceResumeOptionsModel.ServiceID).To(Equal(core.StringPtr("testString")))
				Expect(createMilvusServiceResumeOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createMilvusServiceResumeOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateMilvusServiceScaleOptions successfully`, func() {
				// Construct an instance of the CreateMilvusServiceScaleOptions model
				serviceID := "testString"
				createMilvusServiceScaleOptionsModel := watsonxDataService.NewCreateMilvusServiceScaleOptions(serviceID)
				createMilvusServiceScaleOptionsModel.SetServiceID("testString")
				createMilvusServiceScaleOptionsModel.SetTshirtSize("small")
				createMilvusServiceScaleOptionsModel.SetAuthInstanceID("testString")
				createMilvusServiceScaleOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createMilvusServiceScaleOptionsModel).ToNot(BeNil())
				Expect(createMilvusServiceScaleOptionsModel.ServiceID).To(Equal(core.StringPtr("testString")))
				Expect(createMilvusServiceScaleOptionsModel.TshirtSize).To(Equal(core.StringPtr("small")))
				Expect(createMilvusServiceScaleOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createMilvusServiceScaleOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateNetezzaEngineOptions successfully`, func() {
				// Construct an instance of the NetezzaEngineDetailsBody model
				netezzaEngineDetailsBodyModel := new(watsonxdatav2.NetezzaEngineDetailsBody)
				Expect(netezzaEngineDetailsBodyModel).ToNot(BeNil())
				netezzaEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				Expect(netezzaEngineDetailsBodyModel.ConnectionString).To(Equal(core.StringPtr("1.2.3.4")))

				// Construct an instance of the CreateNetezzaEngineOptions model
				createNetezzaEngineOptionsOrigin := "external"
				createNetezzaEngineOptionsModel := watsonxDataService.NewCreateNetezzaEngineOptions(createNetezzaEngineOptionsOrigin)
				createNetezzaEngineOptionsModel.SetOrigin("external")
				createNetezzaEngineOptionsModel.SetDescription("netezza engine description")
				createNetezzaEngineOptionsModel.SetEngineDetails(netezzaEngineDetailsBodyModel)
				createNetezzaEngineOptionsModel.SetEngineDisplayName("sampleEngine")
				createNetezzaEngineOptionsModel.SetTags([]string{"tag1", "tag2"})
				createNetezzaEngineOptionsModel.SetAuthInstanceID("testString")
				createNetezzaEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createNetezzaEngineOptionsModel).ToNot(BeNil())
				Expect(createNetezzaEngineOptionsModel.Origin).To(Equal(core.StringPtr("external")))
				Expect(createNetezzaEngineOptionsModel.Description).To(Equal(core.StringPtr("netezza engine description")))
				Expect(createNetezzaEngineOptionsModel.EngineDetails).To(Equal(netezzaEngineDetailsBodyModel))
				Expect(createNetezzaEngineOptionsModel.EngineDisplayName).To(Equal(core.StringPtr("sampleEngine")))
				Expect(createNetezzaEngineOptionsModel.Tags).To(Equal([]string{"tag1", "tag2"}))
				Expect(createNetezzaEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createNetezzaEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateOtherEngineOptions successfully`, func() {
				// Construct an instance of the OtherEngineDetailsBody model
				otherEngineDetailsBodyModel := new(watsonxdatav2.OtherEngineDetailsBody)
				Expect(otherEngineDetailsBodyModel).ToNot(BeNil())
				otherEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				otherEngineDetailsBodyModel.EngineType = core.StringPtr("netezza")
				Expect(otherEngineDetailsBodyModel.ConnectionString).To(Equal(core.StringPtr("1.2.3.4")))
				Expect(otherEngineDetailsBodyModel.EngineType).To(Equal(core.StringPtr("netezza")))

				// Construct an instance of the CreateOtherEngineOptions model
				var createOtherEngineOptionsEngineDetails *watsonxdatav2.OtherEngineDetailsBody = nil
				createOtherEngineOptionsEngineDisplayName := "sampleEngine01"
				createOtherEngineOptionsModel := watsonxDataService.NewCreateOtherEngineOptions(createOtherEngineOptionsEngineDetails, createOtherEngineOptionsEngineDisplayName)
				createOtherEngineOptionsModel.SetEngineDetails(otherEngineDetailsBodyModel)
				createOtherEngineOptionsModel.SetEngineDisplayName("sampleEngine01")
				createOtherEngineOptionsModel.SetDescription("external engine description")
				createOtherEngineOptionsModel.SetOrigin("external")
				createOtherEngineOptionsModel.SetTags([]string{"tag1", "tag2"})
				createOtherEngineOptionsModel.SetAuthInstanceID("testString")
				createOtherEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createOtherEngineOptionsModel).ToNot(BeNil())
				Expect(createOtherEngineOptionsModel.EngineDetails).To(Equal(otherEngineDetailsBodyModel))
				Expect(createOtherEngineOptionsModel.EngineDisplayName).To(Equal(core.StringPtr("sampleEngine01")))
				Expect(createOtherEngineOptionsModel.Description).To(Equal(core.StringPtr("external engine description")))
				Expect(createOtherEngineOptionsModel.Origin).To(Equal(core.StringPtr("external")))
				Expect(createOtherEngineOptionsModel.Tags).To(Equal([]string{"tag1", "tag2"}))
				Expect(createOtherEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createOtherEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreatePrestissimoEngineCatalogsOptions successfully`, func() {
				// Construct an instance of the CreatePrestissimoEngineCatalogsOptions model
				engineID := "testString"
				createPrestissimoEngineCatalogsOptionsModel := watsonxDataService.NewCreatePrestissimoEngineCatalogsOptions(engineID)
				createPrestissimoEngineCatalogsOptionsModel.SetEngineID("testString")
				createPrestissimoEngineCatalogsOptionsModel.SetCatalogNames("testString")
				createPrestissimoEngineCatalogsOptionsModel.SetAuthInstanceID("testString")
				createPrestissimoEngineCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createPrestissimoEngineCatalogsOptionsModel).ToNot(BeNil())
				Expect(createPrestissimoEngineCatalogsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(createPrestissimoEngineCatalogsOptionsModel.CatalogNames).To(Equal(core.StringPtr("testString")))
				Expect(createPrestissimoEngineCatalogsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createPrestissimoEngineCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreatePrestissimoEngineOptions successfully`, func() {
				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				Expect(prestissimoNodeDescriptionBodyModel).ToNot(BeNil())
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))
				Expect(prestissimoNodeDescriptionBodyModel.NodeType).To(Equal(core.StringPtr("worker")))
				Expect(prestissimoNodeDescriptionBodyModel.Quantity).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the PrestissimoEndpoints model
				prestissimoEndpointsModel := new(watsonxdatav2.PrestissimoEndpoints)
				Expect(prestissimoEndpointsModel).ToNot(BeNil())
				prestissimoEndpointsModel.ApplicationsApi = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>")
				prestissimoEndpointsModel.HistoryServerEndpoint = core.StringPtr("$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server")
				prestissimoEndpointsModel.SparkAccessEndpoint = core.StringPtr("$HOST/analytics-engine/details/spark-<instance_id>")
				prestissimoEndpointsModel.SparkJobsV4Endpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications")
				prestissimoEndpointsModel.SparkKernelEndpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels")
				prestissimoEndpointsModel.ViewHistoryServer = core.StringPtr("testString")
				prestissimoEndpointsModel.WxdApplicationEndpoint = core.StringPtr("$HOST/v1/1698311655308796/engines/spark817/applications")
				Expect(prestissimoEndpointsModel.ApplicationsApi).To(Equal(core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>")))
				Expect(prestissimoEndpointsModel.HistoryServerEndpoint).To(Equal(core.StringPtr("$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server")))
				Expect(prestissimoEndpointsModel.SparkAccessEndpoint).To(Equal(core.StringPtr("$HOST/analytics-engine/details/spark-<instance_id>")))
				Expect(prestissimoEndpointsModel.SparkJobsV4Endpoint).To(Equal(core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications")))
				Expect(prestissimoEndpointsModel.SparkKernelEndpoint).To(Equal(core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels")))
				Expect(prestissimoEndpointsModel.ViewHistoryServer).To(Equal(core.StringPtr("testString")))
				Expect(prestissimoEndpointsModel.WxdApplicationEndpoint).To(Equal(core.StringPtr("$HOST/v1/1698311655308796/engines/spark817/applications")))

				// Construct an instance of the PrestissimoEngineDetails model
				prestissimoEngineDetailsModel := new(watsonxdatav2.PrestissimoEngineDetails)
				Expect(prestissimoEngineDetailsModel).ToNot(BeNil())
				prestissimoEngineDetailsModel.ApiKey = core.StringPtr("<api_key>")
				prestissimoEngineDetailsModel.ConnectionString = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				prestissimoEngineDetailsModel.Endpoints = prestissimoEndpointsModel
				prestissimoEngineDetailsModel.InstanceID = core.StringPtr("instance_id")
				prestissimoEngineDetailsModel.ManagedBy = core.StringPtr("fully/self")
				prestissimoEngineDetailsModel.MetastoreHost = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.SizeConfig = core.StringPtr("starter")
				prestissimoEngineDetailsModel.Worker = prestissimoNodeDescriptionBodyModel
				Expect(prestissimoEngineDetailsModel.ApiKey).To(Equal(core.StringPtr("<api_key>")))
				Expect(prestissimoEngineDetailsModel.ConnectionString).To(Equal(core.StringPtr("1.2.3.4")))
				Expect(prestissimoEngineDetailsModel.Coordinator).To(Equal(prestissimoNodeDescriptionBodyModel))
				Expect(prestissimoEngineDetailsModel.Endpoints).To(Equal(prestissimoEndpointsModel))
				Expect(prestissimoEngineDetailsModel.InstanceID).To(Equal(core.StringPtr("instance_id")))
				Expect(prestissimoEngineDetailsModel.ManagedBy).To(Equal(core.StringPtr("fully/self")))
				Expect(prestissimoEngineDetailsModel.MetastoreHost).To(Equal(core.StringPtr("1.2.3.4")))
				Expect(prestissimoEngineDetailsModel.SizeConfig).To(Equal(core.StringPtr("starter")))
				Expect(prestissimoEngineDetailsModel.Worker).To(Equal(prestissimoNodeDescriptionBodyModel))

				// Construct an instance of the CreatePrestissimoEngineOptions model
				createPrestissimoEngineOptionsOrigin := "native"
				createPrestissimoEngineOptionsModel := watsonxDataService.NewCreatePrestissimoEngineOptions(createPrestissimoEngineOptionsOrigin)
				createPrestissimoEngineOptionsModel.SetOrigin("native")
				createPrestissimoEngineOptionsModel.SetAssociatedCatalogs([]string{"hive_data"})
				createPrestissimoEngineOptionsModel.SetDescription("prestissimo engine description")
				createPrestissimoEngineOptionsModel.SetEngineDetails(prestissimoEngineDetailsModel)
				createPrestissimoEngineOptionsModel.SetEngineDisplayName("sampleEngine")
				createPrestissimoEngineOptionsModel.SetRegion("us-south")
				createPrestissimoEngineOptionsModel.SetTags([]string{"tag1", "tag2"})
				createPrestissimoEngineOptionsModel.SetVersion("1.2.3")
				createPrestissimoEngineOptionsModel.SetAuthInstanceID("testString")
				createPrestissimoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createPrestissimoEngineOptionsModel).ToNot(BeNil())
				Expect(createPrestissimoEngineOptionsModel.Origin).To(Equal(core.StringPtr("native")))
				Expect(createPrestissimoEngineOptionsModel.AssociatedCatalogs).To(Equal([]string{"hive_data"}))
				Expect(createPrestissimoEngineOptionsModel.Description).To(Equal(core.StringPtr("prestissimo engine description")))
				Expect(createPrestissimoEngineOptionsModel.EngineDetails).To(Equal(prestissimoEngineDetailsModel))
				Expect(createPrestissimoEngineOptionsModel.EngineDisplayName).To(Equal(core.StringPtr("sampleEngine")))
				Expect(createPrestissimoEngineOptionsModel.Region).To(Equal(core.StringPtr("us-south")))
				Expect(createPrestissimoEngineOptionsModel.Tags).To(Equal([]string{"tag1", "tag2"}))
				Expect(createPrestissimoEngineOptionsModel.Version).To(Equal(core.StringPtr("1.2.3")))
				Expect(createPrestissimoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createPrestissimoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreatePrestoEngineCatalogsOptions successfully`, func() {
				// Construct an instance of the CreatePrestoEngineCatalogsOptions model
				engineID := "testString"
				createPrestoEngineCatalogsOptionsModel := watsonxDataService.NewCreatePrestoEngineCatalogsOptions(engineID)
				createPrestoEngineCatalogsOptionsModel.SetEngineID("testString")
				createPrestoEngineCatalogsOptionsModel.SetCatalogNames("testString")
				createPrestoEngineCatalogsOptionsModel.SetAuthInstanceID("testString")
				createPrestoEngineCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createPrestoEngineCatalogsOptionsModel).ToNot(BeNil())
				Expect(createPrestoEngineCatalogsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(createPrestoEngineCatalogsOptionsModel.CatalogNames).To(Equal(core.StringPtr("testString")))
				Expect(createPrestoEngineCatalogsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createPrestoEngineCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreatePrestoEngineOptions successfully`, func() {
				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				Expect(nodeDescriptionBodyModel).ToNot(BeNil())
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))
				Expect(nodeDescriptionBodyModel.NodeType).To(Equal(core.StringPtr("worker")))
				Expect(nodeDescriptionBodyModel.Quantity).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the EngineDetailsBody model
				engineDetailsBodyModel := new(watsonxdatav2.EngineDetailsBody)
				Expect(engineDetailsBodyModel).ToNot(BeNil())
				engineDetailsBodyModel.ApiKey = core.StringPtr("<api_key>")
				engineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				engineDetailsBodyModel.Coordinator = nodeDescriptionBodyModel
				engineDetailsBodyModel.InstanceID = core.StringPtr("instance_id")
				engineDetailsBodyModel.ManagedBy = core.StringPtr("fully/self")
				engineDetailsBodyModel.SizeConfig = core.StringPtr("starter")
				engineDetailsBodyModel.Worker = nodeDescriptionBodyModel
				Expect(engineDetailsBodyModel.ApiKey).To(Equal(core.StringPtr("<api_key>")))
				Expect(engineDetailsBodyModel.ConnectionString).To(Equal(core.StringPtr("1.2.3.4")))
				Expect(engineDetailsBodyModel.Coordinator).To(Equal(nodeDescriptionBodyModel))
				Expect(engineDetailsBodyModel.InstanceID).To(Equal(core.StringPtr("instance_id")))
				Expect(engineDetailsBodyModel.ManagedBy).To(Equal(core.StringPtr("fully/self")))
				Expect(engineDetailsBodyModel.SizeConfig).To(Equal(core.StringPtr("starter")))
				Expect(engineDetailsBodyModel.Worker).To(Equal(nodeDescriptionBodyModel))

				// Construct an instance of the CreatePrestoEngineOptions model
				createPrestoEngineOptionsOrigin := "native"
				createPrestoEngineOptionsModel := watsonxDataService.NewCreatePrestoEngineOptions(createPrestoEngineOptionsOrigin)
				createPrestoEngineOptionsModel.SetOrigin("native")
				createPrestoEngineOptionsModel.SetAssociatedCatalogs([]string{"iceberg_data", "hive_data"})
				createPrestoEngineOptionsModel.SetDescription("presto engine for running sql queries")
				createPrestoEngineOptionsModel.SetEngineDetails(engineDetailsBodyModel)
				createPrestoEngineOptionsModel.SetEngineDisplayName("sampleEngine")
				createPrestoEngineOptionsModel.SetRegion("us-south")
				createPrestoEngineOptionsModel.SetTags([]string{"tag1", "tag2"})
				createPrestoEngineOptionsModel.SetVersion("1.2.3")
				createPrestoEngineOptionsModel.SetAuthInstanceID("testString")
				createPrestoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createPrestoEngineOptionsModel).ToNot(BeNil())
				Expect(createPrestoEngineOptionsModel.Origin).To(Equal(core.StringPtr("native")))
				Expect(createPrestoEngineOptionsModel.AssociatedCatalogs).To(Equal([]string{"iceberg_data", "hive_data"}))
				Expect(createPrestoEngineOptionsModel.Description).To(Equal(core.StringPtr("presto engine for running sql queries")))
				Expect(createPrestoEngineOptionsModel.EngineDetails).To(Equal(engineDetailsBodyModel))
				Expect(createPrestoEngineOptionsModel.EngineDisplayName).To(Equal(core.StringPtr("sampleEngine")))
				Expect(createPrestoEngineOptionsModel.Region).To(Equal(core.StringPtr("us-south")))
				Expect(createPrestoEngineOptionsModel.Tags).To(Equal([]string{"tag1", "tag2"}))
				Expect(createPrestoEngineOptionsModel.Version).To(Equal(core.StringPtr("1.2.3")))
				Expect(createPrestoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createPrestoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreatePreviewIngestionFileOptions successfully`, func() {
				// Construct an instance of the PreviewIngestionFilePrototypeCsvProperty model
				previewIngestionFilePrototypeCsvPropertyModel := new(watsonxdatav2.PreviewIngestionFilePrototypeCsvProperty)
				Expect(previewIngestionFilePrototypeCsvPropertyModel).ToNot(BeNil())
				previewIngestionFilePrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				previewIngestionFilePrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				previewIngestionFilePrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				previewIngestionFilePrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				previewIngestionFilePrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")
				Expect(previewIngestionFilePrototypeCsvPropertyModel.Encoding).To(Equal(core.StringPtr("utf-8")))
				Expect(previewIngestionFilePrototypeCsvPropertyModel.EscapeCharacter).To(Equal(core.StringPtr("\\\\")))
				Expect(previewIngestionFilePrototypeCsvPropertyModel.FieldDelimiter).To(Equal(core.StringPtr(",")))
				Expect(previewIngestionFilePrototypeCsvPropertyModel.Header).To(Equal(core.BoolPtr(true)))
				Expect(previewIngestionFilePrototypeCsvPropertyModel.LineDelimiter).To(Equal(core.StringPtr("\\n")))

				// Construct an instance of the CreatePreviewIngestionFileOptions model
				authInstanceID := "testString"
				createPreviewIngestionFileOptionsSourceDataFiles := "s3://demobucket/data/yellow_tripdata_2022-01.parquet"
				createPreviewIngestionFileOptionsModel := watsonxDataService.NewCreatePreviewIngestionFileOptions(authInstanceID, createPreviewIngestionFileOptionsSourceDataFiles)
				createPreviewIngestionFileOptionsModel.SetAuthInstanceID("testString")
				createPreviewIngestionFileOptionsModel.SetSourceDataFiles("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createPreviewIngestionFileOptionsModel.SetCsvProperty(previewIngestionFilePrototypeCsvPropertyModel)
				createPreviewIngestionFileOptionsModel.SetSourceFileType("csv")
				createPreviewIngestionFileOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createPreviewIngestionFileOptionsModel).ToNot(BeNil())
				Expect(createPreviewIngestionFileOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createPreviewIngestionFileOptionsModel.SourceDataFiles).To(Equal(core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")))
				Expect(createPreviewIngestionFileOptionsModel.CsvProperty).To(Equal(previewIngestionFilePrototypeCsvPropertyModel))
				Expect(createPreviewIngestionFileOptionsModel.SourceFileType).To(Equal(core.StringPtr("csv")))
				Expect(createPreviewIngestionFileOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateSalIntegrationEnrichmentGlobalSettingsOptions successfully`, func() {
				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration model
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration)
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel).ToNot(BeNil())
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.AssignmentThreshold = core.Float64Ptr(float64(0.14))
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.SuggestionThreshold = core.Float64Ptr(float64(0.9))
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.AssignmentThreshold).To(Equal(core.Float64Ptr(float64(0.14))))
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.SuggestionThreshold).To(Equal(core.Float64Ptr(float64(0.9))))

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration model
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration)
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel).ToNot(BeNil())
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.AssignmentThreshold = core.Float64Ptr(float64(0.1))
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.SuggestionThreshold = core.Float64Ptr(float64(0.1))
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.AssignmentThreshold).To(Equal(core.Float64Ptr(float64(0.1))))
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.SuggestionThreshold).To(Equal(core.Float64Ptr(float64(0.1))))

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansion model
				salIntegrationEnrichmentSettingsSemanticExpansionModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansion)
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionModel).ToNot(BeNil())
				salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGeneration = core.BoolPtr(true)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGenerationConfiguration = salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel
				salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansion = core.BoolPtr(true)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansionConfiguration = salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGeneration).To(Equal(core.BoolPtr(true)))
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGenerationConfiguration).To(Equal(salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel))
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansion).To(Equal(core.BoolPtr(true)))
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansionConfiguration).To(Equal(salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel))

				// Construct an instance of the SalIntegrationEnrichmentSettingsTermAssignment model
				salIntegrationEnrichmentSettingsTermAssignmentModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsTermAssignment)
				Expect(salIntegrationEnrichmentSettingsTermAssignmentModel).ToNot(BeNil())
				salIntegrationEnrichmentSettingsTermAssignmentModel.ClassBasedAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.EvaluateNegativeAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.LlmBasedAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsCustom = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsDefault = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.NameMatching = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.TermAssignmentThreshold = core.Float64Ptr(float64(0.3))
				salIntegrationEnrichmentSettingsTermAssignmentModel.TermSuggestionThreshold = core.Float64Ptr(float64(0.4))
				Expect(salIntegrationEnrichmentSettingsTermAssignmentModel.ClassBasedAssignments).To(Equal(core.BoolPtr(false)))
				Expect(salIntegrationEnrichmentSettingsTermAssignmentModel.EvaluateNegativeAssignments).To(Equal(core.BoolPtr(false)))
				Expect(salIntegrationEnrichmentSettingsTermAssignmentModel.LlmBasedAssignments).To(Equal(core.BoolPtr(false)))
				Expect(salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsCustom).To(Equal(core.BoolPtr(false)))
				Expect(salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsDefault).To(Equal(core.BoolPtr(false)))
				Expect(salIntegrationEnrichmentSettingsTermAssignmentModel.NameMatching).To(Equal(core.BoolPtr(false)))
				Expect(salIntegrationEnrichmentSettingsTermAssignmentModel.TermAssignmentThreshold).To(Equal(core.Float64Ptr(float64(0.3))))
				Expect(salIntegrationEnrichmentSettingsTermAssignmentModel.TermSuggestionThreshold).To(Equal(core.Float64Ptr(float64(0.4))))

				// Construct an instance of the CreateSalIntegrationEnrichmentGlobalSettingsOptions model
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel := watsonxDataService.NewCreateSalIntegrationEnrichmentGlobalSettingsOptions()
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.SetSemanticExpansion(salIntegrationEnrichmentSettingsSemanticExpansionModel)
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.SetTermAssignment(salIntegrationEnrichmentSettingsTermAssignmentModel)
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.SetAuthInstanceID("testString")
				createSalIntegrationEnrichmentGlobalSettingsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createSalIntegrationEnrichmentGlobalSettingsOptionsModel).ToNot(BeNil())
				Expect(createSalIntegrationEnrichmentGlobalSettingsOptionsModel.SemanticExpansion).To(Equal(salIntegrationEnrichmentSettingsSemanticExpansionModel))
				Expect(createSalIntegrationEnrichmentGlobalSettingsOptionsModel.TermAssignment).To(Equal(salIntegrationEnrichmentSettingsTermAssignmentModel))
				Expect(createSalIntegrationEnrichmentGlobalSettingsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createSalIntegrationEnrichmentGlobalSettingsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateSalIntegrationEnrichmentOptions successfully`, func() {
				// Construct an instance of the EnrichmentObj model
				enrichmentObjModel := new(watsonxdatav2.EnrichmentObj)
				Expect(enrichmentObjModel).ToNot(BeNil())
				enrichmentObjModel.Catalog = core.StringPtr("iceberg_data")
				enrichmentObjModel.Operation = core.StringPtr("create")
				enrichmentObjModel.Schema = core.StringPtr("testString")
				enrichmentObjModel.Tables = []string{"testString"}
				Expect(enrichmentObjModel.Catalog).To(Equal(core.StringPtr("iceberg_data")))
				Expect(enrichmentObjModel.Operation).To(Equal(core.StringPtr("create")))
				Expect(enrichmentObjModel.Schema).To(Equal(core.StringPtr("testString")))
				Expect(enrichmentObjModel.Tables).To(Equal([]string{"testString"}))

				// Construct an instance of the CreateSalIntegrationEnrichmentOptions model
				createSalIntegrationEnrichmentOptionsModel := watsonxDataService.NewCreateSalIntegrationEnrichmentOptions()
				createSalIntegrationEnrichmentOptionsModel.SetChanges(enrichmentObjModel)
				createSalIntegrationEnrichmentOptionsModel.SetAuthInstanceID("testString")
				createSalIntegrationEnrichmentOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createSalIntegrationEnrichmentOptionsModel).ToNot(BeNil())
				Expect(createSalIntegrationEnrichmentOptionsModel.Changes).To(Equal(enrichmentObjModel))
				Expect(createSalIntegrationEnrichmentOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createSalIntegrationEnrichmentOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateSalIntegrationEnrichmentSettingsOptions successfully`, func() {
				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration model
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration)
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel).ToNot(BeNil())
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.AssignmentThreshold = core.Float64Ptr(float64(0.14))
				salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.SuggestionThreshold = core.Float64Ptr(float64(0.9))
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.AssignmentThreshold).To(Equal(core.Float64Ptr(float64(0.14))))
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel.SuggestionThreshold).To(Equal(core.Float64Ptr(float64(0.9))))

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration model
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration)
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel).ToNot(BeNil())
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.AssignmentThreshold = core.Float64Ptr(float64(0.1))
				salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.SuggestionThreshold = core.Float64Ptr(float64(0.1))
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.AssignmentThreshold).To(Equal(core.Float64Ptr(float64(0.1))))
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel.SuggestionThreshold).To(Equal(core.Float64Ptr(float64(0.1))))

				// Construct an instance of the SalIntegrationEnrichmentSettingsSemanticExpansion model
				salIntegrationEnrichmentSettingsSemanticExpansionModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansion)
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionModel).ToNot(BeNil())
				salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGeneration = core.BoolPtr(true)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGenerationConfiguration = salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel
				salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansion = core.BoolPtr(true)
				salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansionConfiguration = salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGeneration).To(Equal(core.BoolPtr(true)))
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionModel.DescriptionGenerationConfiguration).To(Equal(salIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfigurationModel))
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansion).To(Equal(core.BoolPtr(true)))
				Expect(salIntegrationEnrichmentSettingsSemanticExpansionModel.NameExpansionConfiguration).To(Equal(salIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfigurationModel))

				// Construct an instance of the SalIntegrationEnrichmentSettingsTermAssignment model
				salIntegrationEnrichmentSettingsTermAssignmentModel := new(watsonxdatav2.SalIntegrationEnrichmentSettingsTermAssignment)
				Expect(salIntegrationEnrichmentSettingsTermAssignmentModel).ToNot(BeNil())
				salIntegrationEnrichmentSettingsTermAssignmentModel.ClassBasedAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.EvaluateNegativeAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.LlmBasedAssignments = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsCustom = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsDefault = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.NameMatching = core.BoolPtr(false)
				salIntegrationEnrichmentSettingsTermAssignmentModel.TermAssignmentThreshold = core.Float64Ptr(float64(0.3))
				salIntegrationEnrichmentSettingsTermAssignmentModel.TermSuggestionThreshold = core.Float64Ptr(float64(0.4))
				Expect(salIntegrationEnrichmentSettingsTermAssignmentModel.ClassBasedAssignments).To(Equal(core.BoolPtr(false)))
				Expect(salIntegrationEnrichmentSettingsTermAssignmentModel.EvaluateNegativeAssignments).To(Equal(core.BoolPtr(false)))
				Expect(salIntegrationEnrichmentSettingsTermAssignmentModel.LlmBasedAssignments).To(Equal(core.BoolPtr(false)))
				Expect(salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsCustom).To(Equal(core.BoolPtr(false)))
				Expect(salIntegrationEnrichmentSettingsTermAssignmentModel.MlBasedAssignmentsDefault).To(Equal(core.BoolPtr(false)))
				Expect(salIntegrationEnrichmentSettingsTermAssignmentModel.NameMatching).To(Equal(core.BoolPtr(false)))
				Expect(salIntegrationEnrichmentSettingsTermAssignmentModel.TermAssignmentThreshold).To(Equal(core.Float64Ptr(float64(0.3))))
				Expect(salIntegrationEnrichmentSettingsTermAssignmentModel.TermSuggestionThreshold).To(Equal(core.Float64Ptr(float64(0.4))))

				// Construct an instance of the CreateSalIntegrationEnrichmentSettingsOptions model
				createSalIntegrationEnrichmentSettingsOptionsModel := watsonxDataService.NewCreateSalIntegrationEnrichmentSettingsOptions()
				createSalIntegrationEnrichmentSettingsOptionsModel.SetSemanticExpansion(salIntegrationEnrichmentSettingsSemanticExpansionModel)
				createSalIntegrationEnrichmentSettingsOptionsModel.SetTermAssignment(salIntegrationEnrichmentSettingsTermAssignmentModel)
				createSalIntegrationEnrichmentSettingsOptionsModel.SetProjectID("testString")
				createSalIntegrationEnrichmentSettingsOptionsModel.SetAuthInstanceID("testString")
				createSalIntegrationEnrichmentSettingsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createSalIntegrationEnrichmentSettingsOptionsModel).ToNot(BeNil())
				Expect(createSalIntegrationEnrichmentSettingsOptionsModel.SemanticExpansion).To(Equal(salIntegrationEnrichmentSettingsSemanticExpansionModel))
				Expect(createSalIntegrationEnrichmentSettingsOptionsModel.TermAssignment).To(Equal(salIntegrationEnrichmentSettingsTermAssignmentModel))
				Expect(createSalIntegrationEnrichmentSettingsOptionsModel.ProjectID).To(Equal(core.StringPtr("testString")))
				Expect(createSalIntegrationEnrichmentSettingsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createSalIntegrationEnrichmentSettingsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateSalIntegrationOptions successfully`, func() {
				// Construct an instance of the CreateSalIntegrationOptions model
				createSalIntegrationOptionsApikey := "12efd3raq"
				createSalIntegrationOptionsEngineID := "presto-01"
				createSalIntegrationOptionsModel := watsonxDataService.NewCreateSalIntegrationOptions(createSalIntegrationOptionsApikey, createSalIntegrationOptionsEngineID)
				createSalIntegrationOptionsModel.SetApikey("12efd3raq")
				createSalIntegrationOptionsModel.SetEngineID("presto-01")
				createSalIntegrationOptionsModel.SetStorageResourceCrn("crn:v1:staging:public:cloud-object-storage:global:a/a7026b374f39f570d20984c1ac6ecf63:5778e94f-c8c7-46a8-9878-d5eeadb51161")
				createSalIntegrationOptionsModel.SetStorageType("bmcos_object_storage")
				createSalIntegrationOptionsModel.SetTrialPlan(true)
				createSalIntegrationOptionsModel.SetAuthInstanceID("testString")
				createSalIntegrationOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createSalIntegrationOptionsModel).ToNot(BeNil())
				Expect(createSalIntegrationOptionsModel.Apikey).To(Equal(core.StringPtr("12efd3raq")))
				Expect(createSalIntegrationOptionsModel.EngineID).To(Equal(core.StringPtr("presto-01")))
				Expect(createSalIntegrationOptionsModel.StorageResourceCrn).To(Equal(core.StringPtr("crn:v1:staging:public:cloud-object-storage:global:a/a7026b374f39f570d20984c1ac6ecf63:5778e94f-c8c7-46a8-9878-d5eeadb51161")))
				Expect(createSalIntegrationOptionsModel.StorageType).To(Equal(core.StringPtr("bmcos_object_storage")))
				Expect(createSalIntegrationOptionsModel.TrialPlan).To(Equal(core.BoolPtr(true)))
				Expect(createSalIntegrationOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createSalIntegrationOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateSalIntegrationUploadGlossaryOptions successfully`, func() {
				// Construct an instance of the CreateSalIntegrationUploadGlossaryOptions model
				replaceOption := "all"
				createSalIntegrationUploadGlossaryOptionsModel := watsonxDataService.NewCreateSalIntegrationUploadGlossaryOptions(replaceOption)
				createSalIntegrationUploadGlossaryOptionsModel.SetReplaceOption("all")
				createSalIntegrationUploadGlossaryOptionsModel.SetGlossaryCsv(CreateMockReader("This is a mock file."))
				createSalIntegrationUploadGlossaryOptionsModel.SetGlossaryCsvContentType("testString")
				createSalIntegrationUploadGlossaryOptionsModel.SetAuthInstanceID("testString")
				createSalIntegrationUploadGlossaryOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createSalIntegrationUploadGlossaryOptionsModel).ToNot(BeNil())
				Expect(createSalIntegrationUploadGlossaryOptionsModel.ReplaceOption).To(Equal(core.StringPtr("all")))
				Expect(createSalIntegrationUploadGlossaryOptionsModel.GlossaryCsv).To(Equal(CreateMockReader("This is a mock file.")))
				Expect(createSalIntegrationUploadGlossaryOptionsModel.GlossaryCsvContentType).To(Equal(core.StringPtr("testString")))
				Expect(createSalIntegrationUploadGlossaryOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createSalIntegrationUploadGlossaryOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateSchemaOptions successfully`, func() {
				// Construct an instance of the CreateSchemaOptions model
				engineID := "testString"
				catalogID := "testString"
				createSchemaOptionsCustomPath := "sample-path"
				createSchemaOptionsSchemaName := "SampleSchema1"
				createSchemaOptionsModel := watsonxDataService.NewCreateSchemaOptions(engineID, catalogID, createSchemaOptionsCustomPath, createSchemaOptionsSchemaName)
				createSchemaOptionsModel.SetEngineID("testString")
				createSchemaOptionsModel.SetCatalogID("testString")
				createSchemaOptionsModel.SetCustomPath("sample-path")
				createSchemaOptionsModel.SetSchemaName("SampleSchema1")
				createSchemaOptionsModel.SetBucketName("sample-bucket")
				createSchemaOptionsModel.SetHostname("db2@hostname.com")
				createSchemaOptionsModel.SetPort(int64(4553))
				createSchemaOptionsModel.SetAuthInstanceID("testString")
				createSchemaOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createSchemaOptionsModel).ToNot(BeNil())
				Expect(createSchemaOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(createSchemaOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(createSchemaOptionsModel.CustomPath).To(Equal(core.StringPtr("sample-path")))
				Expect(createSchemaOptionsModel.SchemaName).To(Equal(core.StringPtr("SampleSchema1")))
				Expect(createSchemaOptionsModel.BucketName).To(Equal(core.StringPtr("sample-bucket")))
				Expect(createSchemaOptionsModel.Hostname).To(Equal(core.StringPtr("db2@hostname.com")))
				Expect(createSchemaOptionsModel.Port).To(Equal(core.Int64Ptr(int64(4553))))
				Expect(createSchemaOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createSchemaOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateSparkEngineApplicationOptions successfully`, func() {
				// Construct an instance of the SparkApplicationConfig model
				sparkApplicationConfigModel := new(watsonxdatav2.SparkApplicationConfig)
				Expect(sparkApplicationConfigModel).ToNot(BeNil())
				sparkApplicationConfigModel.SparkSampleConfigProperpty = core.StringPtr("testString")
				Expect(sparkApplicationConfigModel.SparkSampleConfigProperpty).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SparkApplicationEnv model
				sparkApplicationEnvModel := new(watsonxdatav2.SparkApplicationEnv)
				Expect(sparkApplicationEnvModel).ToNot(BeNil())
				sparkApplicationEnvModel.SampleEnvKey = core.StringPtr("testString")
				Expect(sparkApplicationEnvModel.SampleEnvKey).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SparkApplicationDetailsRuntime model
				sparkApplicationDetailsRuntimeModel := new(watsonxdatav2.SparkApplicationDetailsRuntime)
				Expect(sparkApplicationDetailsRuntimeModel).ToNot(BeNil())
				sparkApplicationDetailsRuntimeModel.SparkVersion = core.StringPtr("3.4")
				Expect(sparkApplicationDetailsRuntimeModel.SparkVersion).To(Equal(core.StringPtr("3.4")))

				// Construct an instance of the SparkApplicationDetails model
				sparkApplicationDetailsModel := new(watsonxdatav2.SparkApplicationDetails)
				Expect(sparkApplicationDetailsModel).ToNot(BeNil())
				sparkApplicationDetailsModel.Application = core.StringPtr("/opt/ibm/spark/examples/src/main/python/wordcount.py")
				sparkApplicationDetailsModel.Arguments = []string{"/opt/ibm/spark/examples/src/main/resources/people.txt"}
				sparkApplicationDetailsModel.Class = core.StringPtr("org.apache.spark.examples.SparkPi")
				sparkApplicationDetailsModel.Conf = sparkApplicationConfigModel
				sparkApplicationDetailsModel.Env = sparkApplicationEnvModel
				sparkApplicationDetailsModel.Files = core.StringPtr("s3://mybucket/myfile.txt")
				sparkApplicationDetailsModel.Jars = core.StringPtr("testString")
				sparkApplicationDetailsModel.Name = core.StringPtr("SparkApplicaton1")
				sparkApplicationDetailsModel.Packages = core.StringPtr("org.apache.spark:example_1.2.3")
				sparkApplicationDetailsModel.Repositories = core.StringPtr("https://repo1.maven.org/maven2/")
				sparkApplicationDetailsModel.SparkVersion = core.StringPtr("3.3")
				sparkApplicationDetailsModel.Runtime = sparkApplicationDetailsRuntimeModel
				Expect(sparkApplicationDetailsModel.Application).To(Equal(core.StringPtr("/opt/ibm/spark/examples/src/main/python/wordcount.py")))
				Expect(sparkApplicationDetailsModel.Arguments).To(Equal([]string{"/opt/ibm/spark/examples/src/main/resources/people.txt"}))
				Expect(sparkApplicationDetailsModel.Class).To(Equal(core.StringPtr("org.apache.spark.examples.SparkPi")))
				Expect(sparkApplicationDetailsModel.Conf).To(Equal(sparkApplicationConfigModel))
				Expect(sparkApplicationDetailsModel.Env).To(Equal(sparkApplicationEnvModel))
				Expect(sparkApplicationDetailsModel.Files).To(Equal(core.StringPtr("s3://mybucket/myfile.txt")))
				Expect(sparkApplicationDetailsModel.Jars).To(Equal(core.StringPtr("testString")))
				Expect(sparkApplicationDetailsModel.Name).To(Equal(core.StringPtr("SparkApplicaton1")))
				Expect(sparkApplicationDetailsModel.Packages).To(Equal(core.StringPtr("org.apache.spark:example_1.2.3")))
				Expect(sparkApplicationDetailsModel.Repositories).To(Equal(core.StringPtr("https://repo1.maven.org/maven2/")))
				Expect(sparkApplicationDetailsModel.SparkVersion).To(Equal(core.StringPtr("3.3")))
				Expect(sparkApplicationDetailsModel.Runtime).To(Equal(sparkApplicationDetailsRuntimeModel))

				// Construct an instance of the SparkVolumeDetails model
				sparkVolumeDetailsModel := new(watsonxdatav2.SparkVolumeDetails)
				Expect(sparkVolumeDetailsModel).ToNot(BeNil())
				sparkVolumeDetailsModel.MountPath = core.StringPtr("/mount/path")
				sparkVolumeDetailsModel.Name = core.StringPtr("my-volume")
				sparkVolumeDetailsModel.ReadOnly = core.BoolPtr(true)
				sparkVolumeDetailsModel.SourceSubPath = core.StringPtr("/source/path")
				Expect(sparkVolumeDetailsModel.MountPath).To(Equal(core.StringPtr("/mount/path")))
				Expect(sparkVolumeDetailsModel.Name).To(Equal(core.StringPtr("my-volume")))
				Expect(sparkVolumeDetailsModel.ReadOnly).To(Equal(core.BoolPtr(true)))
				Expect(sparkVolumeDetailsModel.SourceSubPath).To(Equal(core.StringPtr("/source/path")))

				// Construct an instance of the CreateSparkEngineApplicationOptions model
				engineID := "testString"
				var createSparkEngineApplicationOptionsApplicationDetails *watsonxdatav2.SparkApplicationDetails = nil
				createSparkEngineApplicationOptionsModel := watsonxDataService.NewCreateSparkEngineApplicationOptions(engineID, createSparkEngineApplicationOptionsApplicationDetails)
				createSparkEngineApplicationOptionsModel.SetEngineID("testString")
				createSparkEngineApplicationOptionsModel.SetApplicationDetails(sparkApplicationDetailsModel)
				createSparkEngineApplicationOptionsModel.SetJobEndpoint("testString")
				createSparkEngineApplicationOptionsModel.SetServiceInstanceID("testString")
				createSparkEngineApplicationOptionsModel.SetType("iae")
				createSparkEngineApplicationOptionsModel.SetVolumes([]watsonxdatav2.SparkVolumeDetails{*sparkVolumeDetailsModel})
				createSparkEngineApplicationOptionsModel.SetAuthInstanceID("testString")
				createSparkEngineApplicationOptionsModel.SetState([]string{"testString"})
				createSparkEngineApplicationOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createSparkEngineApplicationOptionsModel).ToNot(BeNil())
				Expect(createSparkEngineApplicationOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEngineApplicationOptionsModel.ApplicationDetails).To(Equal(sparkApplicationDetailsModel))
				Expect(createSparkEngineApplicationOptionsModel.JobEndpoint).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEngineApplicationOptionsModel.ServiceInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEngineApplicationOptionsModel.Type).To(Equal(core.StringPtr("iae")))
				Expect(createSparkEngineApplicationOptionsModel.Volumes).To(Equal([]watsonxdatav2.SparkVolumeDetails{*sparkVolumeDetailsModel}))
				Expect(createSparkEngineApplicationOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEngineApplicationOptionsModel.State).To(Equal([]string{"testString"}))
				Expect(createSparkEngineApplicationOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateSparkEngineCatalogsOptions successfully`, func() {
				// Construct an instance of the CreateSparkEngineCatalogsOptions model
				engineID := "testString"
				createSparkEngineCatalogsOptionsModel := watsonxDataService.NewCreateSparkEngineCatalogsOptions(engineID)
				createSparkEngineCatalogsOptionsModel.SetEngineID("testString")
				createSparkEngineCatalogsOptionsModel.SetCatalogNames("testString")
				createSparkEngineCatalogsOptionsModel.SetAuthInstanceID("testString")
				createSparkEngineCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createSparkEngineCatalogsOptionsModel).ToNot(BeNil())
				Expect(createSparkEngineCatalogsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEngineCatalogsOptionsModel.CatalogNames).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEngineCatalogsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEngineCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateSparkEngineOptions successfully`, func() {
				// Construct an instance of the SparkDefaultConfig model
				sparkDefaultConfigModel := new(watsonxdatav2.SparkDefaultConfig)
				Expect(sparkDefaultConfigModel).ToNot(BeNil())
				sparkDefaultConfigModel.Config1 = core.StringPtr("testString")
				sparkDefaultConfigModel.Config2 = core.StringPtr("testString")
				Expect(sparkDefaultConfigModel.Config1).To(Equal(core.StringPtr("testString")))
				Expect(sparkDefaultConfigModel.Config2).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SparkScaleConfig model
				sparkScaleConfigModel := new(watsonxdatav2.SparkScaleConfig)
				Expect(sparkScaleConfigModel).ToNot(BeNil())
				sparkScaleConfigModel.AutoScaleEnabled = core.BoolPtr(true)
				sparkScaleConfigModel.CurrentNumberOfNodes = core.Int64Ptr(int64(2))
				sparkScaleConfigModel.MaximumNumberOfNodes = core.Int64Ptr(int64(5))
				sparkScaleConfigModel.MinimumNumberOfNodes = core.Int64Ptr(int64(1))
				sparkScaleConfigModel.NodeType = core.StringPtr("small")
				sparkScaleConfigModel.NumberOfNodes = core.Int64Ptr(int64(5))
				Expect(sparkScaleConfigModel.AutoScaleEnabled).To(Equal(core.BoolPtr(true)))
				Expect(sparkScaleConfigModel.CurrentNumberOfNodes).To(Equal(core.Int64Ptr(int64(2))))
				Expect(sparkScaleConfigModel.MaximumNumberOfNodes).To(Equal(core.Int64Ptr(int64(5))))
				Expect(sparkScaleConfigModel.MinimumNumberOfNodes).To(Equal(core.Int64Ptr(int64(1))))
				Expect(sparkScaleConfigModel.NodeType).To(Equal(core.StringPtr("small")))
				Expect(sparkScaleConfigModel.NumberOfNodes).To(Equal(core.Int64Ptr(int64(5))))

				// Construct an instance of the SparkEngineDetailsPrototype model
				sparkEngineDetailsPrototypeModel := new(watsonxdatav2.SparkEngineDetailsPrototype)
				Expect(sparkEngineDetailsPrototypeModel).ToNot(BeNil())
				sparkEngineDetailsPrototypeModel.ApiKey = core.StringPtr("apikey")
				sparkEngineDetailsPrototypeModel.ConnectionString = core.StringPtr("1.2.3.4")
				sparkEngineDetailsPrototypeModel.DefaultConfig = sparkDefaultConfigModel
				sparkEngineDetailsPrototypeModel.DefaultVersion = core.StringPtr("3.3")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketDisplayName = core.StringPtr("test-spark-bucket")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketName = core.StringPtr("4fec0f8b-888a-4c16-8f38-250c8499e6ce-customer")
				sparkEngineDetailsPrototypeModel.EngineHomePath = core.StringPtr("spark/spark1234")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeID = core.StringPtr("1704979825978585")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeName = core.StringPtr("my-volume")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageClass = core.StringPtr("nfs-client")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageSize = core.StringPtr("5Gi")
				sparkEngineDetailsPrototypeModel.InstanceID = core.StringPtr("spark-id")
				sparkEngineDetailsPrototypeModel.EngineSubType = core.StringPtr("java/cpp")
				sparkEngineDetailsPrototypeModel.ManagedBy = core.StringPtr("fully/self")
				sparkEngineDetailsPrototypeModel.ScaleConfig = sparkScaleConfigModel
				Expect(sparkEngineDetailsPrototypeModel.ApiKey).To(Equal(core.StringPtr("apikey")))
				Expect(sparkEngineDetailsPrototypeModel.ConnectionString).To(Equal(core.StringPtr("1.2.3.4")))
				Expect(sparkEngineDetailsPrototypeModel.DefaultConfig).To(Equal(sparkDefaultConfigModel))
				Expect(sparkEngineDetailsPrototypeModel.DefaultVersion).To(Equal(core.StringPtr("3.3")))
				Expect(sparkEngineDetailsPrototypeModel.EngineHomeBucketDisplayName).To(Equal(core.StringPtr("test-spark-bucket")))
				Expect(sparkEngineDetailsPrototypeModel.EngineHomeBucketName).To(Equal(core.StringPtr("4fec0f8b-888a-4c16-8f38-250c8499e6ce-customer")))
				Expect(sparkEngineDetailsPrototypeModel.EngineHomePath).To(Equal(core.StringPtr("spark/spark1234")))
				Expect(sparkEngineDetailsPrototypeModel.EngineHomeVolumeID).To(Equal(core.StringPtr("1704979825978585")))
				Expect(sparkEngineDetailsPrototypeModel.EngineHomeVolumeName).To(Equal(core.StringPtr("my-volume")))
				Expect(sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageClass).To(Equal(core.StringPtr("nfs-client")))
				Expect(sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageSize).To(Equal(core.StringPtr("5Gi")))
				Expect(sparkEngineDetailsPrototypeModel.InstanceID).To(Equal(core.StringPtr("spark-id")))
				Expect(sparkEngineDetailsPrototypeModel.EngineSubType).To(Equal(core.StringPtr("java/cpp")))
				Expect(sparkEngineDetailsPrototypeModel.ManagedBy).To(Equal(core.StringPtr("fully/self")))
				Expect(sparkEngineDetailsPrototypeModel.ScaleConfig).To(Equal(sparkScaleConfigModel))

				// Construct an instance of the CreateSparkEngineOptions model
				createSparkEngineOptionsOrigin := "native"
				createSparkEngineOptionsModel := watsonxDataService.NewCreateSparkEngineOptions(createSparkEngineOptionsOrigin)
				createSparkEngineOptionsModel.SetOrigin("native")
				createSparkEngineOptionsModel.SetAssociatedCatalogs([]string{"iceberg_data"})
				createSparkEngineOptionsModel.SetDescription("testString")
				createSparkEngineOptionsModel.SetEngineDetails(sparkEngineDetailsPrototypeModel)
				createSparkEngineOptionsModel.SetEngineDisplayName("test-native")
				createSparkEngineOptionsModel.SetStatus("testString")
				createSparkEngineOptionsModel.SetTags([]string{"testString"})
				createSparkEngineOptionsModel.SetAuthInstanceID("testString")
				createSparkEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createSparkEngineOptionsModel).ToNot(BeNil())
				Expect(createSparkEngineOptionsModel.Origin).To(Equal(core.StringPtr("native")))
				Expect(createSparkEngineOptionsModel.AssociatedCatalogs).To(Equal([]string{"iceberg_data"}))
				Expect(createSparkEngineOptionsModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEngineOptionsModel.EngineDetails).To(Equal(sparkEngineDetailsPrototypeModel))
				Expect(createSparkEngineOptionsModel.EngineDisplayName).To(Equal(core.StringPtr("test-native")))
				Expect(createSparkEngineOptionsModel.Status).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEngineOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(createSparkEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems successfully`, func() {
				encrypt := true
				key := "hive.metastore"
				value := "glue"
				_model, err := watsonxDataService.NewDatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems(encrypt, key, value)
				Expect(_model).ToNot(BeNil())
				Expect(err).To(BeNil())
			})
			It(`Invoke NewDatabaseRegistrationPrototypeDatabasePropertiesItems successfully`, func() {
				encrypt := true
				key := "hive.metastore"
				value := "glue"
				_model, err := watsonxDataService.NewDatabaseRegistrationPrototypeDatabasePropertiesItems(encrypt, key, value)
				Expect(_model).ToNot(BeNil())
				Expect(err).To(BeNil())
			})
			It(`Invoke NewDeleteBucketRegistrationOptions successfully`, func() {
				// Construct an instance of the DeleteBucketRegistrationOptions model
				bucketID := "testString"
				deleteBucketRegistrationOptionsModel := watsonxDataService.NewDeleteBucketRegistrationOptions(bucketID)
				deleteBucketRegistrationOptionsModel.SetBucketID("testString")
				deleteBucketRegistrationOptionsModel.SetAuthInstanceID("testString")
				deleteBucketRegistrationOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteBucketRegistrationOptionsModel).ToNot(BeNil())
				Expect(deleteBucketRegistrationOptionsModel.BucketID).To(Equal(core.StringPtr("testString")))
				Expect(deleteBucketRegistrationOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteBucketRegistrationOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteColumnOptions successfully`, func() {
				// Construct an instance of the DeleteColumnOptions model
				engineID := "testString"
				catalogID := "testString"
				schemaID := "testString"
				tableID := "testString"
				columnID := "testString"
				deleteColumnOptionsModel := watsonxDataService.NewDeleteColumnOptions(engineID, catalogID, schemaID, tableID, columnID)
				deleteColumnOptionsModel.SetEngineID("testString")
				deleteColumnOptionsModel.SetCatalogID("testString")
				deleteColumnOptionsModel.SetSchemaID("testString")
				deleteColumnOptionsModel.SetTableID("testString")
				deleteColumnOptionsModel.SetColumnID("testString")
				deleteColumnOptionsModel.SetAuthInstanceID("testString")
				deleteColumnOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteColumnOptionsModel).ToNot(BeNil())
				Expect(deleteColumnOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteColumnOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(deleteColumnOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(deleteColumnOptionsModel.TableID).To(Equal(core.StringPtr("testString")))
				Expect(deleteColumnOptionsModel.ColumnID).To(Equal(core.StringPtr("testString")))
				Expect(deleteColumnOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteColumnOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteDatabaseCatalogOptions successfully`, func() {
				// Construct an instance of the DeleteDatabaseCatalogOptions model
				databaseID := "testString"
				deleteDatabaseCatalogOptionsModel := watsonxDataService.NewDeleteDatabaseCatalogOptions(databaseID)
				deleteDatabaseCatalogOptionsModel.SetDatabaseID("testString")
				deleteDatabaseCatalogOptionsModel.SetAuthInstanceID("testString")
				deleteDatabaseCatalogOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteDatabaseCatalogOptionsModel).ToNot(BeNil())
				Expect(deleteDatabaseCatalogOptionsModel.DatabaseID).To(Equal(core.StringPtr("testString")))
				Expect(deleteDatabaseCatalogOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteDatabaseCatalogOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteDb2EngineOptions successfully`, func() {
				// Construct an instance of the DeleteDb2EngineOptions model
				engineID := "testString"
				deleteDb2EngineOptionsModel := watsonxDataService.NewDeleteDb2EngineOptions(engineID)
				deleteDb2EngineOptionsModel.SetEngineID("testString")
				deleteDb2EngineOptionsModel.SetAuthInstanceID("testString")
				deleteDb2EngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteDb2EngineOptionsModel).ToNot(BeNil())
				Expect(deleteDb2EngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteDb2EngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteDb2EngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteDeactivateBucketOptions successfully`, func() {
				// Construct an instance of the DeleteDeactivateBucketOptions model
				bucketID := "testString"
				deleteDeactivateBucketOptionsModel := watsonxDataService.NewDeleteDeactivateBucketOptions(bucketID)
				deleteDeactivateBucketOptionsModel.SetBucketID("testString")
				deleteDeactivateBucketOptionsModel.SetAuthInstanceID("testString")
				deleteDeactivateBucketOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteDeactivateBucketOptionsModel).ToNot(BeNil())
				Expect(deleteDeactivateBucketOptionsModel.BucketID).To(Equal(core.StringPtr("testString")))
				Expect(deleteDeactivateBucketOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteDeactivateBucketOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteEngineOptions successfully`, func() {
				// Construct an instance of the DeleteEngineOptions model
				engineID := "testString"
				deleteEngineOptionsModel := watsonxDataService.NewDeleteEngineOptions(engineID)
				deleteEngineOptionsModel.SetEngineID("testString")
				deleteEngineOptionsModel.SetAuthInstanceID("testString")
				deleteEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteEngineOptionsModel).ToNot(BeNil())
				Expect(deleteEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteIngestionJobsOptions successfully`, func() {
				// Construct an instance of the DeleteIngestionJobsOptions model
				jobID := "testString"
				authInstanceID := "testString"
				deleteIngestionJobsOptionsModel := watsonxDataService.NewDeleteIngestionJobsOptions(jobID, authInstanceID)
				deleteIngestionJobsOptionsModel.SetJobID("testString")
				deleteIngestionJobsOptionsModel.SetAuthInstanceID("testString")
				deleteIngestionJobsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteIngestionJobsOptionsModel).ToNot(BeNil())
				Expect(deleteIngestionJobsOptionsModel.JobID).To(Equal(core.StringPtr("testString")))
				Expect(deleteIngestionJobsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteIngestionJobsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteIntegrationOptions successfully`, func() {
				// Construct an instance of the DeleteIntegrationOptions model
				integrationID := "testString"
				deleteIntegrationOptionsModel := watsonxDataService.NewDeleteIntegrationOptions(integrationID)
				deleteIntegrationOptionsModel.SetIntegrationID("testString")
				deleteIntegrationOptionsModel.SetAuthInstanceID("testString")
				deleteIntegrationOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteIntegrationOptionsModel).ToNot(BeNil())
				Expect(deleteIntegrationOptionsModel.IntegrationID).To(Equal(core.StringPtr("testString")))
				Expect(deleteIntegrationOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteIntegrationOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteMilvusServiceOptions successfully`, func() {
				// Construct an instance of the DeleteMilvusServiceOptions model
				serviceID := "testString"
				deleteMilvusServiceOptionsModel := watsonxDataService.NewDeleteMilvusServiceOptions(serviceID)
				deleteMilvusServiceOptionsModel.SetServiceID("testString")
				deleteMilvusServiceOptionsModel.SetAuthInstanceID("testString")
				deleteMilvusServiceOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteMilvusServiceOptionsModel).ToNot(BeNil())
				Expect(deleteMilvusServiceOptionsModel.ServiceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteMilvusServiceOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteMilvusServiceOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteNetezzaEngineOptions successfully`, func() {
				// Construct an instance of the DeleteNetezzaEngineOptions model
				engineID := "testString"
				deleteNetezzaEngineOptionsModel := watsonxDataService.NewDeleteNetezzaEngineOptions(engineID)
				deleteNetezzaEngineOptionsModel.SetEngineID("testString")
				deleteNetezzaEngineOptionsModel.SetAuthInstanceID("testString")
				deleteNetezzaEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteNetezzaEngineOptionsModel).ToNot(BeNil())
				Expect(deleteNetezzaEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteNetezzaEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteNetezzaEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteOtherEngineOptions successfully`, func() {
				// Construct an instance of the DeleteOtherEngineOptions model
				engineID := "testString"
				deleteOtherEngineOptionsModel := watsonxDataService.NewDeleteOtherEngineOptions(engineID)
				deleteOtherEngineOptionsModel.SetEngineID("testString")
				deleteOtherEngineOptionsModel.SetAuthInstanceID("testString")
				deleteOtherEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteOtherEngineOptionsModel).ToNot(BeNil())
				Expect(deleteOtherEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteOtherEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteOtherEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeletePrestissimoEngineCatalogsOptions successfully`, func() {
				// Construct an instance of the DeletePrestissimoEngineCatalogsOptions model
				engineID := "testString"
				catalogNames := "testString"
				deletePrestissimoEngineCatalogsOptionsModel := watsonxDataService.NewDeletePrestissimoEngineCatalogsOptions(engineID, catalogNames)
				deletePrestissimoEngineCatalogsOptionsModel.SetEngineID("testString")
				deletePrestissimoEngineCatalogsOptionsModel.SetCatalogNames("testString")
				deletePrestissimoEngineCatalogsOptionsModel.SetAuthInstanceID("testString")
				deletePrestissimoEngineCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deletePrestissimoEngineCatalogsOptionsModel).ToNot(BeNil())
				Expect(deletePrestissimoEngineCatalogsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deletePrestissimoEngineCatalogsOptionsModel.CatalogNames).To(Equal(core.StringPtr("testString")))
				Expect(deletePrestissimoEngineCatalogsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deletePrestissimoEngineCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeletePrestissimoEngineOptions successfully`, func() {
				// Construct an instance of the DeletePrestissimoEngineOptions model
				engineID := "testString"
				deletePrestissimoEngineOptionsModel := watsonxDataService.NewDeletePrestissimoEngineOptions(engineID)
				deletePrestissimoEngineOptionsModel.SetEngineID("testString")
				deletePrestissimoEngineOptionsModel.SetAuthInstanceID("testString")
				deletePrestissimoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deletePrestissimoEngineOptionsModel).ToNot(BeNil())
				Expect(deletePrestissimoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deletePrestissimoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deletePrestissimoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeletePrestoEngineCatalogsOptions successfully`, func() {
				// Construct an instance of the DeletePrestoEngineCatalogsOptions model
				engineID := "testString"
				catalogNames := "testString"
				deletePrestoEngineCatalogsOptionsModel := watsonxDataService.NewDeletePrestoEngineCatalogsOptions(engineID, catalogNames)
				deletePrestoEngineCatalogsOptionsModel.SetEngineID("testString")
				deletePrestoEngineCatalogsOptionsModel.SetCatalogNames("testString")
				deletePrestoEngineCatalogsOptionsModel.SetAuthInstanceID("testString")
				deletePrestoEngineCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deletePrestoEngineCatalogsOptionsModel).ToNot(BeNil())
				Expect(deletePrestoEngineCatalogsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deletePrestoEngineCatalogsOptionsModel.CatalogNames).To(Equal(core.StringPtr("testString")))
				Expect(deletePrestoEngineCatalogsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deletePrestoEngineCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteSalIntegrationOptions successfully`, func() {
				// Construct an instance of the DeleteSalIntegrationOptions model
				deleteSalIntegrationOptionsModel := watsonxDataService.NewDeleteSalIntegrationOptions()
				deleteSalIntegrationOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteSalIntegrationOptionsModel).ToNot(BeNil())
				Expect(deleteSalIntegrationOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteSchemaOptions successfully`, func() {
				// Construct an instance of the DeleteSchemaOptions model
				engineID := "testString"
				catalogID := "testString"
				schemaID := "testString"
				deleteSchemaOptionsModel := watsonxDataService.NewDeleteSchemaOptions(engineID, catalogID, schemaID)
				deleteSchemaOptionsModel.SetEngineID("testString")
				deleteSchemaOptionsModel.SetCatalogID("testString")
				deleteSchemaOptionsModel.SetSchemaID("testString")
				deleteSchemaOptionsModel.SetAuthInstanceID("testString")
				deleteSchemaOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteSchemaOptionsModel).ToNot(BeNil())
				Expect(deleteSchemaOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSchemaOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSchemaOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSchemaOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSchemaOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteSparkEngineApplicationsOptions successfully`, func() {
				// Construct an instance of the DeleteSparkEngineApplicationsOptions model
				engineID := "testString"
				applicationID := "testString"
				deleteSparkEngineApplicationsOptionsModel := watsonxDataService.NewDeleteSparkEngineApplicationsOptions(engineID, applicationID)
				deleteSparkEngineApplicationsOptionsModel.SetEngineID("testString")
				deleteSparkEngineApplicationsOptionsModel.SetApplicationID("testString")
				deleteSparkEngineApplicationsOptionsModel.SetAuthInstanceID("testString")
				deleteSparkEngineApplicationsOptionsModel.SetState([]string{"testString"})
				deleteSparkEngineApplicationsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteSparkEngineApplicationsOptionsModel).ToNot(BeNil())
				Expect(deleteSparkEngineApplicationsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSparkEngineApplicationsOptionsModel.ApplicationID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSparkEngineApplicationsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSparkEngineApplicationsOptionsModel.State).To(Equal([]string{"testString"}))
				Expect(deleteSparkEngineApplicationsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteSparkEngineCatalogsOptions successfully`, func() {
				// Construct an instance of the DeleteSparkEngineCatalogsOptions model
				engineID := "testString"
				catalogNames := "testString"
				deleteSparkEngineCatalogsOptionsModel := watsonxDataService.NewDeleteSparkEngineCatalogsOptions(engineID, catalogNames)
				deleteSparkEngineCatalogsOptionsModel.SetEngineID("testString")
				deleteSparkEngineCatalogsOptionsModel.SetCatalogNames("testString")
				deleteSparkEngineCatalogsOptionsModel.SetAuthInstanceID("testString")
				deleteSparkEngineCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteSparkEngineCatalogsOptionsModel).ToNot(BeNil())
				Expect(deleteSparkEngineCatalogsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSparkEngineCatalogsOptionsModel.CatalogNames).To(Equal(core.StringPtr("testString")))
				Expect(deleteSparkEngineCatalogsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSparkEngineCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteSparkEngineHistoryServerOptions successfully`, func() {
				// Construct an instance of the DeleteSparkEngineHistoryServerOptions model
				engineID := "testString"
				deleteSparkEngineHistoryServerOptionsModel := watsonxDataService.NewDeleteSparkEngineHistoryServerOptions(engineID)
				deleteSparkEngineHistoryServerOptionsModel.SetEngineID("testString")
				deleteSparkEngineHistoryServerOptionsModel.SetAuthInstanceID("testString")
				deleteSparkEngineHistoryServerOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteSparkEngineHistoryServerOptionsModel).ToNot(BeNil())
				Expect(deleteSparkEngineHistoryServerOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSparkEngineHistoryServerOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSparkEngineHistoryServerOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteSparkEngineOptions successfully`, func() {
				// Construct an instance of the DeleteSparkEngineOptions model
				engineID := "testString"
				deleteSparkEngineOptionsModel := watsonxDataService.NewDeleteSparkEngineOptions(engineID)
				deleteSparkEngineOptionsModel.SetEngineID("testString")
				deleteSparkEngineOptionsModel.SetAuthInstanceID("testString")
				deleteSparkEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteSparkEngineOptionsModel).ToNot(BeNil())
				Expect(deleteSparkEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSparkEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSparkEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteTableOptions successfully`, func() {
				// Construct an instance of the DeleteTableOptions model
				catalogID := "testString"
				schemaID := "testString"
				tableID := "testString"
				engineID := "testString"
				deleteTableOptionsModel := watsonxDataService.NewDeleteTableOptions(catalogID, schemaID, tableID, engineID)
				deleteTableOptionsModel.SetCatalogID("testString")
				deleteTableOptionsModel.SetSchemaID("testString")
				deleteTableOptionsModel.SetTableID("testString")
				deleteTableOptionsModel.SetEngineID("testString")
				deleteTableOptionsModel.SetType("testString")
				deleteTableOptionsModel.SetAuthInstanceID("testString")
				deleteTableOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteTableOptionsModel).ToNot(BeNil())
				Expect(deleteTableOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(deleteTableOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(deleteTableOptionsModel.TableID).To(Equal(core.StringPtr("testString")))
				Expect(deleteTableOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteTableOptionsModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(deleteTableOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteTableOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewEnrichmentObj successfully`, func() {
				catalog := "iceberg_data"
				operation := "create"
				schema := "testString"
				_model, err := watsonxDataService.NewEnrichmentObj(catalog, operation, schema)
				Expect(_model).ToNot(BeNil())
				Expect(err).To(BeNil())
			})
			It(`Invoke NewGetAllColumnsOptions successfully`, func() {
				// Construct an instance of the GetAllColumnsOptions model
				getAllColumnsOptionsModel := watsonxDataService.NewGetAllColumnsOptions()
				getAllColumnsOptionsModel.SetTableName("testString")
				getAllColumnsOptionsModel.SetCatalogName("testString")
				getAllColumnsOptionsModel.SetSchemaName("testString")
				getAllColumnsOptionsModel.SetAuthInstanceID("testString")
				getAllColumnsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getAllColumnsOptionsModel).ToNot(BeNil())
				Expect(getAllColumnsOptionsModel.TableName).To(Equal(core.StringPtr("testString")))
				Expect(getAllColumnsOptionsModel.CatalogName).To(Equal(core.StringPtr("testString")))
				Expect(getAllColumnsOptionsModel.SchemaName).To(Equal(core.StringPtr("testString")))
				Expect(getAllColumnsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getAllColumnsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetBucketObjectPropertiesOptions successfully`, func() {
				// Construct an instance of the Path model
				pathModel := new(watsonxdatav2.Path)
				Expect(pathModel).ToNot(BeNil())
				pathModel.Path = core.StringPtr("string")
				Expect(pathModel.Path).To(Equal(core.StringPtr("string")))

				// Construct an instance of the GetBucketObjectPropertiesOptions model
				bucketID := "testString"
				getBucketObjectPropertiesOptionsModel := watsonxDataService.NewGetBucketObjectPropertiesOptions(bucketID)
				getBucketObjectPropertiesOptionsModel.SetBucketID("testString")
				getBucketObjectPropertiesOptionsModel.SetPaths([]watsonxdatav2.Path{*pathModel})
				getBucketObjectPropertiesOptionsModel.SetAuthInstanceID("testString")
				getBucketObjectPropertiesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getBucketObjectPropertiesOptionsModel).ToNot(BeNil())
				Expect(getBucketObjectPropertiesOptionsModel.BucketID).To(Equal(core.StringPtr("testString")))
				Expect(getBucketObjectPropertiesOptionsModel.Paths).To(Equal([]watsonxdatav2.Path{*pathModel}))
				Expect(getBucketObjectPropertiesOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getBucketObjectPropertiesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetBucketRegistrationOptions successfully`, func() {
				// Construct an instance of the GetBucketRegistrationOptions model
				bucketID := "testString"
				getBucketRegistrationOptionsModel := watsonxDataService.NewGetBucketRegistrationOptions(bucketID)
				getBucketRegistrationOptionsModel.SetBucketID("testString")
				getBucketRegistrationOptionsModel.SetAuthInstanceID("testString")
				getBucketRegistrationOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getBucketRegistrationOptionsModel).ToNot(BeNil())
				Expect(getBucketRegistrationOptionsModel.BucketID).To(Equal(core.StringPtr("testString")))
				Expect(getBucketRegistrationOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getBucketRegistrationOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetCatalogOptions successfully`, func() {
				// Construct an instance of the GetCatalogOptions model
				catalogID := "testString"
				getCatalogOptionsModel := watsonxDataService.NewGetCatalogOptions(catalogID)
				getCatalogOptionsModel.SetCatalogID("testString")
				getCatalogOptionsModel.SetAuthInstanceID("testString")
				getCatalogOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getCatalogOptionsModel).ToNot(BeNil())
				Expect(getCatalogOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(getCatalogOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getCatalogOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetDatabaseOptions successfully`, func() {
				// Construct an instance of the GetDatabaseOptions model
				databaseID := "testString"
				getDatabaseOptionsModel := watsonxDataService.NewGetDatabaseOptions(databaseID)
				getDatabaseOptionsModel.SetDatabaseID("testString")
				getDatabaseOptionsModel.SetAuthInstanceID("testString")
				getDatabaseOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getDatabaseOptionsModel).ToNot(BeNil())
				Expect(getDatabaseOptionsModel.DatabaseID).To(Equal(core.StringPtr("testString")))
				Expect(getDatabaseOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getDatabaseOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetEndpointsOptions successfully`, func() {
				// Construct an instance of the GetEndpointsOptions model
				getEndpointsOptionsModel := watsonxDataService.NewGetEndpointsOptions()
				getEndpointsOptionsModel.SetAuthInstanceID("testString")
				getEndpointsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getEndpointsOptionsModel).ToNot(BeNil())
				Expect(getEndpointsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getEndpointsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetIngestionJobOptions successfully`, func() {
				// Construct an instance of the GetIngestionJobOptions model
				jobID := "testString"
				authInstanceID := "testString"
				getIngestionJobOptionsModel := watsonxDataService.NewGetIngestionJobOptions(jobID, authInstanceID)
				getIngestionJobOptionsModel.SetJobID("testString")
				getIngestionJobOptionsModel.SetAuthInstanceID("testString")
				getIngestionJobOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getIngestionJobOptionsModel).ToNot(BeNil())
				Expect(getIngestionJobOptionsModel.JobID).To(Equal(core.StringPtr("testString")))
				Expect(getIngestionJobOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getIngestionJobOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetIntegrationsOptions successfully`, func() {
				// Construct an instance of the GetIntegrationsOptions model
				integrationID := "testString"
				getIntegrationsOptionsModel := watsonxDataService.NewGetIntegrationsOptions(integrationID)
				getIntegrationsOptionsModel.SetIntegrationID("testString")
				getIntegrationsOptionsModel.SetAuthInstanceID("testString")
				getIntegrationsOptionsModel.SetSecret("testString")
				getIntegrationsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getIntegrationsOptionsModel).ToNot(BeNil())
				Expect(getIntegrationsOptionsModel.IntegrationID).To(Equal(core.StringPtr("testString")))
				Expect(getIntegrationsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getIntegrationsOptionsModel.Secret).To(Equal(core.StringPtr("testString")))
				Expect(getIntegrationsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetMilvusServiceOptions successfully`, func() {
				// Construct an instance of the GetMilvusServiceOptions model
				serviceID := "testString"
				getMilvusServiceOptionsModel := watsonxDataService.NewGetMilvusServiceOptions(serviceID)
				getMilvusServiceOptionsModel.SetServiceID("testString")
				getMilvusServiceOptionsModel.SetAuthInstanceID("testString")
				getMilvusServiceOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getMilvusServiceOptionsModel).ToNot(BeNil())
				Expect(getMilvusServiceOptionsModel.ServiceID).To(Equal(core.StringPtr("testString")))
				Expect(getMilvusServiceOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getMilvusServiceOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetPrestissimoEngineCatalogOptions successfully`, func() {
				// Construct an instance of the GetPrestissimoEngineCatalogOptions model
				engineID := "testString"
				catalogID := "testString"
				getPrestissimoEngineCatalogOptionsModel := watsonxDataService.NewGetPrestissimoEngineCatalogOptions(engineID, catalogID)
				getPrestissimoEngineCatalogOptionsModel.SetEngineID("testString")
				getPrestissimoEngineCatalogOptionsModel.SetCatalogID("testString")
				getPrestissimoEngineCatalogOptionsModel.SetAuthInstanceID("testString")
				getPrestissimoEngineCatalogOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getPrestissimoEngineCatalogOptionsModel).ToNot(BeNil())
				Expect(getPrestissimoEngineCatalogOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(getPrestissimoEngineCatalogOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(getPrestissimoEngineCatalogOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getPrestissimoEngineCatalogOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetPrestissimoEngineOptions successfully`, func() {
				// Construct an instance of the GetPrestissimoEngineOptions model
				engineID := "testString"
				getPrestissimoEngineOptionsModel := watsonxDataService.NewGetPrestissimoEngineOptions(engineID)
				getPrestissimoEngineOptionsModel.SetEngineID("testString")
				getPrestissimoEngineOptionsModel.SetAuthInstanceID("testString")
				getPrestissimoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getPrestissimoEngineOptionsModel).ToNot(BeNil())
				Expect(getPrestissimoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(getPrestissimoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getPrestissimoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetPrestoEngineCatalogOptions successfully`, func() {
				// Construct an instance of the GetPrestoEngineCatalogOptions model
				engineID := "testString"
				catalogID := "testString"
				getPrestoEngineCatalogOptionsModel := watsonxDataService.NewGetPrestoEngineCatalogOptions(engineID, catalogID)
				getPrestoEngineCatalogOptionsModel.SetEngineID("testString")
				getPrestoEngineCatalogOptionsModel.SetCatalogID("testString")
				getPrestoEngineCatalogOptionsModel.SetAuthInstanceID("testString")
				getPrestoEngineCatalogOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getPrestoEngineCatalogOptionsModel).ToNot(BeNil())
				Expect(getPrestoEngineCatalogOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(getPrestoEngineCatalogOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(getPrestoEngineCatalogOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getPrestoEngineCatalogOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetPrestoEngineOptions successfully`, func() {
				// Construct an instance of the GetPrestoEngineOptions model
				engineID := "testString"
				getPrestoEngineOptionsModel := watsonxDataService.NewGetPrestoEngineOptions(engineID)
				getPrestoEngineOptionsModel.SetEngineID("testString")
				getPrestoEngineOptionsModel.SetAuthInstanceID("testString")
				getPrestoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getPrestoEngineOptionsModel).ToNot(BeNil())
				Expect(getPrestoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(getPrestoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getPrestoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetSalIntegrationEnrichmentAssetsOptions successfully`, func() {
				// Construct an instance of the GetSalIntegrationEnrichmentAssetsOptions model
				getSalIntegrationEnrichmentAssetsOptionsModel := watsonxDataService.NewGetSalIntegrationEnrichmentAssetsOptions()
				getSalIntegrationEnrichmentAssetsOptionsModel.SetProjectID("testString")
				getSalIntegrationEnrichmentAssetsOptionsModel.SetAuthInstanceID("testString")
				getSalIntegrationEnrichmentAssetsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getSalIntegrationEnrichmentAssetsOptionsModel).ToNot(BeNil())
				Expect(getSalIntegrationEnrichmentAssetsOptionsModel.ProjectID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationEnrichmentAssetsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationEnrichmentAssetsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetSalIntegrationEnrichmentDataAssetOptions successfully`, func() {
				// Construct an instance of the GetSalIntegrationEnrichmentDataAssetOptions model
				getSalIntegrationEnrichmentDataAssetOptionsModel := watsonxDataService.NewGetSalIntegrationEnrichmentDataAssetOptions()
				getSalIntegrationEnrichmentDataAssetOptionsModel.SetProjectID("testString")
				getSalIntegrationEnrichmentDataAssetOptionsModel.SetAssetID("testString")
				getSalIntegrationEnrichmentDataAssetOptionsModel.SetAuthInstanceID("testString")
				getSalIntegrationEnrichmentDataAssetOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getSalIntegrationEnrichmentDataAssetOptionsModel).ToNot(BeNil())
				Expect(getSalIntegrationEnrichmentDataAssetOptionsModel.ProjectID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationEnrichmentDataAssetOptionsModel.AssetID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationEnrichmentDataAssetOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationEnrichmentDataAssetOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetSalIntegrationEnrichmentGlobalSettingsOptions successfully`, func() {
				// Construct an instance of the GetSalIntegrationEnrichmentGlobalSettingsOptions model
				getSalIntegrationEnrichmentGlobalSettingsOptionsModel := watsonxDataService.NewGetSalIntegrationEnrichmentGlobalSettingsOptions()
				getSalIntegrationEnrichmentGlobalSettingsOptionsModel.SetAuthInstanceID("testString")
				getSalIntegrationEnrichmentGlobalSettingsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getSalIntegrationEnrichmentGlobalSettingsOptionsModel).ToNot(BeNil())
				Expect(getSalIntegrationEnrichmentGlobalSettingsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationEnrichmentGlobalSettingsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetSalIntegrationEnrichmentJobRunLogsOptions successfully`, func() {
				// Construct an instance of the GetSalIntegrationEnrichmentJobRunLogsOptions model
				getSalIntegrationEnrichmentJobRunLogsOptionsModel := watsonxDataService.NewGetSalIntegrationEnrichmentJobRunLogsOptions()
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.SetJobID("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.SetJobRunID("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.SetProjectID("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.SetAuthInstanceID("testString")
				getSalIntegrationEnrichmentJobRunLogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getSalIntegrationEnrichmentJobRunLogsOptionsModel).ToNot(BeNil())
				Expect(getSalIntegrationEnrichmentJobRunLogsOptionsModel.JobID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationEnrichmentJobRunLogsOptionsModel.JobRunID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationEnrichmentJobRunLogsOptionsModel.ProjectID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationEnrichmentJobRunLogsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationEnrichmentJobRunLogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetSalIntegrationEnrichmentJobRunsOptions successfully`, func() {
				// Construct an instance of the GetSalIntegrationEnrichmentJobRunsOptions model
				getSalIntegrationEnrichmentJobRunsOptionsModel := watsonxDataService.NewGetSalIntegrationEnrichmentJobRunsOptions()
				getSalIntegrationEnrichmentJobRunsOptionsModel.SetJobID("testString")
				getSalIntegrationEnrichmentJobRunsOptionsModel.SetProjectID("testString")
				getSalIntegrationEnrichmentJobRunsOptionsModel.SetAuthInstanceID("testString")
				getSalIntegrationEnrichmentJobRunsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getSalIntegrationEnrichmentJobRunsOptionsModel).ToNot(BeNil())
				Expect(getSalIntegrationEnrichmentJobRunsOptionsModel.JobID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationEnrichmentJobRunsOptionsModel.ProjectID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationEnrichmentJobRunsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationEnrichmentJobRunsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetSalIntegrationEnrichmentJobsOptions successfully`, func() {
				// Construct an instance of the GetSalIntegrationEnrichmentJobsOptions model
				getSalIntegrationEnrichmentJobsOptionsModel := watsonxDataService.NewGetSalIntegrationEnrichmentJobsOptions()
				getSalIntegrationEnrichmentJobsOptionsModel.SetWkcProjectID("testString")
				getSalIntegrationEnrichmentJobsOptionsModel.SetAuthInstanceID("testString")
				getSalIntegrationEnrichmentJobsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getSalIntegrationEnrichmentJobsOptionsModel).ToNot(BeNil())
				Expect(getSalIntegrationEnrichmentJobsOptionsModel.WkcProjectID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationEnrichmentJobsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationEnrichmentJobsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetSalIntegrationEnrichmentSettingsOptions successfully`, func() {
				// Construct an instance of the GetSalIntegrationEnrichmentSettingsOptions model
				getSalIntegrationEnrichmentSettingsOptionsModel := watsonxDataService.NewGetSalIntegrationEnrichmentSettingsOptions()
				getSalIntegrationEnrichmentSettingsOptionsModel.SetProjectID("testString")
				getSalIntegrationEnrichmentSettingsOptionsModel.SetAuthInstanceID("testString")
				getSalIntegrationEnrichmentSettingsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getSalIntegrationEnrichmentSettingsOptionsModel).ToNot(BeNil())
				Expect(getSalIntegrationEnrichmentSettingsOptionsModel.ProjectID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationEnrichmentSettingsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationEnrichmentSettingsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetSalIntegrationGlossaryTermsOptions successfully`, func() {
				// Construct an instance of the GetSalIntegrationGlossaryTermsOptions model
				getSalIntegrationGlossaryTermsOptionsModel := watsonxDataService.NewGetSalIntegrationGlossaryTermsOptions()
				getSalIntegrationGlossaryTermsOptionsModel.SetAuthInstanceID("testString")
				getSalIntegrationGlossaryTermsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getSalIntegrationGlossaryTermsOptionsModel).ToNot(BeNil())
				Expect(getSalIntegrationGlossaryTermsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationGlossaryTermsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetSalIntegrationMappingsOptions successfully`, func() {
				// Construct an instance of the GetSalIntegrationMappingsOptions model
				catalogName := "testString"
				schemaName := "testString"
				getSalIntegrationMappingsOptionsModel := watsonxDataService.NewGetSalIntegrationMappingsOptions(catalogName, schemaName)
				getSalIntegrationMappingsOptionsModel.SetCatalogName("testString")
				getSalIntegrationMappingsOptionsModel.SetSchemaName("testString")
				getSalIntegrationMappingsOptionsModel.SetAuthInstanceID("testString")
				getSalIntegrationMappingsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getSalIntegrationMappingsOptionsModel).ToNot(BeNil())
				Expect(getSalIntegrationMappingsOptionsModel.CatalogName).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationMappingsOptionsModel.SchemaName).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationMappingsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationMappingsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetSalIntegrationOptions successfully`, func() {
				// Construct an instance of the GetSalIntegrationOptions model
				getSalIntegrationOptionsModel := watsonxDataService.NewGetSalIntegrationOptions()
				getSalIntegrationOptionsModel.SetAuthInstanceID("testString")
				getSalIntegrationOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getSalIntegrationOptionsModel).ToNot(BeNil())
				Expect(getSalIntegrationOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetSalIntegrationUploadGlossaryStatusOptions successfully`, func() {
				// Construct an instance of the GetSalIntegrationUploadGlossaryStatusOptions model
				getSalIntegrationUploadGlossaryStatusOptionsModel := watsonxDataService.NewGetSalIntegrationUploadGlossaryStatusOptions()
				getSalIntegrationUploadGlossaryStatusOptionsModel.SetProcessID("testString")
				getSalIntegrationUploadGlossaryStatusOptionsModel.SetAuthInstanceID("testString")
				getSalIntegrationUploadGlossaryStatusOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getSalIntegrationUploadGlossaryStatusOptionsModel).ToNot(BeNil())
				Expect(getSalIntegrationUploadGlossaryStatusOptionsModel.ProcessID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationUploadGlossaryStatusOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getSalIntegrationUploadGlossaryStatusOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetSchemaDetailsOptions successfully`, func() {
				// Construct an instance of the GetSchemaDetailsOptions model
				schemaName := "testString"
				getSchemaDetailsOptionsModel := watsonxDataService.NewGetSchemaDetailsOptions(schemaName)
				getSchemaDetailsOptionsModel.SetSchemaName("testString")
				getSchemaDetailsOptionsModel.SetCatalogName("testString")
				getSchemaDetailsOptionsModel.SetAuthInstanceID("testString")
				getSchemaDetailsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getSchemaDetailsOptionsModel).ToNot(BeNil())
				Expect(getSchemaDetailsOptionsModel.SchemaName).To(Equal(core.StringPtr("testString")))
				Expect(getSchemaDetailsOptionsModel.CatalogName).To(Equal(core.StringPtr("testString")))
				Expect(getSchemaDetailsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getSchemaDetailsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetSparkEngineApplicationStatusOptions successfully`, func() {
				// Construct an instance of the GetSparkEngineApplicationStatusOptions model
				engineID := "testString"
				applicationID := "testString"
				getSparkEngineApplicationStatusOptionsModel := watsonxDataService.NewGetSparkEngineApplicationStatusOptions(engineID, applicationID)
				getSparkEngineApplicationStatusOptionsModel.SetEngineID("testString")
				getSparkEngineApplicationStatusOptionsModel.SetApplicationID("testString")
				getSparkEngineApplicationStatusOptionsModel.SetAuthInstanceID("testString")
				getSparkEngineApplicationStatusOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getSparkEngineApplicationStatusOptionsModel).ToNot(BeNil())
				Expect(getSparkEngineApplicationStatusOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(getSparkEngineApplicationStatusOptionsModel.ApplicationID).To(Equal(core.StringPtr("testString")))
				Expect(getSparkEngineApplicationStatusOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getSparkEngineApplicationStatusOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetSparkEngineCatalogOptions successfully`, func() {
				// Construct an instance of the GetSparkEngineCatalogOptions model
				engineID := "testString"
				catalogID := "testString"
				getSparkEngineCatalogOptionsModel := watsonxDataService.NewGetSparkEngineCatalogOptions(engineID, catalogID)
				getSparkEngineCatalogOptionsModel.SetEngineID("testString")
				getSparkEngineCatalogOptionsModel.SetCatalogID("testString")
				getSparkEngineCatalogOptionsModel.SetAuthInstanceID("testString")
				getSparkEngineCatalogOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getSparkEngineCatalogOptionsModel).ToNot(BeNil())
				Expect(getSparkEngineCatalogOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(getSparkEngineCatalogOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(getSparkEngineCatalogOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getSparkEngineCatalogOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetSparkEngineHistoryServerOptions successfully`, func() {
				// Construct an instance of the GetSparkEngineHistoryServerOptions model
				engineID := "testString"
				getSparkEngineHistoryServerOptionsModel := watsonxDataService.NewGetSparkEngineHistoryServerOptions(engineID)
				getSparkEngineHistoryServerOptionsModel.SetEngineID("testString")
				getSparkEngineHistoryServerOptionsModel.SetAuthInstanceID("testString")
				getSparkEngineHistoryServerOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getSparkEngineHistoryServerOptionsModel).ToNot(BeNil())
				Expect(getSparkEngineHistoryServerOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(getSparkEngineHistoryServerOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getSparkEngineHistoryServerOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetSparkEngineOptions successfully`, func() {
				// Construct an instance of the GetSparkEngineOptions model
				engineID := "testString"
				getSparkEngineOptionsModel := watsonxDataService.NewGetSparkEngineOptions(engineID)
				getSparkEngineOptionsModel.SetEngineID("testString")
				getSparkEngineOptionsModel.SetAuthInstanceID("testString")
				getSparkEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getSparkEngineOptionsModel).ToNot(BeNil())
				Expect(getSparkEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(getSparkEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getSparkEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetTableDetailsOptions successfully`, func() {
				// Construct an instance of the GetTableDetailsOptions model
				tableName := "testString"
				getTableDetailsOptionsModel := watsonxDataService.NewGetTableDetailsOptions(tableName)
				getTableDetailsOptionsModel.SetTableName("testString")
				getTableDetailsOptionsModel.SetCatalogName("testString")
				getTableDetailsOptionsModel.SetSchemaName("testString")
				getTableDetailsOptionsModel.SetAuthInstanceID("testString")
				getTableDetailsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getTableDetailsOptionsModel).ToNot(BeNil())
				Expect(getTableDetailsOptionsModel.TableName).To(Equal(core.StringPtr("testString")))
				Expect(getTableDetailsOptionsModel.CatalogName).To(Equal(core.StringPtr("testString")))
				Expect(getTableDetailsOptionsModel.SchemaName).To(Equal(core.StringPtr("testString")))
				Expect(getTableDetailsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getTableDetailsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetTableOptions successfully`, func() {
				// Construct an instance of the GetTableOptions model
				catalogID := "testString"
				schemaID := "testString"
				tableID := "testString"
				engineID := "testString"
				getTableOptionsModel := watsonxDataService.NewGetTableOptions(catalogID, schemaID, tableID, engineID)
				getTableOptionsModel.SetCatalogID("testString")
				getTableOptionsModel.SetSchemaID("testString")
				getTableOptionsModel.SetTableID("testString")
				getTableOptionsModel.SetEngineID("testString")
				getTableOptionsModel.SetType("testString")
				getTableOptionsModel.SetAuthInstanceID("testString")
				getTableOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getTableOptionsModel).ToNot(BeNil())
				Expect(getTableOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(getTableOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(getTableOptionsModel.TableID).To(Equal(core.StringPtr("testString")))
				Expect(getTableOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(getTableOptionsModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(getTableOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getTableOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListAllIntegrationsOptions successfully`, func() {
				// Construct an instance of the ListAllIntegrationsOptions model
				listAllIntegrationsOptionsModel := watsonxDataService.NewListAllIntegrationsOptions()
				listAllIntegrationsOptionsModel.SetAuthInstanceID("testString")
				listAllIntegrationsOptionsModel.SetSecret("testString")
				listAllIntegrationsOptionsModel.SetServiceType("testString")
				listAllIntegrationsOptionsModel.SetState([]string{"testString"})
				listAllIntegrationsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listAllIntegrationsOptionsModel).ToNot(BeNil())
				Expect(listAllIntegrationsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listAllIntegrationsOptionsModel.Secret).To(Equal(core.StringPtr("testString")))
				Expect(listAllIntegrationsOptionsModel.ServiceType).To(Equal(core.StringPtr("testString")))
				Expect(listAllIntegrationsOptionsModel.State).To(Equal([]string{"testString"}))
				Expect(listAllIntegrationsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListAllSchemasOptions successfully`, func() {
				// Construct an instance of the ListAllSchemasOptions model
				listAllSchemasOptionsModel := watsonxDataService.NewListAllSchemasOptions()
				listAllSchemasOptionsModel.SetCatalogName("testString")
				listAllSchemasOptionsModel.SetAuthInstanceID("testString")
				listAllSchemasOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listAllSchemasOptionsModel).ToNot(BeNil())
				Expect(listAllSchemasOptionsModel.CatalogName).To(Equal(core.StringPtr("testString")))
				Expect(listAllSchemasOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listAllSchemasOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListAllTablesOptions successfully`, func() {
				// Construct an instance of the ListAllTablesOptions model
				listAllTablesOptionsModel := watsonxDataService.NewListAllTablesOptions()
				listAllTablesOptionsModel.SetCatalogName("testString")
				listAllTablesOptionsModel.SetSchemaName("testString")
				listAllTablesOptionsModel.SetAuthInstanceID("testString")
				listAllTablesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listAllTablesOptionsModel).ToNot(BeNil())
				Expect(listAllTablesOptionsModel.CatalogName).To(Equal(core.StringPtr("testString")))
				Expect(listAllTablesOptionsModel.SchemaName).To(Equal(core.StringPtr("testString")))
				Expect(listAllTablesOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listAllTablesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListBucketObjectsOptions successfully`, func() {
				// Construct an instance of the ListBucketObjectsOptions model
				bucketID := "testString"
				listBucketObjectsOptionsModel := watsonxDataService.NewListBucketObjectsOptions(bucketID)
				listBucketObjectsOptionsModel.SetBucketID("testString")
				listBucketObjectsOptionsModel.SetAuthInstanceID("testString")
				listBucketObjectsOptionsModel.SetPath("testString")
				listBucketObjectsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listBucketObjectsOptionsModel).ToNot(BeNil())
				Expect(listBucketObjectsOptionsModel.BucketID).To(Equal(core.StringPtr("testString")))
				Expect(listBucketObjectsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listBucketObjectsOptionsModel.Path).To(Equal(core.StringPtr("testString")))
				Expect(listBucketObjectsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListBucketRegistrationsOptions successfully`, func() {
				// Construct an instance of the ListBucketRegistrationsOptions model
				listBucketRegistrationsOptionsModel := watsonxDataService.NewListBucketRegistrationsOptions()
				listBucketRegistrationsOptionsModel.SetAuthInstanceID("testString")
				listBucketRegistrationsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listBucketRegistrationsOptionsModel).ToNot(BeNil())
				Expect(listBucketRegistrationsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listBucketRegistrationsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListCatalogsOptions successfully`, func() {
				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := watsonxDataService.NewListCatalogsOptions()
				listCatalogsOptionsModel.SetAuthInstanceID("testString")
				listCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listCatalogsOptionsModel).ToNot(BeNil())
				Expect(listCatalogsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListColumnsOptions successfully`, func() {
				// Construct an instance of the ListColumnsOptions model
				engineID := "testString"
				catalogID := "testString"
				schemaID := "testString"
				tableID := "testString"
				listColumnsOptionsModel := watsonxDataService.NewListColumnsOptions(engineID, catalogID, schemaID, tableID)
				listColumnsOptionsModel.SetEngineID("testString")
				listColumnsOptionsModel.SetCatalogID("testString")
				listColumnsOptionsModel.SetSchemaID("testString")
				listColumnsOptionsModel.SetTableID("testString")
				listColumnsOptionsModel.SetAuthInstanceID("testString")
				listColumnsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listColumnsOptionsModel).ToNot(BeNil())
				Expect(listColumnsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(listColumnsOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(listColumnsOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(listColumnsOptionsModel.TableID).To(Equal(core.StringPtr("testString")))
				Expect(listColumnsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listColumnsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListDatabaseRegistrationsOptions successfully`, func() {
				// Construct an instance of the ListDatabaseRegistrationsOptions model
				listDatabaseRegistrationsOptionsModel := watsonxDataService.NewListDatabaseRegistrationsOptions()
				listDatabaseRegistrationsOptionsModel.SetAuthInstanceID("testString")
				listDatabaseRegistrationsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listDatabaseRegistrationsOptionsModel).ToNot(BeNil())
				Expect(listDatabaseRegistrationsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listDatabaseRegistrationsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListDb2EnginesOptions successfully`, func() {
				// Construct an instance of the ListDb2EnginesOptions model
				listDb2EnginesOptionsModel := watsonxDataService.NewListDb2EnginesOptions()
				listDb2EnginesOptionsModel.SetAuthInstanceID("testString")
				listDb2EnginesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listDb2EnginesOptionsModel).ToNot(BeNil())
				Expect(listDb2EnginesOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listDb2EnginesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListIngestionJobsOptions successfully`, func() {
				// Construct an instance of the ListIngestionJobsOptions model
				authInstanceID := "testString"
				listIngestionJobsOptionsModel := watsonxDataService.NewListIngestionJobsOptions(authInstanceID)
				listIngestionJobsOptionsModel.SetAuthInstanceID("testString")
				listIngestionJobsOptionsModel.SetStart("1")
				listIngestionJobsOptionsModel.SetJobsPerPage(int64(1))
				listIngestionJobsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listIngestionJobsOptionsModel).ToNot(BeNil())
				Expect(listIngestionJobsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listIngestionJobsOptionsModel.Start).To(Equal(core.StringPtr("1")))
				Expect(listIngestionJobsOptionsModel.JobsPerPage).To(Equal(core.Int64Ptr(int64(1))))
				Expect(listIngestionJobsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListMilvusDatabaseCollectionsOptions successfully`, func() {
				// Construct an instance of the ListMilvusDatabaseCollectionsOptions model
				serviceID := "testString"
				databaseID := "testString"
				listMilvusDatabaseCollectionsOptionsModel := watsonxDataService.NewListMilvusDatabaseCollectionsOptions(serviceID, databaseID)
				listMilvusDatabaseCollectionsOptionsModel.SetServiceID("testString")
				listMilvusDatabaseCollectionsOptionsModel.SetDatabaseID("testString")
				listMilvusDatabaseCollectionsOptionsModel.SetAuthInstanceID("testString")
				listMilvusDatabaseCollectionsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listMilvusDatabaseCollectionsOptionsModel).ToNot(BeNil())
				Expect(listMilvusDatabaseCollectionsOptionsModel.ServiceID).To(Equal(core.StringPtr("testString")))
				Expect(listMilvusDatabaseCollectionsOptionsModel.DatabaseID).To(Equal(core.StringPtr("testString")))
				Expect(listMilvusDatabaseCollectionsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listMilvusDatabaseCollectionsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListMilvusServiceDatabasesOptions successfully`, func() {
				// Construct an instance of the ListMilvusServiceDatabasesOptions model
				serviceID := "testString"
				listMilvusServiceDatabasesOptionsModel := watsonxDataService.NewListMilvusServiceDatabasesOptions(serviceID)
				listMilvusServiceDatabasesOptionsModel.SetServiceID("testString")
				listMilvusServiceDatabasesOptionsModel.SetAuthInstanceID("testString")
				listMilvusServiceDatabasesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listMilvusServiceDatabasesOptionsModel).ToNot(BeNil())
				Expect(listMilvusServiceDatabasesOptionsModel.ServiceID).To(Equal(core.StringPtr("testString")))
				Expect(listMilvusServiceDatabasesOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listMilvusServiceDatabasesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListMilvusServicesOptions successfully`, func() {
				// Construct an instance of the ListMilvusServicesOptions model
				listMilvusServicesOptionsModel := watsonxDataService.NewListMilvusServicesOptions()
				listMilvusServicesOptionsModel.SetAuthInstanceID("testString")
				listMilvusServicesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listMilvusServicesOptionsModel).ToNot(BeNil())
				Expect(listMilvusServicesOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listMilvusServicesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListNetezzaEnginesOptions successfully`, func() {
				// Construct an instance of the ListNetezzaEnginesOptions model
				listNetezzaEnginesOptionsModel := watsonxDataService.NewListNetezzaEnginesOptions()
				listNetezzaEnginesOptionsModel.SetAuthInstanceID("testString")
				listNetezzaEnginesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listNetezzaEnginesOptionsModel).ToNot(BeNil())
				Expect(listNetezzaEnginesOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listNetezzaEnginesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListOtherEnginesOptions successfully`, func() {
				// Construct an instance of the ListOtherEnginesOptions model
				listOtherEnginesOptionsModel := watsonxDataService.NewListOtherEnginesOptions()
				listOtherEnginesOptionsModel.SetAuthInstanceID("testString")
				listOtherEnginesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listOtherEnginesOptionsModel).ToNot(BeNil())
				Expect(listOtherEnginesOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listOtherEnginesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListPrestissimoEngineCatalogsOptions successfully`, func() {
				// Construct an instance of the ListPrestissimoEngineCatalogsOptions model
				engineID := "testString"
				listPrestissimoEngineCatalogsOptionsModel := watsonxDataService.NewListPrestissimoEngineCatalogsOptions(engineID)
				listPrestissimoEngineCatalogsOptionsModel.SetEngineID("testString")
				listPrestissimoEngineCatalogsOptionsModel.SetAuthInstanceID("testString")
				listPrestissimoEngineCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listPrestissimoEngineCatalogsOptionsModel).ToNot(BeNil())
				Expect(listPrestissimoEngineCatalogsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(listPrestissimoEngineCatalogsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listPrestissimoEngineCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListPrestissimoEnginesOptions successfully`, func() {
				// Construct an instance of the ListPrestissimoEnginesOptions model
				listPrestissimoEnginesOptionsModel := watsonxDataService.NewListPrestissimoEnginesOptions()
				listPrestissimoEnginesOptionsModel.SetAuthInstanceID("testString")
				listPrestissimoEnginesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listPrestissimoEnginesOptionsModel).ToNot(BeNil())
				Expect(listPrestissimoEnginesOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listPrestissimoEnginesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListPrestoEngineCatalogsOptions successfully`, func() {
				// Construct an instance of the ListPrestoEngineCatalogsOptions model
				engineID := "testString"
				listPrestoEngineCatalogsOptionsModel := watsonxDataService.NewListPrestoEngineCatalogsOptions(engineID)
				listPrestoEngineCatalogsOptionsModel.SetEngineID("testString")
				listPrestoEngineCatalogsOptionsModel.SetAuthInstanceID("testString")
				listPrestoEngineCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listPrestoEngineCatalogsOptionsModel).ToNot(BeNil())
				Expect(listPrestoEngineCatalogsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(listPrestoEngineCatalogsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listPrestoEngineCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListPrestoEnginesOptions successfully`, func() {
				// Construct an instance of the ListPrestoEnginesOptions model
				listPrestoEnginesOptionsModel := watsonxDataService.NewListPrestoEnginesOptions()
				listPrestoEnginesOptionsModel.SetAuthInstanceID("testString")
				listPrestoEnginesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listPrestoEnginesOptionsModel).ToNot(BeNil())
				Expect(listPrestoEnginesOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listPrestoEnginesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListSchemasOptions successfully`, func() {
				// Construct an instance of the ListSchemasOptions model
				engineID := "testString"
				catalogID := "testString"
				listSchemasOptionsModel := watsonxDataService.NewListSchemasOptions(engineID, catalogID)
				listSchemasOptionsModel.SetEngineID("testString")
				listSchemasOptionsModel.SetCatalogID("testString")
				listSchemasOptionsModel.SetAuthInstanceID("testString")
				listSchemasOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listSchemasOptionsModel).ToNot(BeNil())
				Expect(listSchemasOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(listSchemasOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(listSchemasOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listSchemasOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListSparkEngineApplicationsOptions successfully`, func() {
				// Construct an instance of the ListSparkEngineApplicationsOptions model
				engineID := "testString"
				listSparkEngineApplicationsOptionsModel := watsonxDataService.NewListSparkEngineApplicationsOptions(engineID)
				listSparkEngineApplicationsOptionsModel.SetEngineID("testString")
				listSparkEngineApplicationsOptionsModel.SetAuthInstanceID("testString")
				listSparkEngineApplicationsOptionsModel.SetState([]string{"testString"})
				listSparkEngineApplicationsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listSparkEngineApplicationsOptionsModel).ToNot(BeNil())
				Expect(listSparkEngineApplicationsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(listSparkEngineApplicationsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listSparkEngineApplicationsOptionsModel.State).To(Equal([]string{"testString"}))
				Expect(listSparkEngineApplicationsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListSparkEngineCatalogsOptions successfully`, func() {
				// Construct an instance of the ListSparkEngineCatalogsOptions model
				engineID := "testString"
				listSparkEngineCatalogsOptionsModel := watsonxDataService.NewListSparkEngineCatalogsOptions(engineID)
				listSparkEngineCatalogsOptionsModel.SetEngineID("testString")
				listSparkEngineCatalogsOptionsModel.SetAuthInstanceID("testString")
				listSparkEngineCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listSparkEngineCatalogsOptionsModel).ToNot(BeNil())
				Expect(listSparkEngineCatalogsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(listSparkEngineCatalogsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listSparkEngineCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListSparkEnginesOptions successfully`, func() {
				// Construct an instance of the ListSparkEnginesOptions model
				listSparkEnginesOptionsModel := watsonxDataService.NewListSparkEnginesOptions()
				listSparkEnginesOptionsModel.SetAuthInstanceID("testString")
				listSparkEnginesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listSparkEnginesOptionsModel).ToNot(BeNil())
				Expect(listSparkEnginesOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listSparkEnginesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListSparkVersionsOptions successfully`, func() {
				// Construct an instance of the ListSparkVersionsOptions model
				listSparkVersionsOptionsModel := watsonxDataService.NewListSparkVersionsOptions()
				listSparkVersionsOptionsModel.SetAuthInstanceID("testString")
				listSparkVersionsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listSparkVersionsOptionsModel).ToNot(BeNil())
				Expect(listSparkVersionsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listSparkVersionsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListTableSnapshotsOptions successfully`, func() {
				// Construct an instance of the ListTableSnapshotsOptions model
				engineID := "testString"
				catalogID := "testString"
				schemaID := "testString"
				tableID := "testString"
				listTableSnapshotsOptionsModel := watsonxDataService.NewListTableSnapshotsOptions(engineID, catalogID, schemaID, tableID)
				listTableSnapshotsOptionsModel.SetEngineID("testString")
				listTableSnapshotsOptionsModel.SetCatalogID("testString")
				listTableSnapshotsOptionsModel.SetSchemaID("testString")
				listTableSnapshotsOptionsModel.SetTableID("testString")
				listTableSnapshotsOptionsModel.SetAuthInstanceID("testString")
				listTableSnapshotsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listTableSnapshotsOptionsModel).ToNot(BeNil())
				Expect(listTableSnapshotsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(listTableSnapshotsOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(listTableSnapshotsOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(listTableSnapshotsOptionsModel.TableID).To(Equal(core.StringPtr("testString")))
				Expect(listTableSnapshotsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listTableSnapshotsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListTablesOptions successfully`, func() {
				// Construct an instance of the ListTablesOptions model
				catalogID := "testString"
				schemaID := "testString"
				engineID := "testString"
				listTablesOptionsModel := watsonxDataService.NewListTablesOptions(catalogID, schemaID, engineID)
				listTablesOptionsModel.SetCatalogID("testString")
				listTablesOptionsModel.SetSchemaID("testString")
				listTablesOptionsModel.SetEngineID("testString")
				listTablesOptionsModel.SetAuthInstanceID("testString")
				listTablesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listTablesOptionsModel).ToNot(BeNil())
				Expect(listTablesOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(listTablesOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(listTablesOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(listTablesOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listTablesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewOtherEngineDetailsBody successfully`, func() {
				connectionString := "1.2.3.4"
				engineType := "netezza"
				_model, err := watsonxDataService.NewOtherEngineDetailsBody(connectionString, engineType)
				Expect(_model).ToNot(BeNil())
				Expect(err).To(BeNil())
			})
			It(`Invoke NewPausePrestissimoEngineOptions successfully`, func() {
				// Construct an instance of the PausePrestissimoEngineOptions model
				engineID := "testString"
				pausePrestissimoEngineOptionsModel := watsonxDataService.NewPausePrestissimoEngineOptions(engineID)
				pausePrestissimoEngineOptionsModel.SetEngineID("testString")
				pausePrestissimoEngineOptionsModel.SetAuthInstanceID("testString")
				pausePrestissimoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(pausePrestissimoEngineOptionsModel).ToNot(BeNil())
				Expect(pausePrestissimoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(pausePrestissimoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(pausePrestissimoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewPausePrestoEngineOptions successfully`, func() {
				// Construct an instance of the PausePrestoEngineOptions model
				engineID := "testString"
				pausePrestoEngineOptionsModel := watsonxDataService.NewPausePrestoEngineOptions(engineID)
				pausePrestoEngineOptionsModel.SetEngineID("testString")
				pausePrestoEngineOptionsModel.SetAuthInstanceID("testString")
				pausePrestoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(pausePrestoEngineOptionsModel).ToNot(BeNil())
				Expect(pausePrestoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(pausePrestoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(pausePrestoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewPauseSparkEngineOptions successfully`, func() {
				// Construct an instance of the PauseSparkEngineOptions model
				engineID := "testString"
				pauseSparkEngineOptionsModel := watsonxDataService.NewPauseSparkEngineOptions(engineID)
				pauseSparkEngineOptionsModel.SetEngineID("testString")
				pauseSparkEngineOptionsModel.SetForce(true)
				pauseSparkEngineOptionsModel.SetAuthInstanceID("testString")
				pauseSparkEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(pauseSparkEngineOptionsModel).ToNot(BeNil())
				Expect(pauseSparkEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(pauseSparkEngineOptionsModel.Force).To(Equal(core.BoolPtr(true)))
				Expect(pauseSparkEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(pauseSparkEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewRestartPrestissimoEngineOptions successfully`, func() {
				// Construct an instance of the RestartPrestissimoEngineOptions model
				engineID := "testString"
				restartPrestissimoEngineOptionsModel := watsonxDataService.NewRestartPrestissimoEngineOptions(engineID)
				restartPrestissimoEngineOptionsModel.SetEngineID("testString")
				restartPrestissimoEngineOptionsModel.SetAuthInstanceID("testString")
				restartPrestissimoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(restartPrestissimoEngineOptionsModel).ToNot(BeNil())
				Expect(restartPrestissimoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(restartPrestissimoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(restartPrestissimoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewRestartPrestoEngineOptions successfully`, func() {
				// Construct an instance of the RestartPrestoEngineOptions model
				engineID := "testString"
				restartPrestoEngineOptionsModel := watsonxDataService.NewRestartPrestoEngineOptions(engineID)
				restartPrestoEngineOptionsModel.SetEngineID("testString")
				restartPrestoEngineOptionsModel.SetAuthInstanceID("testString")
				restartPrestoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(restartPrestoEngineOptionsModel).ToNot(BeNil())
				Expect(restartPrestoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(restartPrestoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(restartPrestoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewResumePrestissimoEngineOptions successfully`, func() {
				// Construct an instance of the ResumePrestissimoEngineOptions model
				engineID := "testString"
				resumePrestissimoEngineOptionsModel := watsonxDataService.NewResumePrestissimoEngineOptions(engineID)
				resumePrestissimoEngineOptionsModel.SetEngineID("testString")
				resumePrestissimoEngineOptionsModel.SetAuthInstanceID("testString")
				resumePrestissimoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(resumePrestissimoEngineOptionsModel).ToNot(BeNil())
				Expect(resumePrestissimoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(resumePrestissimoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(resumePrestissimoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewResumePrestoEngineOptions successfully`, func() {
				// Construct an instance of the ResumePrestoEngineOptions model
				engineID := "testString"
				resumePrestoEngineOptionsModel := watsonxDataService.NewResumePrestoEngineOptions(engineID)
				resumePrestoEngineOptionsModel.SetEngineID("testString")
				resumePrestoEngineOptionsModel.SetAuthInstanceID("testString")
				resumePrestoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(resumePrestoEngineOptionsModel).ToNot(BeNil())
				Expect(resumePrestoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(resumePrestoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(resumePrestoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewResumeSparkEngineOptions successfully`, func() {
				// Construct an instance of the ResumeSparkEngineOptions model
				engineID := "testString"
				resumeSparkEngineOptionsModel := watsonxDataService.NewResumeSparkEngineOptions(engineID)
				resumeSparkEngineOptionsModel.SetEngineID("testString")
				resumeSparkEngineOptionsModel.SetAuthInstanceID("testString")
				resumeSparkEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(resumeSparkEngineOptionsModel).ToNot(BeNil())
				Expect(resumeSparkEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(resumeSparkEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(resumeSparkEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewRollbackTableOptions successfully`, func() {
				// Construct an instance of the RollbackTableOptions model
				engineID := "testString"
				catalogID := "testString"
				schemaID := "testString"
				tableID := "testString"
				rollbackTableOptionsModel := watsonxDataService.NewRollbackTableOptions(engineID, catalogID, schemaID, tableID)
				rollbackTableOptionsModel.SetEngineID("testString")
				rollbackTableOptionsModel.SetCatalogID("testString")
				rollbackTableOptionsModel.SetSchemaID("testString")
				rollbackTableOptionsModel.SetTableID("testString")
				rollbackTableOptionsModel.SetSnapshotID("testString")
				rollbackTableOptionsModel.SetAuthInstanceID("testString")
				rollbackTableOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(rollbackTableOptionsModel).ToNot(BeNil())
				Expect(rollbackTableOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(rollbackTableOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(rollbackTableOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(rollbackTableOptionsModel.TableID).To(Equal(core.StringPtr("testString")))
				Expect(rollbackTableOptionsModel.SnapshotID).To(Equal(core.StringPtr("testString")))
				Expect(rollbackTableOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(rollbackTableOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewRunExplainAnalyzeStatementOptions successfully`, func() {
				// Construct an instance of the RunExplainAnalyzeStatementOptions model
				engineID := "testString"
				runExplainAnalyzeStatementOptionsStatement := "show schemas in catalog_name"
				runExplainAnalyzeStatementOptionsModel := watsonxDataService.NewRunExplainAnalyzeStatementOptions(engineID, runExplainAnalyzeStatementOptionsStatement)
				runExplainAnalyzeStatementOptionsModel.SetEngineID("testString")
				runExplainAnalyzeStatementOptionsModel.SetStatement("show schemas in catalog_name")
				runExplainAnalyzeStatementOptionsModel.SetVerbose(true)
				runExplainAnalyzeStatementOptionsModel.SetAuthInstanceID("testString")
				runExplainAnalyzeStatementOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(runExplainAnalyzeStatementOptionsModel).ToNot(BeNil())
				Expect(runExplainAnalyzeStatementOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(runExplainAnalyzeStatementOptionsModel.Statement).To(Equal(core.StringPtr("show schemas in catalog_name")))
				Expect(runExplainAnalyzeStatementOptionsModel.Verbose).To(Equal(core.BoolPtr(true)))
				Expect(runExplainAnalyzeStatementOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(runExplainAnalyzeStatementOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewRunExplainStatementOptions successfully`, func() {
				// Construct an instance of the RunExplainStatementOptions model
				engineID := "testString"
				runExplainStatementOptionsStatement := "show schemas in catalog_name"
				runExplainStatementOptionsModel := watsonxDataService.NewRunExplainStatementOptions(engineID, runExplainStatementOptionsStatement)
				runExplainStatementOptionsModel.SetEngineID("testString")
				runExplainStatementOptionsModel.SetStatement("show schemas in catalog_name")
				runExplainStatementOptionsModel.SetFormat("json")
				runExplainStatementOptionsModel.SetType("io")
				runExplainStatementOptionsModel.SetAuthInstanceID("testString")
				runExplainStatementOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(runExplainStatementOptionsModel).ToNot(BeNil())
				Expect(runExplainStatementOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(runExplainStatementOptionsModel.Statement).To(Equal(core.StringPtr("show schemas in catalog_name")))
				Expect(runExplainStatementOptionsModel.Format).To(Equal(core.StringPtr("json")))
				Expect(runExplainStatementOptionsModel.Type).To(Equal(core.StringPtr("io")))
				Expect(runExplainStatementOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(runExplainStatementOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewRunPrestissimoExplainAnalyzeStatementOptions successfully`, func() {
				// Construct an instance of the RunPrestissimoExplainAnalyzeStatementOptions model
				engineID := "testString"
				runPrestissimoExplainAnalyzeStatementOptionsStatement := "show schemas in catalog_name"
				runPrestissimoExplainAnalyzeStatementOptionsModel := watsonxDataService.NewRunPrestissimoExplainAnalyzeStatementOptions(engineID, runPrestissimoExplainAnalyzeStatementOptionsStatement)
				runPrestissimoExplainAnalyzeStatementOptionsModel.SetEngineID("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.SetStatement("show schemas in catalog_name")
				runPrestissimoExplainAnalyzeStatementOptionsModel.SetVerbose(true)
				runPrestissimoExplainAnalyzeStatementOptionsModel.SetAuthInstanceID("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(runPrestissimoExplainAnalyzeStatementOptionsModel).ToNot(BeNil())
				Expect(runPrestissimoExplainAnalyzeStatementOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(runPrestissimoExplainAnalyzeStatementOptionsModel.Statement).To(Equal(core.StringPtr("show schemas in catalog_name")))
				Expect(runPrestissimoExplainAnalyzeStatementOptionsModel.Verbose).To(Equal(core.BoolPtr(true)))
				Expect(runPrestissimoExplainAnalyzeStatementOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(runPrestissimoExplainAnalyzeStatementOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewRunPrestissimoExplainStatementOptions successfully`, func() {
				// Construct an instance of the RunPrestissimoExplainStatementOptions model
				engineID := "testString"
				runPrestissimoExplainStatementOptionsStatement := "show schemas in catalog_name"
				runPrestissimoExplainStatementOptionsModel := watsonxDataService.NewRunPrestissimoExplainStatementOptions(engineID, runPrestissimoExplainStatementOptionsStatement)
				runPrestissimoExplainStatementOptionsModel.SetEngineID("testString")
				runPrestissimoExplainStatementOptionsModel.SetStatement("show schemas in catalog_name")
				runPrestissimoExplainStatementOptionsModel.SetFormat("json")
				runPrestissimoExplainStatementOptionsModel.SetType("io")
				runPrestissimoExplainStatementOptionsModel.SetAuthInstanceID("testString")
				runPrestissimoExplainStatementOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(runPrestissimoExplainStatementOptionsModel).ToNot(BeNil())
				Expect(runPrestissimoExplainStatementOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(runPrestissimoExplainStatementOptionsModel.Statement).To(Equal(core.StringPtr("show schemas in catalog_name")))
				Expect(runPrestissimoExplainStatementOptionsModel.Format).To(Equal(core.StringPtr("json")))
				Expect(runPrestissimoExplainStatementOptionsModel.Type).To(Equal(core.StringPtr("io")))
				Expect(runPrestissimoExplainStatementOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(runPrestissimoExplainStatementOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewScalePrestissimoEngineOptions successfully`, func() {
				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				Expect(prestissimoNodeDescriptionBodyModel).ToNot(BeNil())
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))
				Expect(prestissimoNodeDescriptionBodyModel.NodeType).To(Equal(core.StringPtr("worker")))
				Expect(prestissimoNodeDescriptionBodyModel.Quantity).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the ScalePrestissimoEngineOptions model
				engineID := "testString"
				scalePrestissimoEngineOptionsModel := watsonxDataService.NewScalePrestissimoEngineOptions(engineID)
				scalePrestissimoEngineOptionsModel.SetEngineID("testString")
				scalePrestissimoEngineOptionsModel.SetCoordinator(prestissimoNodeDescriptionBodyModel)
				scalePrestissimoEngineOptionsModel.SetWorker(prestissimoNodeDescriptionBodyModel)
				scalePrestissimoEngineOptionsModel.SetAuthInstanceID("testString")
				scalePrestissimoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(scalePrestissimoEngineOptionsModel).ToNot(BeNil())
				Expect(scalePrestissimoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(scalePrestissimoEngineOptionsModel.Coordinator).To(Equal(prestissimoNodeDescriptionBodyModel))
				Expect(scalePrestissimoEngineOptionsModel.Worker).To(Equal(prestissimoNodeDescriptionBodyModel))
				Expect(scalePrestissimoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(scalePrestissimoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewScalePrestoEngineOptions successfully`, func() {
				// Construct an instance of the NodeDescription model
				nodeDescriptionModel := new(watsonxdatav2.NodeDescription)
				Expect(nodeDescriptionModel).ToNot(BeNil())
				nodeDescriptionModel.NodeType = core.StringPtr("worker")
				nodeDescriptionModel.Quantity = core.Int64Ptr(int64(38))
				Expect(nodeDescriptionModel.NodeType).To(Equal(core.StringPtr("worker")))
				Expect(nodeDescriptionModel.Quantity).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the ScalePrestoEngineOptions model
				engineID := "testString"
				scalePrestoEngineOptionsModel := watsonxDataService.NewScalePrestoEngineOptions(engineID)
				scalePrestoEngineOptionsModel.SetEngineID("testString")
				scalePrestoEngineOptionsModel.SetCoordinator(nodeDescriptionModel)
				scalePrestoEngineOptionsModel.SetWorker(nodeDescriptionModel)
				scalePrestoEngineOptionsModel.SetAuthInstanceID("testString")
				scalePrestoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(scalePrestoEngineOptionsModel).ToNot(BeNil())
				Expect(scalePrestoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(scalePrestoEngineOptionsModel.Coordinator).To(Equal(nodeDescriptionModel))
				Expect(scalePrestoEngineOptionsModel.Worker).To(Equal(nodeDescriptionModel))
				Expect(scalePrestoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(scalePrestoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewScaleSparkEngineOptions successfully`, func() {
				// Construct an instance of the ScaleSparkEngineOptions model
				engineID := "testString"
				scaleSparkEngineOptionsModel := watsonxDataService.NewScaleSparkEngineOptions(engineID)
				scaleSparkEngineOptionsModel.SetEngineID("testString")
				scaleSparkEngineOptionsModel.SetNumberOfNodes(int64(2))
				scaleSparkEngineOptionsModel.SetAuthInstanceID("testString")
				scaleSparkEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(scaleSparkEngineOptionsModel).ToNot(BeNil())
				Expect(scaleSparkEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(scaleSparkEngineOptionsModel.NumberOfNodes).To(Equal(core.Int64Ptr(int64(2))))
				Expect(scaleSparkEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(scaleSparkEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewStartSparkEngineHistoryServerOptions successfully`, func() {
				// Construct an instance of the StartSparkEngineHistoryServerOptions model
				engineID := "testString"
				startSparkEngineHistoryServerOptionsModel := watsonxDataService.NewStartSparkEngineHistoryServerOptions(engineID)
				startSparkEngineHistoryServerOptionsModel.SetEngineID("testString")
				startSparkEngineHistoryServerOptionsModel.SetCores("1")
				startSparkEngineHistoryServerOptionsModel.SetMemory("4G")
				startSparkEngineHistoryServerOptionsModel.SetAuthInstanceID("testString")
				startSparkEngineHistoryServerOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(startSparkEngineHistoryServerOptionsModel).ToNot(BeNil())
				Expect(startSparkEngineHistoryServerOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(startSparkEngineHistoryServerOptionsModel.Cores).To(Equal(core.StringPtr("1")))
				Expect(startSparkEngineHistoryServerOptionsModel.Memory).To(Equal(core.StringPtr("4G")))
				Expect(startSparkEngineHistoryServerOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(startSparkEngineHistoryServerOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewStorageDetails successfully`, func() {
				authMode := "<account_key/sas/service_principle>"
				containerName := "sample-container"
				endpoint := "abfss://<container_name>@<storage_account_name>.dfs.core.windows.net/"
				storageAccountName := "sample-storage"
				_model, err := watsonxDataService.NewStorageDetails(authMode, containerName, endpoint, storageAccountName)
				Expect(_model).ToNot(BeNil())
				Expect(err).To(BeNil())
			})
			It(`Invoke NewUpdateBucketRegistrationOptions successfully`, func() {
				// Construct an instance of the UpdateBucketRegistrationOptions model
				bucketID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				updateBucketRegistrationOptionsModel := watsonxDataService.NewUpdateBucketRegistrationOptions(bucketID, body)
				updateBucketRegistrationOptionsModel.SetBucketID("testString")
				updateBucketRegistrationOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updateBucketRegistrationOptionsModel.SetAuthInstanceID("testString")
				updateBucketRegistrationOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateBucketRegistrationOptionsModel).ToNot(BeNil())
				Expect(updateBucketRegistrationOptionsModel.BucketID).To(Equal(core.StringPtr("testString")))
				Expect(updateBucketRegistrationOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updateBucketRegistrationOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updateBucketRegistrationOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateColumnOptions successfully`, func() {
				// Construct an instance of the UpdateColumnOptions model
				engineID := "testString"
				catalogID := "testString"
				schemaID := "testString"
				tableID := "testString"
				columnID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				updateColumnOptionsModel := watsonxDataService.NewUpdateColumnOptions(engineID, catalogID, schemaID, tableID, columnID, body)
				updateColumnOptionsModel.SetEngineID("testString")
				updateColumnOptionsModel.SetCatalogID("testString")
				updateColumnOptionsModel.SetSchemaID("testString")
				updateColumnOptionsModel.SetTableID("testString")
				updateColumnOptionsModel.SetColumnID("testString")
				updateColumnOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updateColumnOptionsModel.SetAuthInstanceID("testString")
				updateColumnOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateColumnOptionsModel).ToNot(BeNil())
				Expect(updateColumnOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(updateColumnOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(updateColumnOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(updateColumnOptionsModel.TableID).To(Equal(core.StringPtr("testString")))
				Expect(updateColumnOptionsModel.ColumnID).To(Equal(core.StringPtr("testString")))
				Expect(updateColumnOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updateColumnOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updateColumnOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateDatabaseOptions successfully`, func() {
				// Construct an instance of the UpdateDatabaseOptions model
				databaseID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				updateDatabaseOptionsModel := watsonxDataService.NewUpdateDatabaseOptions(databaseID, body)
				updateDatabaseOptionsModel.SetDatabaseID("testString")
				updateDatabaseOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updateDatabaseOptionsModel.SetAuthInstanceID("testString")
				updateDatabaseOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateDatabaseOptionsModel).ToNot(BeNil())
				Expect(updateDatabaseOptionsModel.DatabaseID).To(Equal(core.StringPtr("testString")))
				Expect(updateDatabaseOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updateDatabaseOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updateDatabaseOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateDb2EngineOptions successfully`, func() {
				// Construct an instance of the UpdateDb2EngineOptions model
				engineID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				updateDb2EngineOptionsModel := watsonxDataService.NewUpdateDb2EngineOptions(engineID, body)
				updateDb2EngineOptionsModel.SetEngineID("testString")
				updateDb2EngineOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updateDb2EngineOptionsModel.SetAuthInstanceID("testString")
				updateDb2EngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateDb2EngineOptionsModel).ToNot(BeNil())
				Expect(updateDb2EngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(updateDb2EngineOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updateDb2EngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updateDb2EngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateIntegrationOptions successfully`, func() {
				// Construct an instance of the UpdateIntegrationOptions model
				integrationID := "testString"
				integrationPatch := map[string]interface{}{"anyKey": "anyValue"}
				updateIntegrationOptionsModel := watsonxDataService.NewUpdateIntegrationOptions(integrationID, integrationPatch)
				updateIntegrationOptionsModel.SetIntegrationID("testString")
				updateIntegrationOptionsModel.SetIntegrationPatch(map[string]interface{}{"anyKey": "anyValue"})
				updateIntegrationOptionsModel.SetAuthInstanceID("testString")
				updateIntegrationOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateIntegrationOptionsModel).ToNot(BeNil())
				Expect(updateIntegrationOptionsModel.IntegrationID).To(Equal(core.StringPtr("testString")))
				Expect(updateIntegrationOptionsModel.IntegrationPatch).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updateIntegrationOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updateIntegrationOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateMilvusServiceOptions successfully`, func() {
				// Construct an instance of the UpdateMilvusServiceOptions model
				serviceID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				updateMilvusServiceOptionsModel := watsonxDataService.NewUpdateMilvusServiceOptions(serviceID, body)
				updateMilvusServiceOptionsModel.SetServiceID("testString")
				updateMilvusServiceOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updateMilvusServiceOptionsModel.SetAuthInstanceID("testString")
				updateMilvusServiceOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateMilvusServiceOptionsModel).ToNot(BeNil())
				Expect(updateMilvusServiceOptionsModel.ServiceID).To(Equal(core.StringPtr("testString")))
				Expect(updateMilvusServiceOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updateMilvusServiceOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updateMilvusServiceOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateNetezzaEngineOptions successfully`, func() {
				// Construct an instance of the UpdateNetezzaEngineOptions model
				engineID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				updateNetezzaEngineOptionsModel := watsonxDataService.NewUpdateNetezzaEngineOptions(engineID, body)
				updateNetezzaEngineOptionsModel.SetEngineID("testString")
				updateNetezzaEngineOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updateNetezzaEngineOptionsModel.SetAuthInstanceID("testString")
				updateNetezzaEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateNetezzaEngineOptionsModel).ToNot(BeNil())
				Expect(updateNetezzaEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(updateNetezzaEngineOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updateNetezzaEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updateNetezzaEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdatePrestissimoEngineOptions successfully`, func() {
				// Construct an instance of the UpdatePrestissimoEngineOptions model
				engineID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				updatePrestissimoEngineOptionsModel := watsonxDataService.NewUpdatePrestissimoEngineOptions(engineID, body)
				updatePrestissimoEngineOptionsModel.SetEngineID("testString")
				updatePrestissimoEngineOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updatePrestissimoEngineOptionsModel.SetAuthInstanceID("testString")
				updatePrestissimoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updatePrestissimoEngineOptionsModel).ToNot(BeNil())
				Expect(updatePrestissimoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(updatePrestissimoEngineOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updatePrestissimoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updatePrestissimoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdatePrestoEngineOptions successfully`, func() {
				// Construct an instance of the UpdatePrestoEngineOptions model
				engineID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				updatePrestoEngineOptionsModel := watsonxDataService.NewUpdatePrestoEngineOptions(engineID, body)
				updatePrestoEngineOptionsModel.SetEngineID("testString")
				updatePrestoEngineOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updatePrestoEngineOptionsModel.SetAuthInstanceID("testString")
				updatePrestoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updatePrestoEngineOptionsModel).ToNot(BeNil())
				Expect(updatePrestoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(updatePrestoEngineOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updatePrestoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updatePrestoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateSalIntegrationOptions successfully`, func() {
				// Construct an instance of the UpdateSalIntegrationOptions model
				body := map[string]interface{}{"anyKey": "anyValue"}
				updateSalIntegrationOptionsModel := watsonxDataService.NewUpdateSalIntegrationOptions(body)
				updateSalIntegrationOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updateSalIntegrationOptionsModel.SetAuthInstanceID("testString")
				updateSalIntegrationOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateSalIntegrationOptionsModel).ToNot(BeNil())
				Expect(updateSalIntegrationOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updateSalIntegrationOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updateSalIntegrationOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateSparkEngineOptions successfully`, func() {
				// Construct an instance of the UpdateSparkEngineOptions model
				engineID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				updateSparkEngineOptionsModel := watsonxDataService.NewUpdateSparkEngineOptions(engineID, body)
				updateSparkEngineOptionsModel.SetEngineID("testString")
				updateSparkEngineOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updateSparkEngineOptionsModel.SetAuthInstanceID("testString")
				updateSparkEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateSparkEngineOptionsModel).ToNot(BeNil())
				Expect(updateSparkEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(updateSparkEngineOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updateSparkEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updateSparkEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateSyncCatalogOptions successfully`, func() {
				// Construct an instance of the UpdateSyncCatalogOptions model
				catalogID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				updateSyncCatalogOptionsModel := watsonxDataService.NewUpdateSyncCatalogOptions(catalogID, body)
				updateSyncCatalogOptionsModel.SetCatalogID("testString")
				updateSyncCatalogOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updateSyncCatalogOptionsModel.SetAuthInstanceID("testString")
				updateSyncCatalogOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateSyncCatalogOptionsModel).ToNot(BeNil())
				Expect(updateSyncCatalogOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(updateSyncCatalogOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updateSyncCatalogOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updateSyncCatalogOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateTableOptions successfully`, func() {
				// Construct an instance of the UpdateTableOptions model
				catalogID := "testString"
				schemaID := "testString"
				tableID := "testString"
				engineID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				updateTableOptionsModel := watsonxDataService.NewUpdateTableOptions(catalogID, schemaID, tableID, engineID, body)
				updateTableOptionsModel.SetCatalogID("testString")
				updateTableOptionsModel.SetSchemaID("testString")
				updateTableOptionsModel.SetTableID("testString")
				updateTableOptionsModel.SetEngineID("testString")
				updateTableOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updateTableOptionsModel.SetType("testString")
				updateTableOptionsModel.SetAuthInstanceID("testString")
				updateTableOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateTableOptionsModel).ToNot(BeNil())
				Expect(updateTableOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(updateTableOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(updateTableOptionsModel.TableID).To(Equal(core.StringPtr("testString")))
				Expect(updateTableOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(updateTableOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updateTableOptionsModel.Type).To(Equal(core.StringPtr("testString")))
				Expect(updateTableOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updateTableOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
		})
	})
	Describe(`Model unmarshaling tests`, func() {
		It(`Invoke UnmarshalBucketCatalog successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.BucketCatalog)
			model.CatalogName = core.StringPtr("sampleCatalog")
			model.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
			model.CatalogType = core.StringPtr("iceberg")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.BucketCatalog
			err = watsonxdatav2.UnmarshalBucketCatalog(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalBucketDetails successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.BucketDetails)
			model.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
			model.BucketName = core.StringPtr("sample-bucket")
			model.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
			model.KeyFile = core.StringPtr("key_file")
			model.Provider = core.StringPtr("ibm_cos")
			model.Region = core.StringPtr("us-south")
			model.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.BucketDetails
			err = watsonxdatav2.UnmarshalBucketDetails(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalBucketRegistrationPatch successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.BucketRegistrationPatch)
			model.BucketDetails = nil
			model.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
			model.Description = core.StringPtr("COS bucket for customer data")
			model.Tags = []string{"testbucket", "userbucket"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.BucketRegistrationPatch
			err = watsonxdatav2.UnmarshalBucketRegistrationPatch(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalColumn successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.Column)
			model.ColumnName = core.StringPtr("expenses")
			model.Comment = core.StringPtr("expenses column")
			model.Extra = core.StringPtr("varchar")
			model.Length = core.StringPtr("30")
			model.Scale = core.StringPtr("2")
			model.Precision = core.StringPtr("10")
			model.Type = core.StringPtr("varchar")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.Column
			err = watsonxdatav2.UnmarshalColumn(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalColumnPatch successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.ColumnPatch)
			model.ColumnName = core.StringPtr("expenses")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.ColumnPatch
			err = watsonxdatav2.UnmarshalColumnPatch(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalDatabaseCatalog successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.DatabaseCatalog)
			model.CatalogName = core.StringPtr("sampleCatalog")
			model.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
			model.CatalogType = core.StringPtr("iceberg")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.DatabaseCatalog
			err = watsonxdatav2.UnmarshalDatabaseCatalog(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalDatabaseDetails successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.DatabaseDetails)
			model.AuthenticationType = core.StringPtr("LDAP")
			model.AuthenticationValue = core.StringPtr("LDAP")
			model.BrokerAuthenticationPassword = core.StringPtr("samplepassword")
			model.BrokerAuthenticationType = core.StringPtr("PASSWORD")
			model.BrokerAuthenticationUser = core.StringPtr("sampleuser")
			model.BrokerHost = core.StringPtr("samplehost")
			model.BrokerPort = core.Int64Ptr(int64(4553))
			model.Certificate = core.StringPtr("contents of a pem/crt file")
			model.CertificateExtension = core.StringPtr("pem/crt")
			model.ConnectionMethod = core.StringPtr("basic, apikey")
			model.ConnectionMode = core.StringPtr("service_name")
			model.ConnectionModeValue = core.StringPtr("orclpdb")
			model.ConnectionType = core.StringPtr("JDBC, Arrow flight")
			model.ControllerAuthenticationPassword = core.StringPtr("samplepassword")
			model.ControllerAuthenticationType = core.StringPtr("PASSWORD")
			model.ControllerAuthenticationUser = core.StringPtr("sampleuser")
			model.CoordinatorHost = core.StringPtr("samplehost")
			model.CoordinatorPort = core.Int64Ptr(int64(4553))
			model.CpdHostname = core.StringPtr("samplecpdhostname")
			model.CredentialsKey = core.StringPtr("eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......")
			model.DatabaseName = core.StringPtr("new_database")
			model.DatabaseProperties = nil
			model.Hostname = core.StringPtr("db2@<hostname>.com")
			model.HostnameInCertificate = core.StringPtr("samplehostname")
			model.Hosts = core.StringPtr("abc.com:1234,xyz.com:4321")
			model.InformixServer = core.StringPtr("ol_informix1410")
			model.Password = core.StringPtr("samplepassword")
			model.Port = core.Int64Ptr(int64(4553))
			model.ProjectID = core.StringPtr("conops-bigquery")
			model.Sasl = core.BoolPtr(true)
			model.SaslMechanism = core.StringPtr("plain")
			model.SchemaName = core.StringPtr("sampleSchema")
			model.Schemas = core.StringPtr("redis__name")
			model.ServiceApiKey = core.StringPtr("sampleapikey")
			model.ServiceHostname = core.StringPtr("api.dataplatform.dev.cloud.ibm.com")
			model.ServicePassword = core.StringPtr("samplepassword")
			model.ServicePort = core.Int64Ptr(int64(443))
			model.ServiceSsl = core.BoolPtr(true)
			model.ServiceTokenURL = core.StringPtr("sampletoakenurl")
			model.ServiceUsername = core.StringPtr("sampleusername")
			model.Ssl = core.BoolPtr(true)
			model.Tables = core.StringPtr("kafka_table_name, redis_table_name")
			model.Username = core.StringPtr("sampleuser")
			model.ValidateServerCertificate = core.BoolPtr(true)
			model.VerifyHostName = core.BoolPtr(true)
			model.WarehouseName = core.StringPtr("samplewrehouse")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.DatabaseDetails
			err = watsonxdatav2.UnmarshalDatabaseDetails(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalDatabaseRegistrationPatch successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.DatabaseRegistrationPatch)
			model.DatabaseDetails = nil
			model.DatabaseDisplayName = core.StringPtr("new_database")
			model.Description = core.StringPtr("External database description")
			model.Tables = nil
			model.Tags = []string{"testdatabase", "userdatabase"}
			model.DatabaseProperties = nil
			model.Topics = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.DatabaseRegistrationPatch
			err = watsonxdatav2.UnmarshalDatabaseRegistrationPatch(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalDatabaseRegistrationPatchDatabaseDetails successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetails)
			model.AuthenticationValue = core.StringPtr("LDAP")
			model.BrokerAuthenticationPassword = core.StringPtr("samplepassword")
			model.BrokerAuthenticationType = core.StringPtr("PASSWORD")
			model.BrokerAuthenticationUser = core.StringPtr("sampleuser")
			model.ControllerAuthenticationPassword = core.StringPtr("samplepassword")
			model.ControllerAuthenticationType = core.StringPtr("PASSWORD")
			model.ControllerAuthenticationUser = core.StringPtr("sampleuser")
			model.CredentialsKey = core.StringPtr("eyJ0eXBlIjoic2VydmljZV9hY2NvdW50IiwicHJvamVjdF9pZCI6ImNvbm9wcy1iaWdxdWVyeSIsInByaXZhdGVfa2V5X2lkIjoiMGY3......")
			model.DatabaseProperties = nil
			model.Password = core.StringPtr("samplepassword")
			model.Username = core.StringPtr("sampleuser")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.DatabaseRegistrationPatchDatabaseDetails
			err = watsonxdatav2.UnmarshalDatabaseRegistrationPatchDatabaseDetails(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalDatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems)
			model.Encrypt = core.BoolPtr(true)
			model.Key = core.StringPtr("hive.metastore")
			model.Value = core.StringPtr("glue")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.DatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems
			err = watsonxdatav2.UnmarshalDatabaseRegistrationPatchDatabaseDetailsDatabasePropertiesItems(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalDatabaseRegistrationPatchTablesItems successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.DatabaseRegistrationPatchTablesItems)
			model.CreatedOn = core.StringPtr("1686792721")
			model.FileContents = core.StringPtr("sample file content")
			model.FileName = core.StringPtr("sample file name")
			model.SchemaName = core.StringPtr("customer")
			model.TableName = core.StringPtr("customer")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.DatabaseRegistrationPatchTablesItems
			err = watsonxdatav2.UnmarshalDatabaseRegistrationPatchTablesItems(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalDatabaseRegistrationPatchTopicsItems successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.DatabaseRegistrationPatchTopicsItems)
			model.CreatedOn = core.StringPtr("1686792721")
			model.FileContents = core.StringPtr("sample file contents")
			model.FileName = core.StringPtr("sample file name")
			model.TopicName = core.StringPtr("customer")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.DatabaseRegistrationPatchTopicsItems
			err = watsonxdatav2.UnmarshalDatabaseRegistrationPatchTopicsItems(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalDatabaseRegistrationPrototypeDatabasePropertiesItems successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems)
			model.Encrypt = core.BoolPtr(true)
			model.Key = core.StringPtr("hive.metastore")
			model.Value = core.StringPtr("glue")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems
			err = watsonxdatav2.UnmarshalDatabaseRegistrationPrototypeDatabasePropertiesItems(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalDb2EngineDetailsBody successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.Db2EngineDetailsBody)
			model.ConnectionString = core.StringPtr("1.2.3.4")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.Db2EngineDetailsBody
			err = watsonxdatav2.UnmarshalDb2EngineDetailsBody(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalDb2EnginePatch successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.Db2EnginePatch)
			model.Description = core.StringPtr("db2 engine updated description")
			model.EngineDisplayName = core.StringPtr("sampleEngine")
			model.Tags = []string{"tag1", "tag2"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.Db2EnginePatch
			err = watsonxdatav2.UnmarshalDb2EnginePatch(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalEngineDetailsBody successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.EngineDetailsBody)
			model.ApiKey = core.StringPtr("<api_key>")
			model.ConnectionString = core.StringPtr("1.2.3.4")
			model.Coordinator = nil
			model.InstanceID = core.StringPtr("instance_id")
			model.ManagedBy = core.StringPtr("fully/self")
			model.SizeConfig = core.StringPtr("starter")
			model.Worker = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.EngineDetailsBody
			err = watsonxdatav2.UnmarshalEngineDetailsBody(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalEnginePropertiesLogConfiguration successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.EnginePropertiesLogConfiguration)
			model.Coordinator = nil
			model.Worker = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.EnginePropertiesLogConfiguration
			err = watsonxdatav2.UnmarshalEnginePropertiesLogConfiguration(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalEnginePropertiesOaiGen1Configuration successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.EnginePropertiesOaiGen1Configuration)
			model.Coordinator = nil
			model.Worker = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.EnginePropertiesOaiGen1Configuration
			err = watsonxdatav2.UnmarshalEnginePropertiesOaiGen1Configuration(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalEnginePropertiesOaiGen1Jvm successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.EnginePropertiesOaiGen1Jvm)
			model.Coordinator = nil
			model.Worker = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.EnginePropertiesOaiGen1Jvm
			err = watsonxdatav2.UnmarshalEnginePropertiesOaiGen1Jvm(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalEnginePropertiesOaiGenConfiguration successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.EnginePropertiesOaiGenConfiguration)
			model.Coordinator = nil
			model.Worker = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.EnginePropertiesOaiGenConfiguration
			err = watsonxdatav2.UnmarshalEnginePropertiesOaiGenConfiguration(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalEnrichmentObj successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.EnrichmentObj)
			model.Catalog = core.StringPtr("iceberg_data")
			model.Operation = core.StringPtr("create")
			model.Schema = core.StringPtr("testString")
			model.Tables = []string{"testString"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.EnrichmentObj
			err = watsonxdatav2.UnmarshalEnrichmentObj(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalIngestionJobPrototypeCsvProperty successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.IngestionJobPrototypeCsvProperty)
			model.Encoding = core.StringPtr("utf-8")
			model.EscapeCharacter = core.StringPtr("\\\\")
			model.FieldDelimiter = core.StringPtr(",")
			model.Header = core.BoolPtr(true)
			model.LineDelimiter = core.StringPtr("\\n")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.IngestionJobPrototypeCsvProperty
			err = watsonxdatav2.UnmarshalIngestionJobPrototypeCsvProperty(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalIngestionJobPrototypeExecuteConfig successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.IngestionJobPrototypeExecuteConfig)
			model.DriverCores = core.Int64Ptr(int64(1))
			model.DriverMemory = core.StringPtr("2G")
			model.ExecutorCores = core.Int64Ptr(int64(1))
			model.ExecutorMemory = core.StringPtr("2G")
			model.NumExecutors = core.Int64Ptr(int64(1))

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.IngestionJobPrototypeExecuteConfig
			err = watsonxdatav2.UnmarshalIngestionJobPrototypeExecuteConfig(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalIntegrationPatch successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.IntegrationPatch)
			model.Apikey = core.StringPtr("apikey")
			model.EnableDataPolicyWithinWxd = core.BoolPtr(false)
			model.Password = core.StringPtr("password")
			model.Resource = core.StringPtr("presto01")
			model.StorageCatalogs = []string{"iceberg_data", "hive_data"}
			model.URL = core.StringPtr("ikc.url")
			model.Username = core.StringPtr("username@email.com")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.IntegrationPatch
			err = watsonxdatav2.UnmarshalIntegrationPatch(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalMilvusServicePatch successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.MilvusServicePatch)
			model.Description = core.StringPtr("updated description for milvus service")
			model.ServiceDisplayName = core.StringPtr("sampleService")
			model.Tags = []string{"tag1", "tag2"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.MilvusServicePatch
			err = watsonxdatav2.UnmarshalMilvusServicePatch(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalNetezzaEngineDetailsBody successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.NetezzaEngineDetailsBody)
			model.ConnectionString = core.StringPtr("1.2.3.4")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.NetezzaEngineDetailsBody
			err = watsonxdatav2.UnmarshalNetezzaEngineDetailsBody(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalNetezzaEnginePatch successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.NetezzaEnginePatch)
			model.Description = core.StringPtr("netezza engine updated description")
			model.EngineDisplayName = core.StringPtr("sampleEngine")
			model.Tags = []string{"tag1", "tag2"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.NetezzaEnginePatch
			err = watsonxdatav2.UnmarshalNetezzaEnginePatch(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalNodeDescription successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.NodeDescription)
			model.NodeType = core.StringPtr("worker")
			model.Quantity = core.Int64Ptr(int64(38))

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.NodeDescription
			err = watsonxdatav2.UnmarshalNodeDescription(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalNodeDescriptionBody successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.NodeDescriptionBody)
			model.NodeType = core.StringPtr("worker")
			model.Quantity = core.Int64Ptr(int64(38))

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.NodeDescriptionBody
			err = watsonxdatav2.UnmarshalNodeDescriptionBody(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalOtherEngineDetailsBody successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.OtherEngineDetailsBody)
			model.ConnectionString = core.StringPtr("1.2.3.4")
			model.EngineType = core.StringPtr("netezza")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.OtherEngineDetailsBody
			err = watsonxdatav2.UnmarshalOtherEngineDetailsBody(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPath successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.Path)
			model.Path = core.StringPtr("string")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.Path
			err = watsonxdatav2.UnmarshalPath(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestissimoEndpoints successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestissimoEndpoints)
			model.ApplicationsApi = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>")
			model.HistoryServerEndpoint = core.StringPtr("$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server")
			model.SparkAccessEndpoint = core.StringPtr("$HOST/analytics-engine/details/spark-<instance_id>")
			model.SparkJobsV4Endpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications")
			model.SparkKernelEndpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels")
			model.ViewHistoryServer = core.StringPtr("testString")
			model.WxdApplicationEndpoint = core.StringPtr("$HOST/v1/1698311655308796/engines/spark817/applications")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestissimoEndpoints
			err = watsonxdatav2.UnmarshalPrestissimoEndpoints(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestissimoEngineDetails successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestissimoEngineDetails)
			model.ApiKey = core.StringPtr("<api_key>")
			model.ConnectionString = core.StringPtr("1.2.3.4")
			model.Coordinator = nil
			model.Endpoints = nil
			model.InstanceID = core.StringPtr("instance_id")
			model.ManagedBy = core.StringPtr("fully/self")
			model.MetastoreHost = core.StringPtr("1.2.3.4")
			model.SizeConfig = core.StringPtr("starter")
			model.Worker = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestissimoEngineDetails
			err = watsonxdatav2.UnmarshalPrestissimoEngineDetails(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestissimoEngineEngineProperties successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestissimoEngineEngineProperties)
			model.Catalog = nil
			model.Configuration = nil
			model.Velox = nil
			model.Global = nil
			model.Jvm = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestissimoEngineEngineProperties
			err = watsonxdatav2.UnmarshalPrestissimoEngineEngineProperties(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestissimoEnginePatch successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestissimoEnginePatch)
			model.Description = core.StringPtr("updated description for prestissimo engine")
			model.EngineDisplayName = core.StringPtr("sampleEngine")
			model.EngineProperties = nil
			model.EngineRestart = core.StringPtr("force")
			model.RemoveEngineProperties = nil
			model.Tags = []string{"tag1", "tag2"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestissimoEnginePatch
			err = watsonxdatav2.UnmarshalPrestissimoEnginePatch(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestissimoEnginePropertiesCatalog successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestissimoEnginePropertiesCatalog)
			model.CatalogName = []string{"testString"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestissimoEnginePropertiesCatalog
			err = watsonxdatav2.UnmarshalPrestissimoEnginePropertiesCatalog(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestissimoEnginePropertiesGlobal successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestissimoEnginePropertiesGlobal)
			model.GlobalProperty = core.StringPtr("enable-mixed-case-support:true")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestissimoEnginePropertiesGlobal
			err = watsonxdatav2.UnmarshalPrestissimoEnginePropertiesGlobal(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestissimoEnginePropertiesOaiGen1Jvm successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestissimoEnginePropertiesOaiGen1Jvm)
			model.Coordinator = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestissimoEnginePropertiesOaiGen1Jvm
			err = watsonxdatav2.UnmarshalPrestissimoEnginePropertiesOaiGen1Jvm(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestissimoEnginePropertiesVelox successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestissimoEnginePropertiesVelox)
			model.VeloxProperty = []string{"testString"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestissimoEnginePropertiesVelox
			err = watsonxdatav2.UnmarshalPrestissimoEnginePropertiesVelox(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestissimoNodeDescriptionBody successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
			model.NodeType = core.StringPtr("worker")
			model.Quantity = core.Int64Ptr(int64(38))

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestissimoNodeDescriptionBody
			err = watsonxdatav2.UnmarshalPrestissimoNodeDescriptionBody(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestoEngineEngineProperties successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestoEngineEngineProperties)
			model.Catalog = nil
			model.Configuration = nil
			model.EventListener = nil
			model.Global = nil
			model.Jvm = nil
			model.LogConfig = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestoEngineEngineProperties
			err = watsonxdatav2.UnmarshalPrestoEngineEngineProperties(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestoEnginePatch successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestoEnginePatch)
			model.Description = core.StringPtr("updated description for presto engine")
			model.EngineDisplayName = core.StringPtr("sampleEngine")
			model.EngineProperties = nil
			model.EngineRestart = core.StringPtr("force")
			model.RemoveEngineProperties = nil
			model.Tags = []string{"tag1", "tag2"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestoEnginePatch
			err = watsonxdatav2.UnmarshalPrestoEnginePatch(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestoEnginePatchRemoveEngineProperties successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestoEnginePatchRemoveEngineProperties)
			model.Catalog = nil
			model.Configuration = nil
			model.Jvm = nil
			model.EventListener = []string{}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestoEnginePatchRemoveEngineProperties
			err = watsonxdatav2.UnmarshalPrestoEnginePatchRemoveEngineProperties(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestoEnginePropertiesCatalog successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestoEnginePropertiesCatalog)
			model.CatalogName = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestoEnginePropertiesCatalog
			err = watsonxdatav2.UnmarshalPrestoEnginePropertiesCatalog(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestoEnginePropertiesEventListener successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestoEnginePropertiesEventListener)
			model.EventListenerProperty = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestoEnginePropertiesEventListener
			err = watsonxdatav2.UnmarshalPrestoEnginePropertiesEventListener(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestoEnginePropertiesGlobal successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestoEnginePropertiesGlobal)
			model.GlobalProperty = core.StringPtr("enable-mixed-case-support:true")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestoEnginePropertiesGlobal
			err = watsonxdatav2.UnmarshalPrestoEnginePropertiesGlobal(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPreviewIngestionFilePrototypeCsvProperty successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PreviewIngestionFilePrototypeCsvProperty)
			model.Encoding = core.StringPtr("utf-8")
			model.EscapeCharacter = core.StringPtr("\\\\")
			model.FieldDelimiter = core.StringPtr(",")
			model.Header = core.BoolPtr(true)
			model.LineDelimiter = core.StringPtr("\\n")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PreviewIngestionFilePrototypeCsvProperty
			err = watsonxdatav2.UnmarshalPreviewIngestionFilePrototypeCsvProperty(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalRemoveEngineProperties successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.RemoveEngineProperties)
			model.Catalog = nil
			model.Configuration = nil
			model.Jvm = nil
			model.Velox = []string{"testString"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.RemoveEngineProperties
			err = watsonxdatav2.UnmarshalRemoveEngineProperties(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalRemoveEnginePropertiesConfiguration successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.RemoveEnginePropertiesConfiguration)
			model.Coordinator = []string{"testString"}
			model.Worker = []string{"testString"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.RemoveEnginePropertiesConfiguration
			err = watsonxdatav2.UnmarshalRemoveEnginePropertiesConfiguration(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalRemoveEnginePropertiesOaiGenConfiguration successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.RemoveEnginePropertiesOaiGenConfiguration)
			model.Coordinator = []string{"testString"}
			model.Worker = []string{"testString"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.RemoveEnginePropertiesOaiGenConfiguration
			err = watsonxdatav2.UnmarshalRemoveEnginePropertiesOaiGenConfiguration(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalRemoveEnginePropertiesOaiGenJvm successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.RemoveEnginePropertiesOaiGenJvm)
			model.Coordinator = []string{"testString"}
			model.Worker = []string{"testString"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.RemoveEnginePropertiesOaiGenJvm
			err = watsonxdatav2.UnmarshalRemoveEnginePropertiesOaiGenJvm(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalRemoveEnginePropertiesPrestissimoOaiGenJvm successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.RemoveEnginePropertiesPrestissimoOaiGenJvm)
			model.Coordinator = []string{"testString"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.RemoveEnginePropertiesPrestissimoOaiGenJvm
			err = watsonxdatav2.UnmarshalRemoveEnginePropertiesPrestissimoOaiGenJvm(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSalIntegrationEnrichmentSettings successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SalIntegrationEnrichmentSettings)
			model.SemanticExpansion = nil
			model.TermAssignment = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SalIntegrationEnrichmentSettings
			err = watsonxdatav2.UnmarshalSalIntegrationEnrichmentSettings(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSalIntegrationEnrichmentSettingsSemanticExpansion successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansion)
			model.DescriptionGeneration = core.BoolPtr(true)
			model.DescriptionGenerationConfiguration = nil
			model.NameExpansion = core.BoolPtr(true)
			model.NameExpansionConfiguration = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansion
			err = watsonxdatav2.UnmarshalSalIntegrationEnrichmentSettingsSemanticExpansion(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration)
			model.AssignmentThreshold = core.Float64Ptr(float64(0.14))
			model.SuggestionThreshold = core.Float64Ptr(float64(0.9))

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration
			err = watsonxdatav2.UnmarshalSalIntegrationEnrichmentSettingsSemanticExpansionDescriptionGenerationConfiguration(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration)
			model.AssignmentThreshold = core.Float64Ptr(float64(0.1))
			model.SuggestionThreshold = core.Float64Ptr(float64(0.1))

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration
			err = watsonxdatav2.UnmarshalSalIntegrationEnrichmentSettingsSemanticExpansionNameExpansionConfiguration(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSalIntegrationEnrichmentSettingsTermAssignment successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SalIntegrationEnrichmentSettingsTermAssignment)
			model.ClassBasedAssignments = core.BoolPtr(false)
			model.EvaluateNegativeAssignments = core.BoolPtr(false)
			model.LlmBasedAssignments = core.BoolPtr(false)
			model.MlBasedAssignmentsCustom = core.BoolPtr(false)
			model.MlBasedAssignmentsDefault = core.BoolPtr(false)
			model.NameMatching = core.BoolPtr(false)
			model.TermAssignmentThreshold = core.Float64Ptr(float64(0.3))
			model.TermSuggestionThreshold = core.Float64Ptr(float64(0.4))

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SalIntegrationEnrichmentSettingsTermAssignment
			err = watsonxdatav2.UnmarshalSalIntegrationEnrichmentSettingsTermAssignment(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSalIntegrationPatch successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SalIntegrationPatch)
			model.Op = core.StringPtr("add")
			model.Path = core.StringPtr("storage")
			model.Value = core.StringPtr("new-apikey")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SalIntegrationPatch
			err = watsonxdatav2.UnmarshalSalIntegrationPatch(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSparkApplicationConfig successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SparkApplicationConfig)
			model.SparkSampleConfigProperpty = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SparkApplicationConfig
			err = watsonxdatav2.UnmarshalSparkApplicationConfig(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSparkApplicationDetails successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SparkApplicationDetails)
			model.Application = core.StringPtr("s3://mybucket/wordcount.py")
			model.Arguments = []string{"people.txt"}
			model.Class = core.StringPtr("org.apache.spark.examples.SparkPi")
			model.Conf = nil
			model.Env = nil
			model.Files = core.StringPtr("s3://mybucket/myfile.txt")
			model.Jars = core.StringPtr("testString")
			model.Name = core.StringPtr("SparkApplicaton1")
			model.Packages = core.StringPtr("org.apache.spark:example_1.2.3")
			model.Repositories = core.StringPtr("https://repo1.maven.org/maven2/")
			model.SparkVersion = core.StringPtr("3.3")
			model.Runtime = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SparkApplicationDetails
			err = watsonxdatav2.UnmarshalSparkApplicationDetails(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSparkApplicationDetailsRuntime successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SparkApplicationDetailsRuntime)
			model.SparkVersion = core.StringPtr("3.4")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SparkApplicationDetailsRuntime
			err = watsonxdatav2.UnmarshalSparkApplicationDetailsRuntime(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSparkApplicationEnv successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SparkApplicationEnv)
			model.SampleEnvKey = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SparkApplicationEnv
			err = watsonxdatav2.UnmarshalSparkApplicationEnv(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSparkDefaultConfig successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SparkDefaultConfig)
			model.Config1 = core.StringPtr("testString")
			model.Config2 = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SparkDefaultConfig
			err = watsonxdatav2.UnmarshalSparkDefaultConfig(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSparkEngineDetailsPrototype successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SparkEngineDetailsPrototype)
			model.ApiKey = core.StringPtr("apikey")
			model.ConnectionString = core.StringPtr("1.2.3.4")
			model.DefaultConfig = nil
			model.DefaultVersion = core.StringPtr("4.8.3")
			model.EngineHomeBucketDisplayName = core.StringPtr("test-spark-bucket")
			model.EngineHomeBucketName = core.StringPtr("test-spark-bucket")
			model.EngineHomePath = core.StringPtr("spark/spark1234")
			model.EngineHomeVolumeID = core.StringPtr("1704979825978585")
			model.EngineHomeVolumeName = core.StringPtr("my-volume")
			model.EngineHomeVolumeStorageClass = core.StringPtr("nfs-client")
			model.EngineHomeVolumeStorageSize = core.StringPtr("5Gi")
			model.InstanceID = core.StringPtr("spark-id")
			model.EngineSubType = core.StringPtr("java/cpp")
			model.ManagedBy = core.StringPtr("fully/self")
			model.ScaleConfig = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SparkEngineDetailsPrototype
			err = watsonxdatav2.UnmarshalSparkEngineDetailsPrototype(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSparkEngineResourceLimit successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SparkEngineResourceLimit)
			model.Cores = core.StringPtr("1")
			model.Memory = core.StringPtr("4G")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SparkEngineResourceLimit
			err = watsonxdatav2.UnmarshalSparkEngineResourceLimit(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSparkScaleConfig successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SparkScaleConfig)
			model.AutoScaleEnabled = core.BoolPtr(true)
			model.CurrentNumberOfNodes = core.Int64Ptr(int64(2))
			model.MaximumNumberOfNodes = core.Int64Ptr(int64(5))
			model.MinimumNumberOfNodes = core.Int64Ptr(int64(1))
			model.NodeType = core.StringPtr("medium")
			model.NumberOfNodes = core.Int64Ptr(int64(2))

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SparkScaleConfig
			err = watsonxdatav2.UnmarshalSparkScaleConfig(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSparkVolumeDetails successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SparkVolumeDetails)
			model.MountPath = core.StringPtr("/mount/path")
			model.Name = core.StringPtr("my-volume")
			model.ReadOnly = core.BoolPtr(true)
			model.SourceSubPath = core.StringPtr("/source/path")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SparkVolumeDetails
			err = watsonxdatav2.UnmarshalSparkVolumeDetails(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalStorageDetails successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.StorageDetails)
			model.AccessKey = core.StringPtr("<access_key>")
			model.ApplicationID = core.StringPtr("<application_id>")
			model.AuthMode = core.StringPtr("<account_key/sas/service_principle>")
			model.ContainerName = core.StringPtr("sample-container")
			model.DirectoryID = core.StringPtr("<directory_id>")
			model.Endpoint = core.StringPtr("abfss://<container_name>@<storage_account_name>.dfs.core.windows.net/")
			model.SasToken = core.StringPtr("<sas_token>")
			model.SecretKey = core.StringPtr("secret_key")
			model.StorageAccountName = core.StringPtr("sample-storage")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.StorageDetails
			err = watsonxdatav2.UnmarshalStorageDetails(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSyncCatalogs successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SyncCatalogs)
			model.AutoAddNewTables = core.BoolPtr(true)
			model.SyncIcebergMd = core.BoolPtr(true)

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SyncCatalogs
			err = watsonxdatav2.UnmarshalSyncCatalogs(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalTablePatch successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.TablePatch)
			model.TableName = core.StringPtr("updated_table_name")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.TablePatch
			err = watsonxdatav2.UnmarshalTablePatch(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalUpdateSparkEngineBody successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.UpdateSparkEngineBody)
			model.Description = core.StringPtr("updated description for spark engine")
			model.EngineDetails = nil
			model.EngineDisplayName = core.StringPtr("sampleEngine")
			model.Tags = []string{"tag1", "tag2"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.UpdateSparkEngineBody
			err = watsonxdatav2.UnmarshalUpdateSparkEngineBody(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalUpdateSparkEngineBodyEngineDetails successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.UpdateSparkEngineBodyEngineDetails)
			model.DefaultConfig = map[string]string{"key1": "testString"}
			model.DefaultVersion = core.StringPtr("4.8.3")
			model.EngineHomeBucketName = core.StringPtr("test-spark-bucket")
			model.ResourceLimitEnabled = core.BoolPtr(true)
			model.ResourceLimits = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.UpdateSparkEngineBodyEngineDetails
			err = watsonxdatav2.UnmarshalUpdateSparkEngineBodyEngineDetails(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
	})
	Describe(`Utility function tests`, func() {
		It(`Invoke CreateMockByteArray() successfully`, func() {
			mockByteArray := CreateMockByteArray("VGhpcyBpcyBhIHRlc3Qgb2YgdGhlIGVtZXJnZW5jeSBicm9hZGNhc3Qgc3lzdGVt")
			Expect(mockByteArray).ToNot(BeNil())
		})
		It(`Invoke CreateMockUUID() successfully`, func() {
			mockUUID := CreateMockUUID("9fab83da-98cb-4f18-a7ba-b6f0435c9673")
			Expect(mockUUID).ToNot(BeNil())
		})
		It(`Invoke CreateMockReader() successfully`, func() {
			mockReader := CreateMockReader("This is a test.")
			Expect(mockReader).ToNot(BeNil())
		})
		It(`Invoke CreateMockDate() successfully`, func() {
			mockDate := CreateMockDate("2019-01-01")
			Expect(mockDate).ToNot(BeNil())
		})
		It(`Invoke CreateMockDateTime() successfully`, func() {
			mockDateTime := CreateMockDateTime("2019-01-01T12:00:00.000Z")
			Expect(mockDateTime).ToNot(BeNil())
		})
	})
})

//
// Utility functions used by the generated test code
//

func CreateMockByteArray(encodedString string) *[]byte {
	ba, err := base64.StdEncoding.DecodeString(encodedString)
	if err != nil {
		panic(err)
	}
	return &ba
}

func CreateMockUUID(mockData string) *strfmt.UUID {
	uuid := strfmt.UUID(mockData)
	return &uuid
}

func CreateMockReader(mockData string) io.ReadCloser {
	return io.NopCloser(bytes.NewReader([]byte(mockData)))
}

func CreateMockDate(mockData string) *strfmt.Date {
	d, err := core.ParseDate(mockData)
	if err != nil {
		return nil
	}
	return &d
}

func CreateMockDateTime(mockData string) *strfmt.DateTime {
	d, err := core.ParseDateTime(mockData)
	if err != nil {
		return nil
	}
	return &d
}

func SetTestEnvironment(testEnvironment map[string]string) {
	for key, value := range testEnvironment {
		os.Setenv(key, value)
	}
}

func ClearTestEnvironment(testEnvironment map[string]string) {
	for key := range testEnvironment {
		os.Unsetenv(key)
	}
}
